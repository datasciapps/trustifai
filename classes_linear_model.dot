digraph "classes_linear_model" {
rankdir=BT
charset="utf-8"
"sklearn.linear_model._bayes.ARDRegression" [color="black", fontcolor="black", label=<{ARDRegression|X_offset_ : ndarray<br ALIGN="LEFT"/>X_scale_<br ALIGN="LEFT"/>alpha_<br ALIGN="LEFT"/>alpha_1 : float<br ALIGN="LEFT"/>alpha_2 : float<br ALIGN="LEFT"/>coef_ : ndarray<br ALIGN="LEFT"/>compute_score : bool<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>lambda_ : ndarray<br ALIGN="LEFT"/>lambda_1 : float<br ALIGN="LEFT"/>lambda_2 : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>scores_ : list<br ALIGN="LEFT"/>sigma_ : tuple<br ALIGN="LEFT"/>threshold_lambda : float<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X, return_std)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._stochastic_gradient.BaseSGD" [color="black", fontcolor="black", label=<{BaseSGD|C : float<br ALIGN="LEFT"/>alpha : float<br ALIGN="LEFT"/>average : bool<br ALIGN="LEFT"/>coef_ : ndarray<br ALIGN="LEFT"/>early_stopping : bool<br ALIGN="LEFT"/>epsilon : float<br ALIGN="LEFT"/>eta0 : float<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_ : ndarray<br ALIGN="LEFT"/>l1_ratio : float<br ALIGN="LEFT"/>learning_rate : str<br ALIGN="LEFT"/>loss<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_iter_no_change : int<br ALIGN="LEFT"/>offset_ : ndarray<br ALIGN="LEFT"/>penalty : str<br ALIGN="LEFT"/>power_t : float<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>shuffle : bool<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>validation_fraction : float<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>warm_start : bool<br ALIGN="LEFT"/>|<I>fit</I>(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._stochastic_gradient.BaseSGDClassifier" [color="black", fontcolor="black", label=<{BaseSGDClassifier|class_weight : NoneType<br ALIGN="LEFT"/>coef_ : NoneType, ndarray<br ALIGN="LEFT"/>intercept_ : NoneType, ndarray, tuple<br ALIGN="LEFT"/>loss_functions : dict<br ALIGN="LEFT"/>n_iter_ : float<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>t_ : float<br ALIGN="LEFT"/>|fit(X, y, coef_init, intercept_init, sample_weight)<br ALIGN="LEFT"/>partial_fit(X, y, classes, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._stochastic_gradient.BaseSGDRegressor" [color="black", fontcolor="black", label=<{BaseSGDRegressor|coef_ : NoneType, ndarray<br ALIGN="LEFT"/>intercept_ : NoneType, tuple<br ALIGN="LEFT"/>loss_functions : dict<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>t_ : float<br ALIGN="LEFT"/>|fit(X, y, coef_init, intercept_init, sample_weight)<br ALIGN="LEFT"/>partial_fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._bayes.BayesianRidge" [color="black", fontcolor="black", label=<{BayesianRidge|X_offset_ : ndarray<br ALIGN="LEFT"/>X_scale_<br ALIGN="LEFT"/>alpha_<br ALIGN="LEFT"/>alpha_1 : float<br ALIGN="LEFT"/>alpha_2 : float<br ALIGN="LEFT"/>alpha_init : NoneType<br ALIGN="LEFT"/>coef_ : ndarray<br ALIGN="LEFT"/>compute_score : bool<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>lambda_<br ALIGN="LEFT"/>lambda_1 : float<br ALIGN="LEFT"/>lambda_2 : float<br ALIGN="LEFT"/>lambda_init : NoneType<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>scores_ : list, ndarray<br ALIGN="LEFT"/>sigma_<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict(X, return_std)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._glm.tests.test_glm.BinomialRegressor" [color="black", fontcolor="black", label=<{BinomialRegressor|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model.tests.test_coordinate_descent.test_multitask_cv_estimators_with_sample_weight.CVSplitter" [color="black", fontcolor="black", label=<{CVSplitter|<br ALIGN="LEFT"/>|<I>get_n_splits</I>(X, y, groups, metadata)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model.tests.test_coordinate_descent.test_multitask_cv_estimators_with_sample_weight.CVSplitterSampleWeight" [color="black", fontcolor="black", label=<{CVSplitterSampleWeight|<br ALIGN="LEFT"/>|split(X, y, groups, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._coordinate_descent.ElasticNet" [color="black", fontcolor="black", label=<{ElasticNet|alpha : float<br ALIGN="LEFT"/>coef_ : list, ndarray<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>dual_gap_ : ndarray<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>l1_ratio : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_iter_ : list<br ALIGN="LEFT"/>path : staticmethod<br ALIGN="LEFT"/>positive : bool<br ALIGN="LEFT"/>precompute : bool<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>selection : str<br ALIGN="LEFT"/>sparse_coef_<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>warm_start : bool<br ALIGN="LEFT"/>|fit(X, y, sample_weight, check_input)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._coordinate_descent.ElasticNetCV" [color="black", fontcolor="black", label=<{ElasticNetCV|alphas : NoneType<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>cv : NoneType<br ALIGN="LEFT"/>eps : float<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>l1_ratio : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_alphas : int<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>path : staticmethod<br ALIGN="LEFT"/>positive : bool<br ALIGN="LEFT"/>precompute : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>selection : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._glm.glm.GammaRegressor" [color="black", fontcolor="black", label=<{GammaRegressor|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._huber.HuberRegressor" [color="black", fontcolor="black", label=<{HuberRegressor|alpha : float<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>epsilon : float<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_ : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>outliers_<br ALIGN="LEFT"/>scale_<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>warm_start : bool<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._least_angle.Lars" [color="black", fontcolor="black", label=<{Lars|active_ : list<br ALIGN="LEFT"/>alphas_ : list<br ALIGN="LEFT"/>coef_ : ndarray<br ALIGN="LEFT"/>coef_path_ : list<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>eps<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>fit_path : bool<br ALIGN="LEFT"/>jitter : NoneType<br ALIGN="LEFT"/>method : str<br ALIGN="LEFT"/>n_iter_ : list<br ALIGN="LEFT"/>n_nonzero_coefs : int<br ALIGN="LEFT"/>positive : bool<br ALIGN="LEFT"/>precompute : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|fit(X, y, Xy)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._least_angle.LarsCV" [color="black", fontcolor="black", label=<{LarsCV|alpha_<br ALIGN="LEFT"/>cv : NoneType<br ALIGN="LEFT"/>cv_alphas_<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>max_n_alphas : int<br ALIGN="LEFT"/>method : str<br ALIGN="LEFT"/>mse_path_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>parameter : str<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._coordinate_descent.Lasso" [color="black", fontcolor="black", label=<{Lasso|alpha<br ALIGN="LEFT"/>path : staticmethod<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._coordinate_descent.LassoCV" [color="black", fontcolor="black", label=<{LassoCV|path : staticmethod<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._least_angle.LassoLars" [color="black", fontcolor="black", label=<{LassoLars|alpha : float<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>eps<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>fit_path : bool<br ALIGN="LEFT"/>jitter : NoneType<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>method : str<br ALIGN="LEFT"/>positive : bool<br ALIGN="LEFT"/>precompute : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._least_angle.LassoLarsCV" [color="black", fontcolor="black", label=<{LassoLarsCV|copy_X : bool<br ALIGN="LEFT"/>cv : NoneType<br ALIGN="LEFT"/>eps<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>max_n_alphas : int<br ALIGN="LEFT"/>method : str<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>positive : bool<br ALIGN="LEFT"/>precompute : str<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._least_angle.LassoLarsIC" [color="black", fontcolor="black", label=<{LassoLarsIC|alpha_<br ALIGN="LEFT"/>alphas_ : ndarray<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>criterion : str<br ALIGN="LEFT"/>criterion_<br ALIGN="LEFT"/>eps<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>fit_path : bool<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_iter_ : int<br ALIGN="LEFT"/>noise_variance : NoneType<br ALIGN="LEFT"/>noise_variance_<br ALIGN="LEFT"/>parameter : str<br ALIGN="LEFT"/>positive : bool<br ALIGN="LEFT"/>precompute : str<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|fit(X, y, copy_X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model.tests.test_coordinate_descent.test_lassoCV_does_not_set_precompute.LassoMock" [color="black", fontcolor="black", label=<{LassoMock|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._base.LinearClassifierMixin" [color="black", fontcolor="black", label=<{LinearClassifierMixin|<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._base.LinearModel" [color="black", fontcolor="black", label=<{LinearModel|coef_<br ALIGN="LEFT"/>intercept_ : float<br ALIGN="LEFT"/>|<I>fit</I>(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._coordinate_descent.LinearModelCV" [color="black", fontcolor="black", label=<{LinearModelCV|alpha_<br ALIGN="LEFT"/>alphas : NoneType<br ALIGN="LEFT"/>alphas_<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>cv : NoneType<br ALIGN="LEFT"/>dual_gap_<br ALIGN="LEFT"/>eps : float<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_<br ALIGN="LEFT"/>l1_ratio_<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>mse_path_<br ALIGN="LEFT"/>n_alphas : int<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>positive : bool<br ALIGN="LEFT"/>precompute : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>selection : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/><I>path</I>(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._linear_loss.LinearModelLoss" [color="black", fontcolor="black", label=<{LinearModelLoss|base_loss<br ALIGN="LEFT"/>fit_intercept<br ALIGN="LEFT"/>|gradient(coef, X, y, sample_weight, l2_reg_strength, n_threads, raw_prediction)<br ALIGN="LEFT"/>gradient_hessian(coef, X, y, sample_weight, l2_reg_strength, n_threads, gradient_out, hessian_out, raw_prediction)<br ALIGN="LEFT"/>gradient_hessian_product(coef, X, y, sample_weight, l2_reg_strength, n_threads)<br ALIGN="LEFT"/>init_zero_coef(X, dtype)<br ALIGN="LEFT"/>l2_penalty(weights, l2_reg_strength)<br ALIGN="LEFT"/>loss(coef, X, y, sample_weight, l2_reg_strength, n_threads, raw_prediction)<br ALIGN="LEFT"/>loss_gradient(coef, X, y, sample_weight, l2_reg_strength, n_threads, raw_prediction)<br ALIGN="LEFT"/>weight_intercept(coef)<br ALIGN="LEFT"/>weight_intercept_raw(coef, X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._base.LinearRegression" [color="black", fontcolor="black", label=<{LinearRegression|coef_ : list, ndarray, tuple<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>positive : bool<br ALIGN="LEFT"/>rank_ : int<br ALIGN="LEFT"/>singular_ : NoneType, ndarray<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._logistic.LogisticRegression" [color="black", fontcolor="black", label=<{LogisticRegression|C : float<br ALIGN="LEFT"/>class_weight : NoneType<br ALIGN="LEFT"/>classes_ : ndarray, tuple<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>dual : bool<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_ : float, ndarray<br ALIGN="LEFT"/>intercept_scaling : int<br ALIGN="LEFT"/>l1_ratio : NoneType<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>multi_class : str<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>penalty : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>solver : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>warm_start : bool<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._logistic.LogisticRegressionCV" [color="black", fontcolor="black", label=<{LogisticRegressionCV|C_ : list<br ALIGN="LEFT"/>Cs : int<br ALIGN="LEFT"/>Cs_<br ALIGN="LEFT"/>class_weight : NoneType<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>coef_ : ndarray<br ALIGN="LEFT"/>coefs_paths_ : dict<br ALIGN="LEFT"/>cv : NoneType<br ALIGN="LEFT"/>dual : bool<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_ : ndarray<br ALIGN="LEFT"/>intercept_scaling : float<br ALIGN="LEFT"/>l1_ratio_ : list<br ALIGN="LEFT"/>l1_ratios : NoneType<br ALIGN="LEFT"/>l1_ratios_<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>multi_class : str<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>param : str<br ALIGN="LEFT"/>penalty : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>refit : bool<br ALIGN="LEFT"/>scores_ : dict<br ALIGN="LEFT"/>scoring : NoneType<br ALIGN="LEFT"/>solver : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>score(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model.tests.test_logistic.test_logistic_cv_mock_scorer.MockScorer" [color="black", fontcolor="black", label=<{MockScorer|calls : int<br ALIGN="LEFT"/>scores : list<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._coordinate_descent.MultiTaskElasticNet" [color="black", fontcolor="black", label=<{MultiTaskElasticNet|alpha : float<br ALIGN="LEFT"/>coef_ : ndarray<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>dual_gap_<br ALIGN="LEFT"/>eps_<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>l1_ratio : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>param : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>selection : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>warm_start : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._coordinate_descent.MultiTaskElasticNetCV" [color="black", fontcolor="black", label=<{MultiTaskElasticNetCV|alphas : NoneType<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>cv : NoneType<br ALIGN="LEFT"/>eps : float<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>l1_ratio : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_alphas : int<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>path : staticmethod<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>selection : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._coordinate_descent.MultiTaskLasso" [color="black", fontcolor="black", label=<{MultiTaskLasso|alpha : float<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>l1_ratio : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>selection : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>warm_start : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._coordinate_descent.MultiTaskLassoCV" [color="black", fontcolor="black", label=<{MultiTaskLassoCV|path : staticmethod<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model.tests.test_passive_aggressive.MyPassiveAggressive" [color="black", fontcolor="black", label=<{MyPassiveAggressive|C : float<br ALIGN="LEFT"/>b : float<br ALIGN="LEFT"/>epsilon : float<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>loss : str<br ALIGN="LEFT"/>n_iter : int<br ALIGN="LEFT"/>w : ndarray<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>project(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model.tests.test_perceptron.MyPerceptron" [color="black", fontcolor="black", label=<{MyPerceptron|b : float<br ALIGN="LEFT"/>n_iter : int<br ALIGN="LEFT"/>w : ndarray<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>project(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._glm._newton_solver.NewtonCholeskySolver" [color="black", fontcolor="black", label=<{NewtonCholeskySolver|coef : ndarray<br ALIGN="LEFT"/>coef_newton : matrix, ndarray<br ALIGN="LEFT"/>gradient : ndarray<br ALIGN="LEFT"/>gradient_times_newton<br ALIGN="LEFT"/>hessian : ndarray<br ALIGN="LEFT"/>hessian_warning : bool<br ALIGN="LEFT"/>is_multinomial_no_penalty<br ALIGN="LEFT"/>is_multinomial_with_intercept<br ALIGN="LEFT"/>iteration : int<br ALIGN="LEFT"/>use_fallback_lbfgs_solve : bool<br ALIGN="LEFT"/>|finalize(X, y, sample_weight)<br ALIGN="LEFT"/>inner_solve(X, y, sample_weight)<br ALIGN="LEFT"/>setup(X, y, sample_weight)<br ALIGN="LEFT"/>update_gradient_hessian(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._glm._newton_solver.NewtonSolver" [color="black", fontcolor="black", label=<{NewtonSolver|coef : ndarray<br ALIGN="LEFT"/>coef_old : ndarray<br ALIGN="LEFT"/>converged : bool<br ALIGN="LEFT"/>gradient : ndarray<br ALIGN="LEFT"/>gradient_old : ndarray<br ALIGN="LEFT"/>iteration : int<br ALIGN="LEFT"/>l2_reg_strength : float<br ALIGN="LEFT"/>linear_loss<br ALIGN="LEFT"/>loss_value<br ALIGN="LEFT"/>loss_value_old<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_threads : int<br ALIGN="LEFT"/>raw_prediction<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>use_fallback_lbfgs_solve : bool<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|check_convergence(X, y, sample_weight)<br ALIGN="LEFT"/>fallback_lbfgs_solve(X, y, sample_weight)<br ALIGN="LEFT"/><I>finalize</I>(X, y, sample_weight)<br ALIGN="LEFT"/><I>inner_solve</I>(X, y, sample_weight)<br ALIGN="LEFT"/>line_search(X, y, sample_weight)<br ALIGN="LEFT"/>setup(X, y, sample_weight)<br ALIGN="LEFT"/>solve(X, y, sample_weight)<br ALIGN="LEFT"/><I>update_gradient_hessian</I>(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._omp.OrthogonalMatchingPursuit" [color="black", fontcolor="black", label=<{OrthogonalMatchingPursuit|coef_ : ndarray<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>n_iter_ : list<br ALIGN="LEFT"/>n_nonzero_coefs : NoneType<br ALIGN="LEFT"/>n_nonzero_coefs_ : NoneType<br ALIGN="LEFT"/>precompute : str<br ALIGN="LEFT"/>tol : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._omp.OrthogonalMatchingPursuitCV" [color="black", fontcolor="black", label=<{OrthogonalMatchingPursuitCV|coef_<br ALIGN="LEFT"/>copy : bool<br ALIGN="LEFT"/>cv : NoneType<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_ : float<br ALIGN="LEFT"/>max_iter : NoneType<br ALIGN="LEFT"/>n_iter_ : list<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>n_nonzero_coefs_<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._passive_aggressive.PassiveAggressiveClassifier" [color="black", fontcolor="black", label=<{PassiveAggressiveClassifier|C : float<br ALIGN="LEFT"/>loss : str<br ALIGN="LEFT"/>|fit(X, y, coef_init, intercept_init)<br ALIGN="LEFT"/>partial_fit(X, y, classes)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._passive_aggressive.PassiveAggressiveRegressor" [color="black", fontcolor="black", label=<{PassiveAggressiveRegressor|C : float<br ALIGN="LEFT"/>loss : str<br ALIGN="LEFT"/>|fit(X, y, coef_init, intercept_init)<br ALIGN="LEFT"/>partial_fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._perceptron.Perceptron" [color="black", fontcolor="black", label=<{Perceptron|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._glm.glm.PoissonRegressor" [color="black", fontcolor="black", label=<{PoissonRegressor|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._quantile.QuantileRegressor" [color="black", fontcolor="black", label=<{QuantileRegressor|alpha : float<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_ : float<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>quantile : float<br ALIGN="LEFT"/>solver : str<br ALIGN="LEFT"/>solver_options : NoneType<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._ransac.RANSACRegressor" [color="black", fontcolor="black", label=<{RANSACRegressor|estimator : NoneType<br ALIGN="LEFT"/>estimator_<br ALIGN="LEFT"/>inlier_mask_ : NoneType<br ALIGN="LEFT"/>is_data_valid : NoneType<br ALIGN="LEFT"/>is_model_valid : NoneType<br ALIGN="LEFT"/>loss : str<br ALIGN="LEFT"/>max_skips<br ALIGN="LEFT"/>max_trials : int<br ALIGN="LEFT"/>min_samples : NoneType<br ALIGN="LEFT"/>n_skips_invalid_data_ : int<br ALIGN="LEFT"/>n_skips_invalid_model_ : int<br ALIGN="LEFT"/>n_skips_no_inliers_ : int<br ALIGN="LEFT"/>n_trials_ : int<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>residual_threshold : NoneType<br ALIGN="LEFT"/>stop_n_inliers<br ALIGN="LEFT"/>stop_probability : float<br ALIGN="LEFT"/>stop_score<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>score(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._ridge.Ridge" [color="black", fontcolor="black", label=<{Ridge|<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._ridge.RidgeCV" [color="black", fontcolor="black", label=<{RidgeCV|<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._ridge.RidgeClassifier" [color="black", fontcolor="black", label=<{RidgeClassifier|class_weight : NoneType<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._ridge.RidgeClassifierCV" [color="black", fontcolor="black", label=<{RidgeClassifierCV|class_weight : NoneType<br ALIGN="LEFT"/>param : str<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._stochastic_gradient.SGDClassifier" [color="black", fontcolor="black", label=<{SGDClassifier|<br ALIGN="LEFT"/>|predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._stochastic_gradient.SGDOneClassSVM" [color="black", fontcolor="black", label=<{SGDOneClassSVM|coef_ : NoneType, ndarray<br ALIGN="LEFT"/>loss_functions : dict<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>nu : float<br ALIGN="LEFT"/>offset_ : NoneType<br ALIGN="LEFT"/>t_ : float<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y, coef_init, offset_init, sample_weight)<br ALIGN="LEFT"/>partial_fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>score_samples(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._stochastic_gradient.SGDRegressor" [color="black", fontcolor="black", label=<{SGDRegressor|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._base.SparseCoefMixin" [color="black", fontcolor="black", label=<{SparseCoefMixin|coef_ : csr_matrix, ndarray<br ALIGN="LEFT"/>|densify()<br ALIGN="LEFT"/>sparsify()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._theil_sen.TheilSenRegressor" [color="black", fontcolor="black", label=<{TheilSenRegressor|breakdown_<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>copy_X : str<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_ : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>max_subpopulation : float<br ALIGN="LEFT"/>n_iter_ : int<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>n_subpopulation_ : int<br ALIGN="LEFT"/>n_subsamples : NoneType<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._glm.glm.TweedieRegressor" [color="black", fontcolor="black", label=<{TweedieRegressor|link : str<br ALIGN="LEFT"/>power : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._ridge._BaseRidge" [color="black", fontcolor="black", label=<{_BaseRidge|alpha : float<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_<br ALIGN="LEFT"/>max_iter : NoneType<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>positive : bool<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>solver : str<br ALIGN="LEFT"/>solver_<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._ridge._BaseRidgeCV" [color="black", fontcolor="black", label=<{_BaseRidgeCV|alpha_ : NoneType<br ALIGN="LEFT"/>alpha_per_target : bool<br ALIGN="LEFT"/>alphas : tuple<br ALIGN="LEFT"/>best_score_ : NoneType, tuple<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>cv : NoneType<br ALIGN="LEFT"/>cv_results_ : ndarray<br ALIGN="LEFT"/>cv_values_<br ALIGN="LEFT"/>feature_names_in_<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>gcv_mode : NoneType<br ALIGN="LEFT"/>intercept_ : float<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>scoring : NoneType<br ALIGN="LEFT"/>store_cv_results : NoneType<br ALIGN="LEFT"/>store_cv_values : str<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._glm.glm._GeneralizedLinearRegressor" [color="black", fontcolor="black", label=<{_GeneralizedLinearRegressor|alpha : float<br ALIGN="LEFT"/>coef_ : ndarray<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_ : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_iter_ : int<br ALIGN="LEFT"/>solver : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>warm_start : bool<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>score(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._ridge._IdentityClassifier" [color="black", fontcolor="black", label=<{_IdentityClassifier|classes_<br ALIGN="LEFT"/>|decision_function(y_predict)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._ridge._IdentityRegressor" [color="black", fontcolor="black", label=<{_IdentityRegressor|<br ALIGN="LEFT"/>|decision_function(y_predict)<br ALIGN="LEFT"/>predict(y_predict)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._ridge._RidgeClassifierMixin" [color="black", fontcolor="black", label=<{_RidgeClassifierMixin|classes_<br ALIGN="LEFT"/>|predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._ridge._RidgeGCV" [color="black", fontcolor="black", label=<{_RidgeGCV|alpha_ : NoneType, ndarray<br ALIGN="LEFT"/>alpha_per_target : bool<br ALIGN="LEFT"/>alphas : tuple<br ALIGN="LEFT"/>best_score_ : NoneType, tuple<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>cv_results_ : ndarray<br ALIGN="LEFT"/>dual_coef_ : NoneType, ndarray<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>gcv_mode : NoneType<br ALIGN="LEFT"/>is_clf : bool<br ALIGN="LEFT"/>scoring : NoneType<br ALIGN="LEFT"/>store_cv_results : bool<br ALIGN="LEFT"/>|fit(X, y, sample_weight, score_params)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model.tests.test_sgd._SparseSGDClassifier" [color="black", fontcolor="black", label=<{_SparseSGDClassifier|<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>partial_fit(X, y)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model.tests.test_sgd._SparseSGDOneClassSVM" [color="black", fontcolor="black", label=<{_SparseSGDOneClassSVM|<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X)<br ALIGN="LEFT"/>partial_fit(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model.tests.test_sgd._SparseSGDRegressor" [color="black", fontcolor="black", label=<{_SparseSGDRegressor|<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>partial_fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._stochastic_gradient._ValidationScoreCallback" [color="black", fontcolor="black", label=<{_ValidationScoreCallback|X_val<br ALIGN="LEFT"/>estimator<br ALIGN="LEFT"/>sample_weight_val<br ALIGN="LEFT"/>y_val<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._ridge._XT_CenterStackOp" [color="black", fontcolor="black", label=<{_XT_CenterStackOp|X<br ALIGN="LEFT"/>X_mean<br ALIGN="LEFT"/>sqrt_sw<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._ridge._X_CenterStackOp" [color="black", fontcolor="black", label=<{_X_CenterStackOp|X<br ALIGN="LEFT"/>X_mean<br ALIGN="LEFT"/>sqrt_sw<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._base.LinearRegression" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._bayes.ARDRegression" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._bayes.BayesianRidge" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.ElasticNet" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.ElasticNetCV" -> "sklearn.linear_model._coordinate_descent.LinearModelCV" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.Lasso" -> "sklearn.linear_model._coordinate_descent.ElasticNet" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.LassoCV" -> "sklearn.linear_model._coordinate_descent.LinearModelCV" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.LinearModelCV" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.MultiTaskElasticNet" -> "sklearn.linear_model._coordinate_descent.Lasso" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.MultiTaskElasticNetCV" -> "sklearn.linear_model._coordinate_descent.LinearModelCV" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.MultiTaskLasso" -> "sklearn.linear_model._coordinate_descent.MultiTaskElasticNet" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.MultiTaskLassoCV" -> "sklearn.linear_model._coordinate_descent.LinearModelCV" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._glm._newton_solver.NewtonCholeskySolver" -> "sklearn.linear_model._glm._newton_solver.NewtonSolver" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._glm.glm.GammaRegressor" -> "sklearn.linear_model._glm.glm._GeneralizedLinearRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._glm.glm.PoissonRegressor" -> "sklearn.linear_model._glm.glm._GeneralizedLinearRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._glm.glm.TweedieRegressor" -> "sklearn.linear_model._glm.glm._GeneralizedLinearRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._glm.tests.test_glm.BinomialRegressor" -> "sklearn.linear_model._glm.glm._GeneralizedLinearRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._huber.HuberRegressor" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._least_angle.Lars" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._least_angle.LarsCV" -> "sklearn.linear_model._least_angle.Lars" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._least_angle.LassoLars" -> "sklearn.linear_model._least_angle.Lars" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._least_angle.LassoLarsCV" -> "sklearn.linear_model._least_angle.LarsCV" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._least_angle.LassoLarsIC" -> "sklearn.linear_model._least_angle.LassoLars" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._logistic.LogisticRegression" -> "sklearn.linear_model._base.LinearClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._logistic.LogisticRegression" -> "sklearn.linear_model._base.SparseCoefMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._logistic.LogisticRegressionCV" -> "sklearn.linear_model._base.LinearClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._logistic.LogisticRegressionCV" -> "sklearn.linear_model._logistic.LogisticRegression" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._omp.OrthogonalMatchingPursuit" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._omp.OrthogonalMatchingPursuitCV" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._passive_aggressive.PassiveAggressiveClassifier" -> "sklearn.linear_model._stochastic_gradient.BaseSGDClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._passive_aggressive.PassiveAggressiveRegressor" -> "sklearn.linear_model._stochastic_gradient.BaseSGDRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._perceptron.Perceptron" -> "sklearn.linear_model._stochastic_gradient.BaseSGDClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._quantile.QuantileRegressor" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge.Ridge" -> "sklearn.linear_model._ridge._BaseRidge" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge.RidgeCV" -> "sklearn.linear_model._ridge._BaseRidgeCV" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge.RidgeClassifier" -> "sklearn.linear_model._ridge._BaseRidge" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge.RidgeClassifier" -> "sklearn.linear_model._ridge._RidgeClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge.RidgeClassifierCV" -> "sklearn.linear_model._ridge._BaseRidgeCV" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge.RidgeClassifierCV" -> "sklearn.linear_model._ridge._RidgeClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge._BaseRidge" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge._BaseRidgeCV" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge._IdentityClassifier" -> "sklearn.linear_model._base.LinearClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge._RidgeClassifierMixin" -> "sklearn.linear_model._base.LinearClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge._RidgeGCV" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._stochastic_gradient.BaseSGD" -> "sklearn.linear_model._base.SparseCoefMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._stochastic_gradient.BaseSGDClassifier" -> "sklearn.linear_model._base.LinearClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._stochastic_gradient.BaseSGDClassifier" -> "sklearn.linear_model._stochastic_gradient.BaseSGD" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._stochastic_gradient.BaseSGDRegressor" -> "sklearn.linear_model._stochastic_gradient.BaseSGD" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._stochastic_gradient.SGDClassifier" -> "sklearn.linear_model._stochastic_gradient.BaseSGDClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._stochastic_gradient.SGDOneClassSVM" -> "sklearn.linear_model._stochastic_gradient.BaseSGD" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._stochastic_gradient.SGDRegressor" -> "sklearn.linear_model._stochastic_gradient.BaseSGDRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._theil_sen.TheilSenRegressor" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model.tests.test_coordinate_descent.test_lassoCV_does_not_set_precompute.LassoMock" -> "sklearn.linear_model._coordinate_descent.Lasso" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model.tests.test_coordinate_descent.test_multitask_cv_estimators_with_sample_weight.CVSplitterSampleWeight" -> "sklearn.linear_model.tests.test_coordinate_descent.test_multitask_cv_estimators_with_sample_weight.CVSplitter" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model.tests.test_sgd._SparseSGDClassifier" -> "sklearn.linear_model._stochastic_gradient.SGDClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model.tests.test_sgd._SparseSGDOneClassSVM" -> "sklearn.linear_model._stochastic_gradient.SGDOneClassSVM" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model.tests.test_sgd._SparseSGDRegressor" -> "sklearn.linear_model._stochastic_gradient.SGDRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._linear_loss.LinearModelLoss" -> "sklearn.linear_model._glm._newton_solver.NewtonSolver" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="linear_loss", style="solid"];
}
