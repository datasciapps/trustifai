digraph "classes_sklearn" {
rankdir=BT
charset="utf-8"
"sklearn.feature_extraction.tests.test_dict_vectorizer.test_dict_vectorizer_unsupported_value_type.A" [color="black", fontcolor="black", label=<{A|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_metadata_routing.test_unbound_set_methods_work.A" [color="black", fontcolor="black", label=<{A|<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_set_output.test_set_output_mro.A" [color="black", fontcolor="black", label=<{A|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_validation.test_deprecate_positional_args_warns_for_class.A1" [color="black", fontcolor="black", label=<{A1|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_validation.test_deprecate_positional_args_warns_for_class.A2" [color="black", fontcolor="black", label=<{A2|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._bayes.ARDRegression" [color="black", fontcolor="black", label=<{ARDRegression|X_offset_ : ndarray<br ALIGN="LEFT"/>X_scale_<br ALIGN="LEFT"/>alpha_<br ALIGN="LEFT"/>alpha_1 : float<br ALIGN="LEFT"/>alpha_2 : float<br ALIGN="LEFT"/>coef_ : ndarray<br ALIGN="LEFT"/>compute_score : bool<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>lambda_ : ndarray<br ALIGN="LEFT"/>lambda_1 : float<br ALIGN="LEFT"/>lambda_2 : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>scores_ : list<br ALIGN="LEFT"/>sigma_ : tuple<br ALIGN="LEFT"/>threshold_lambda : float<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X, return_std)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn._loss.loss.AbsoluteError" [color="black", fontcolor="black", label=<{AbsoluteError|approx_hessian : bool<br ALIGN="LEFT"/>constant_hessian<br ALIGN="LEFT"/>differentiable : bool<br ALIGN="LEFT"/>need_update_leaves_values : bool<br ALIGN="LEFT"/>|fit_intercept_only(y_true, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble._weight_boosting.AdaBoostClassifier" [color="black", fontcolor="black", label=<{AdaBoostClassifier|algorithm : str<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>n_classes_<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>staged_decision_function(X)<br ALIGN="LEFT"/>staged_predict(X)<br ALIGN="LEFT"/>staged_predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble._weight_boosting.AdaBoostRegressor" [color="black", fontcolor="black", label=<{AdaBoostRegressor|loss : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>|predict(X)<br ALIGN="LEFT"/>staged_predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.neural_network._stochastic_optimizers.AdamOptimizer" [color="black", fontcolor="black", label=<{AdamOptimizer|beta_1 : float<br ALIGN="LEFT"/>beta_2 : float<br ALIGN="LEFT"/>epsilon : float<br ALIGN="LEFT"/>learning_rate<br ALIGN="LEFT"/>ms<br ALIGN="LEFT"/>t : int<br ALIGN="LEFT"/>vs<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_pipeline.test_pipeline_get_feature_names_out_passes_names_through.AddPrefixStandardScalar" [color="black", fontcolor="black", label=<{AddPrefixStandardScalar|<br ALIGN="LEFT"/>|get_feature_names_out(input_features)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.kernel_approximation.AdditiveChi2Sampler" [color="black", fontcolor="black", label=<{AdditiveChi2Sampler|sample_interval : NoneType<br ALIGN="LEFT"/>sample_steps : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.cluster._affinity_propagation.AffinityPropagation" [color="black", fontcolor="black", label=<{AffinityPropagation|affinity : str<br ALIGN="LEFT"/>affinity_matrix_ : str, tuple<br ALIGN="LEFT"/>cluster_centers_<br ALIGN="LEFT"/>cluster_centers_indices_ : ndarray<br ALIGN="LEFT"/>convergence_iter : int<br ALIGN="LEFT"/>copy : bool<br ALIGN="LEFT"/>damping : float<br ALIGN="LEFT"/>labels_ : ndarray<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_iter_ : int<br ALIGN="LEFT"/>preference : NoneType<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_predict(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.cluster._feature_agglomeration.AgglomerationTransform" [color="black", fontcolor="black", label=<{AgglomerationTransform|<br ALIGN="LEFT"/>|inverse_transform(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.cluster._agglomerative.AgglomerativeClustering" [color="black", fontcolor="black", label=<{AgglomerativeClustering|children_<br ALIGN="LEFT"/>compute_distances : bool<br ALIGN="LEFT"/>compute_full_tree : bool, str<br ALIGN="LEFT"/>connectivity : NoneType<br ALIGN="LEFT"/>distance_threshold : NoneType<br ALIGN="LEFT"/>distances_<br ALIGN="LEFT"/>labels_ : ndarray<br ALIGN="LEFT"/>linkage : str<br ALIGN="LEFT"/>memory : NoneType<br ALIGN="LEFT"/>metric : str<br ALIGN="LEFT"/>n_clusters : int<br ALIGN="LEFT"/>n_clusters_ : int<br ALIGN="LEFT"/>n_connected_components_<br ALIGN="LEFT"/>n_leaves_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_predict(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble.tests.test_base.test_set_random_states.AlphaParamPipeline" [color="black", fontcolor="black", label=<{AlphaParamPipeline|<br ALIGN="LEFT"/>|get_params()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_set_output.AnotherMixin" [color="black", fontcolor="black", label=<{AnotherMixin|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.externals._arff.ArffContainerType" [color="black", fontcolor="black", label=<{ArffContainerType|attributes : List<br ALIGN="LEFT"/>data : Union[ArffDenseDataType, ArffSparseDataType]<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>relation : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.externals._arff.ArffDecoder" [color="black", fontcolor="black", label=<{ArffDecoder|<br ALIGN="LEFT"/>|decode(s, encode_nominal, return_type)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.externals._arff.ArffEncoder" [color="black", fontcolor="black", label=<{ArffEncoder|<br ALIGN="LEFT"/>|encode(obj)<br ALIGN="LEFT"/>iter_encode(obj)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.externals._arff.ArffException" [color="black", fontcolor="red", label=<{ArffException|line : int<br ALIGN="LEFT"/>message : Optional[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.metrics._pairwise_distances_reduction._dispatcher.ArgKmin" [color="black", fontcolor="black", label=<{ArgKmin|<br ALIGN="LEFT"/>|compute(X, Y, k, metric, chunk_size, metric_kwargs, strategy, return_distance)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.metrics._pairwise_distances_reduction._dispatcher.ArgKminClassMode" [color="black", fontcolor="black", label=<{ArgKminClassMode|<br ALIGN="LEFT"/>|compute(X, Y, k, weights, Y_labels, unique_Y_labels, metric, chunk_size, metric_kwargs, strategy)<br ALIGN="LEFT"/>valid_metrics(): List[str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_array_api.test_device_inspection.Array" [color="black", fontcolor="black", label=<{Array|device<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils._mocking.ArraySlicingWrapper" [color="black", fontcolor="black", label=<{ArraySlicingWrapper|array<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_metaestimators.AvailableParameterEstimator" [color="black", fontcolor="black", label=<{AvailableParameterEstimator|available : bool<br ALIGN="LEFT"/>return_value : int<br ALIGN="LEFT"/>|available_func()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_set_output.test_set_output_mro.B" [color="black", fontcolor="black", label=<{B|<br ALIGN="LEFT"/>|transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.externals._arff.BadAttributeFormat" [color="black", fontcolor="red", label=<{BadAttributeFormat|message : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.externals._arff.BadAttributeName" [color="black", fontcolor="red", label=<{BadAttributeName|message<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.externals._arff.BadAttributeType" [color="black", fontcolor="red", label=<{BadAttributeType|message : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.BadBalancedWeightsClassifier" [color="black", fontcolor="black", label=<{BadBalancedWeightsClassifier|class_weight : NoneType<br ALIGN="LEFT"/>coef_ : ndarray<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_validation.test_cross_val_predict.BadCV" [color="black", fontcolor="black", label=<{BadCV|<br ALIGN="LEFT"/>|split(X, y, groups)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.externals._arff.BadDataFormat" [color="black", fontcolor="red", label=<{BadDataFormat|message<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_set_output.test_auto_wrap_output_keys_errors_with_incorrect_input.BadEstimator" [color="black", fontcolor="black", label=<{BadEstimator|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.test_check_classifier_not_supporting_multiclass.BadEstimator" [color="black", fontcolor="black", label=<{BadEstimator|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.test_check_mixin_order.BadEstimator" [color="black", fontcolor="black", label=<{BadEstimator|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.test_check_estimator_tags_renamed.BadEstimator1" [color="black", fontcolor="black", label=<{BadEstimator1|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.test_check_estimator_tags_renamed.BadEstimator2" [color="black", fontcolor="black", label=<{BadEstimator2|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.externals._arff.BadLayout" [color="black", fontcolor="red", label=<{BadLayout|message : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.externals._arff.BadNominalFormatting" [color="black", fontcolor="red", label=<{BadNominalFormatting|message<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.externals._arff.BadNominalValue" [color="black", fontcolor="red", label=<{BadNominalValue|message<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.externals._arff.BadNumericalValue" [color="black", fontcolor="red", label=<{BadNumericalValue|message : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.externals._arff.BadObject" [color="black", fontcolor="red", label=<{BadObject|msg : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.externals._arff.BadRelationFormat" [color="black", fontcolor="red", label=<{BadRelationFormat|message : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_search.test__custom_fit_no_run_search.BadSearchCV" [color="black", fontcolor="black", label=<{BadSearchCV|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.externals._arff.BadStringValue" [color="black", fontcolor="red", label=<{BadStringValue|message : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.BadTransformerWithoutMixin" [color="black", fontcolor="black", label=<{BadTransformerWithoutMixin|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble._bagging.BaggingClassifier" [color="black", fontcolor="black", label=<{BaggingClassifier|classes_<br ALIGN="LEFT"/>estimators_ : list<br ALIGN="LEFT"/>n_classes_<br ALIGN="LEFT"/>oob_decision_function_<br ALIGN="LEFT"/>oob_score_ : float<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble._bagging.BaggingRegressor" [color="black", fontcolor="black", label=<{BaggingRegressor|oob_prediction_ : ndarray<br ALIGN="LEFT"/>oob_score_ : float<br ALIGN="LEFT"/>|predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_metadata_routing.test_default_request_override.Base" [color="black", fontcolor="black", label=<{Base|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_set_output.test_set_output_mro.Base" [color="black", fontcolor="black", label=<{Base|<br ALIGN="LEFT"/>|transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.BaseBadClassifier" [color="black", fontcolor="black", label=<{BaseBadClassifier|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble._bagging.BaseBagging" [color="black", fontcolor="black", label=<{BaseBagging|bootstrap : bool<br ALIGN="LEFT"/>bootstrap_features : bool<br ALIGN="LEFT"/>estimators_ : list<br ALIGN="LEFT"/>estimators_features_ : list<br ALIGN="LEFT"/>estimators_samples_<br ALIGN="LEFT"/>max_features : float<br ALIGN="LEFT"/>max_samples : float<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>oob_score : bool<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>warm_start : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._split.BaseCrossValidator" [color="black", fontcolor="black", label=<{BaseCrossValidator|<br ALIGN="LEFT"/>|<I>get_n_splits</I>(X, y, groups)<br ALIGN="LEFT"/>split(X, y, groups)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tree._classes.BaseDecisionTree" [color="black", fontcolor="black", label=<{BaseDecisionTree|ccp_alpha : float<br ALIGN="LEFT"/>class_weight : NoneType<br ALIGN="LEFT"/>classes_ : list<br ALIGN="LEFT"/>criterion<br ALIGN="LEFT"/>feature_importances_<br ALIGN="LEFT"/>max_depth<br ALIGN="LEFT"/>max_features<br ALIGN="LEFT"/>max_features_ : int<br ALIGN="LEFT"/>max_leaf_nodes<br ALIGN="LEFT"/>min_impurity_decrease<br ALIGN="LEFT"/>min_samples_leaf<br ALIGN="LEFT"/>min_samples_split<br ALIGN="LEFT"/>min_weight_fraction_leaf<br ALIGN="LEFT"/>monotonic_cst : NoneType<br ALIGN="LEFT"/>n_classes_ : list, ndarray<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>n_outputs_<br ALIGN="LEFT"/>random_state<br ALIGN="LEFT"/>splitter<br ALIGN="LEFT"/>tree_<br ALIGN="LEFT"/>|apply(X, check_input)<br ALIGN="LEFT"/>cost_complexity_pruning_path(X, y, sample_weight)<br ALIGN="LEFT"/>decision_path(X, check_input)<br ALIGN="LEFT"/>get_depth()<br ALIGN="LEFT"/>get_n_leaves()<br ALIGN="LEFT"/>predict(X, check_input)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.metrics._pairwise_distances_reduction._dispatcher.BaseDistancesReductionDispatcher" [color="black", fontcolor="black", label=<{BaseDistancesReductionDispatcher|<br ALIGN="LEFT"/>|<I>compute</I>(X, Y)<br ALIGN="LEFT"/>is_usable_for(X, Y, metric): bool<br ALIGN="LEFT"/>valid_metrics(): List[str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble._base.BaseEnsemble" [color="black", fontcolor="black", label=<{BaseEnsemble|estimator : NoneType<br ALIGN="LEFT"/>estimator_ : NoneType<br ALIGN="LEFT"/>estimator_params : tuple<br ALIGN="LEFT"/>n_estimators : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.base.BaseEstimator" [color="black", fontcolor="black", label=<{BaseEstimator|<br ALIGN="LEFT"/>|get_params(deep)<br ALIGN="LEFT"/>set_params()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble._forest.BaseForest" [color="black", fontcolor="black", label=<{BaseForest|bootstrap : bool<br ALIGN="LEFT"/>class_weight : NoneType<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>estimators_ : list<br ALIGN="LEFT"/>estimators_samples_<br ALIGN="LEFT"/>feature_importances_<br ALIGN="LEFT"/>max_samples : NoneType<br ALIGN="LEFT"/>n_classes_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>n_outputs_<br ALIGN="LEFT"/>oob_score : bool<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>warm_start : bool<br ALIGN="LEFT"/>|apply(X)<br ALIGN="LEFT"/>decision_path(X)<br ALIGN="LEFT"/>fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble._gb.BaseGradientBoosting" [color="black", fontcolor="black", label=<{BaseGradientBoosting|alpha : float<br ALIGN="LEFT"/>ccp_alpha<br ALIGN="LEFT"/>criterion<br ALIGN="LEFT"/>estimators_ : ndarray<br ALIGN="LEFT"/>feature_importances_<br ALIGN="LEFT"/>init<br ALIGN="LEFT"/>init_<br ALIGN="LEFT"/>learning_rate<br ALIGN="LEFT"/>loss<br ALIGN="LEFT"/>max_depth<br ALIGN="LEFT"/>max_features<br ALIGN="LEFT"/>max_features_<br ALIGN="LEFT"/>max_leaf_nodes : NoneType<br ALIGN="LEFT"/>min_impurity_decrease<br ALIGN="LEFT"/>min_samples_leaf<br ALIGN="LEFT"/>min_samples_split<br ALIGN="LEFT"/>min_weight_fraction_leaf<br ALIGN="LEFT"/>n_estimators<br ALIGN="LEFT"/>n_estimators_ : int<br ALIGN="LEFT"/>n_iter_no_change : NoneType<br ALIGN="LEFT"/>oob_improvement_ : ndarray<br ALIGN="LEFT"/>oob_score_<br ALIGN="LEFT"/>oob_scores_ : ndarray<br ALIGN="LEFT"/>random_state<br ALIGN="LEFT"/>subsample<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>train_score_ : ndarray<br ALIGN="LEFT"/>validation_fraction : float<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>warm_start : bool<br ALIGN="LEFT"/>|apply(X)<br ALIGN="LEFT"/>fit(X, y, sample_weight, monitor)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.covariance._graph_lasso.BaseGraphicalLasso" [color="black", fontcolor="black", label=<{BaseGraphicalLasso|enet_tol : float<br ALIGN="LEFT"/>eps<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>mode : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.ensemble._hist_gradient_boosting.gradient_boosting.BaseHistGradientBoosting" [color="black", fontcolor="black", label=<{BaseHistGradientBoosting|categorical_features<br ALIGN="LEFT"/>do_early_stopping_<br ALIGN="LEFT"/>early_stopping<br ALIGN="LEFT"/>feature_names_in_<br ALIGN="LEFT"/>interaction_cst<br ALIGN="LEFT"/>is_categorical_ : NoneType, ndarray<br ALIGN="LEFT"/>l2_regularization<br ALIGN="LEFT"/>learning_rate<br ALIGN="LEFT"/>loss<br ALIGN="LEFT"/>max_bins<br ALIGN="LEFT"/>max_depth<br ALIGN="LEFT"/>max_features<br ALIGN="LEFT"/>max_iter<br ALIGN="LEFT"/>max_leaf_nodes<br ALIGN="LEFT"/>min_samples_leaf<br ALIGN="LEFT"/>monotonic_cst<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>n_iter_no_change<br ALIGN="LEFT"/>random_state<br ALIGN="LEFT"/>scoring<br ALIGN="LEFT"/>tol<br ALIGN="LEFT"/>train_score_ : list<br ALIGN="LEFT"/>validation_fraction<br ALIGN="LEFT"/>validation_score_ : list<br ALIGN="LEFT"/>verbose<br ALIGN="LEFT"/>warm_start<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.semi_supervised._label_propagation.BaseLabelPropagation" [color="black", fontcolor="black", label=<{BaseLabelPropagation|X_<br ALIGN="LEFT"/>alpha : int<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>gamma : int<br ALIGN="LEFT"/>kernel : str<br ALIGN="LEFT"/>label_distributions_ : ndarray<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>n_neighbors : int<br ALIGN="LEFT"/>nn_fit<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>transduction_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.svm._base.BaseLibSVM" [color="black", fontcolor="black", label=<{BaseLibSVM|C<br ALIGN="LEFT"/>cache_size<br ALIGN="LEFT"/>class_weight<br ALIGN="LEFT"/>coef0<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>degree<br ALIGN="LEFT"/>dual_coef_ : csr_matrix<br ALIGN="LEFT"/>epsilon<br ALIGN="LEFT"/>fit_status_<br ALIGN="LEFT"/>gamma<br ALIGN="LEFT"/>intercept_<br ALIGN="LEFT"/>kernel<br ALIGN="LEFT"/>max_iter<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>n_support_<br ALIGN="LEFT"/>nu<br ALIGN="LEFT"/>probability<br ALIGN="LEFT"/>random_state<br ALIGN="LEFT"/>shape_fit_ : tuple<br ALIGN="LEFT"/>shrinking<br ALIGN="LEFT"/>support_<br ALIGN="LEFT"/>support_vectors_<br ALIGN="LEFT"/>tol<br ALIGN="LEFT"/>verbose<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn._loss.link.BaseLink" [color="black", fontcolor="black", label=<{BaseLink|interval_y_pred<br ALIGN="LEFT"/>is_multiclass : bool<br ALIGN="LEFT"/>|<I>inverse</I>(raw_prediction, out)<br ALIGN="LEFT"/><I>link</I>(y_pred, out)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn._loss.loss.BaseLoss" [color="black", fontcolor="black", label=<{BaseLoss|approx_hessian : bool<br ALIGN="LEFT"/>closs<br ALIGN="LEFT"/>constant_hessian : bool<br ALIGN="LEFT"/>differentiable : bool<br ALIGN="LEFT"/>interval_y_pred<br ALIGN="LEFT"/>interval_y_true<br ALIGN="LEFT"/>is_multiclass : bool<br ALIGN="LEFT"/>link<br ALIGN="LEFT"/>n_classes : NoneType<br ALIGN="LEFT"/>need_update_leaves_values : bool<br ALIGN="LEFT"/>|constant_to_optimal_zero(y_true, sample_weight)<br ALIGN="LEFT"/>fit_intercept_only(y_true, sample_weight)<br ALIGN="LEFT"/>gradient(y_true, raw_prediction, sample_weight, gradient_out, n_threads)<br ALIGN="LEFT"/>gradient_hessian(y_true, raw_prediction, sample_weight, gradient_out, hessian_out, n_threads)<br ALIGN="LEFT"/>in_y_pred_range(y)<br ALIGN="LEFT"/>in_y_true_range(y)<br ALIGN="LEFT"/>init_gradient_and_hessian(n_samples, dtype, order)<br ALIGN="LEFT"/>loss(y_true, raw_prediction, sample_weight, loss_out, n_threads)<br ALIGN="LEFT"/>loss_gradient(y_true, raw_prediction, sample_weight, loss_out, gradient_out, n_threads)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.mixture._base.BaseMixture" [color="black", fontcolor="black", label=<{BaseMixture|converged_ : bool<br ALIGN="LEFT"/>init_params<br ALIGN="LEFT"/>lower_bound_<br ALIGN="LEFT"/>max_iter<br ALIGN="LEFT"/>n_components<br ALIGN="LEFT"/>n_init<br ALIGN="LEFT"/>n_iter_ : int<br ALIGN="LEFT"/>random_state<br ALIGN="LEFT"/>reg_covar<br ALIGN="LEFT"/>tol<br ALIGN="LEFT"/>verbose<br ALIGN="LEFT"/>verbose_interval<br ALIGN="LEFT"/>warm_start<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_predict(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>sample(n_samples)<br ALIGN="LEFT"/>score(X, y)<br ALIGN="LEFT"/>score_samples(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.neural_network._multilayer_perceptron.BaseMultilayerPerceptron" [color="black", fontcolor="black", label=<{BaseMultilayerPerceptron|activation<br ALIGN="LEFT"/>alpha<br ALIGN="LEFT"/>batch_size<br ALIGN="LEFT"/>best_loss_ : NoneType<br ALIGN="LEFT"/>best_validation_score_ : NoneType<br ALIGN="LEFT"/>beta_1<br ALIGN="LEFT"/>beta_2<br ALIGN="LEFT"/>coefs_ : list<br ALIGN="LEFT"/>early_stopping<br ALIGN="LEFT"/>epsilon<br ALIGN="LEFT"/>hidden_layer_sizes<br ALIGN="LEFT"/>intercepts_ : list<br ALIGN="LEFT"/>learning_rate<br ALIGN="LEFT"/>learning_rate_init<br ALIGN="LEFT"/>loss<br ALIGN="LEFT"/>loss_<br ALIGN="LEFT"/>loss_curve_ : list<br ALIGN="LEFT"/>max_fun<br ALIGN="LEFT"/>max_iter<br ALIGN="LEFT"/>momentum<br ALIGN="LEFT"/>n_iter_ : int<br ALIGN="LEFT"/>n_iter_no_change<br ALIGN="LEFT"/>n_layers_<br ALIGN="LEFT"/>n_outputs_<br ALIGN="LEFT"/>nesterovs_momentum<br ALIGN="LEFT"/>out_activation_ : str<br ALIGN="LEFT"/>power_t<br ALIGN="LEFT"/>random_state<br ALIGN="LEFT"/>shuffle<br ALIGN="LEFT"/>solver<br ALIGN="LEFT"/>t_ : int<br ALIGN="LEFT"/>tol<br ALIGN="LEFT"/>validation_fraction<br ALIGN="LEFT"/>validation_scores_ : NoneType, list<br ALIGN="LEFT"/>verbose<br ALIGN="LEFT"/>warm_start<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.neural_network._stochastic_optimizers.BaseOptimizer" [color="black", fontcolor="black", label=<{BaseOptimizer|learning_rate : float<br ALIGN="LEFT"/>learning_rate_init : float<br ALIGN="LEFT"/>|<I>iteration_ends</I>(time_step)<br ALIGN="LEFT"/>trigger_stopping(msg, verbose)<br ALIGN="LEFT"/>update_params(params, grads)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.random_projection.BaseRandomProjection" [color="black", fontcolor="black", label=<{BaseRandomProjection|components_<br ALIGN="LEFT"/>compute_inverse_components : bool<br ALIGN="LEFT"/>eps : float<br ALIGN="LEFT"/>inverse_components_ : tuple<br ALIGN="LEFT"/>n_components : str<br ALIGN="LEFT"/>n_components_ : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._stochastic_gradient.BaseSGD" [color="black", fontcolor="black", label=<{BaseSGD|C : float<br ALIGN="LEFT"/>alpha : float<br ALIGN="LEFT"/>average : bool<br ALIGN="LEFT"/>coef_ : ndarray<br ALIGN="LEFT"/>early_stopping : bool<br ALIGN="LEFT"/>epsilon : float<br ALIGN="LEFT"/>eta0 : float<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_ : ndarray<br ALIGN="LEFT"/>l1_ratio : float<br ALIGN="LEFT"/>learning_rate : str<br ALIGN="LEFT"/>loss<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_iter_no_change : int<br ALIGN="LEFT"/>offset_ : ndarray<br ALIGN="LEFT"/>penalty : str<br ALIGN="LEFT"/>power_t : float<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>shuffle : bool<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>validation_fraction : float<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>warm_start : bool<br ALIGN="LEFT"/>|<I>fit</I>(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._stochastic_gradient.BaseSGDClassifier" [color="black", fontcolor="black", label=<{BaseSGDClassifier|class_weight : NoneType<br ALIGN="LEFT"/>coef_ : NoneType, ndarray<br ALIGN="LEFT"/>intercept_ : NoneType, ndarray, tuple<br ALIGN="LEFT"/>loss_functions : dict<br ALIGN="LEFT"/>n_iter_ : float<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>t_ : float<br ALIGN="LEFT"/>|fit(X, y, coef_init, intercept_init, sample_weight)<br ALIGN="LEFT"/>partial_fit(X, y, classes, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._stochastic_gradient.BaseSGDRegressor" [color="black", fontcolor="black", label=<{BaseSGDRegressor|coef_ : NoneType, ndarray<br ALIGN="LEFT"/>intercept_ : NoneType, tuple<br ALIGN="LEFT"/>loss_functions : dict<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>t_ : float<br ALIGN="LEFT"/>|fit(X, y, coef_init, intercept_init, sample_weight)<br ALIGN="LEFT"/>partial_fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.svm._base.BaseSVC" [color="black", fontcolor="black", label=<{BaseSVC|break_ties<br ALIGN="LEFT"/>class_weight_ : ndarray<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>decision_function_shape<br ALIGN="LEFT"/>probA_<br ALIGN="LEFT"/>probB_<br ALIGN="LEFT"/>unused_param : str<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._search.BaseSearchCV" [color="black", fontcolor="black", label=<{BaseSearchCV|best_estimator_<br ALIGN="LEFT"/>best_index_<br ALIGN="LEFT"/>best_params_<br ALIGN="LEFT"/>best_score_<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>cv : NoneType<br ALIGN="LEFT"/>cv_results_ : dict<br ALIGN="LEFT"/>error_score<br ALIGN="LEFT"/>estimator<br ALIGN="LEFT"/>feature_names_in_<br ALIGN="LEFT"/>multimetric_<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>n_splits_ : int<br ALIGN="LEFT"/>pre_dispatch : str<br ALIGN="LEFT"/>refit : bool<br ALIGN="LEFT"/>refit_time_<br ALIGN="LEFT"/>return_train_score : bool<br ALIGN="LEFT"/>scorer_ : NoneType<br ALIGN="LEFT"/>scoring : NoneType<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>inverse_transform(X, Xt)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>score(X, y)<br ALIGN="LEFT"/>score_samples(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._split.BaseShuffleSplit" [color="black", fontcolor="black", label=<{BaseShuffleSplit|n_splits : int<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>test_size : NoneType<br ALIGN="LEFT"/>train_size : NoneType<br ALIGN="LEFT"/>|get_n_splits(X, y, groups)<br ALIGN="LEFT"/>split(X, y, groups)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.cluster._bicluster.BaseSpectral" [color="black", fontcolor="black", label=<{BaseSpectral|init : str<br ALIGN="LEFT"/>mini_batch : bool<br ALIGN="LEFT"/>n_clusters : int<br ALIGN="LEFT"/>n_init : int<br ALIGN="LEFT"/>n_svd_vecs : NoneType<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>svd_method : str<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._search_successive_halving.BaseSuccessiveHalving" [color="black", fontcolor="black", label=<{BaseSuccessiveHalving|aggressive_elimination : bool<br ALIGN="LEFT"/>best_score_<br ALIGN="LEFT"/>factor : int<br ALIGN="LEFT"/>max_resources : str<br ALIGN="LEFT"/>max_resources_ : str<br ALIGN="LEFT"/>min_resources : str<br ALIGN="LEFT"/>min_resources_ : int, str<br ALIGN="LEFT"/>n_candidates_ : list<br ALIGN="LEFT"/>n_iterations_<br ALIGN="LEFT"/>n_possible_iterations_<br ALIGN="LEFT"/>n_remaining_candidates_<br ALIGN="LEFT"/>n_required_iterations_<br ALIGN="LEFT"/>n_resources_ : list<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>resource : str<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._classification_threshold.BaseThresholdClassifier" [color="black", fontcolor="black", label=<{BaseThresholdClassifier|classes_<br ALIGN="LEFT"/>estimator<br ALIGN="LEFT"/>feature_names_in_<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>response_method : str<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble._weight_boosting.BaseWeightBoosting" [color="black", fontcolor="black", label=<{BaseWeightBoosting|estimator_errors_ : ndarray<br ALIGN="LEFT"/>estimator_weights_ : ndarray<br ALIGN="LEFT"/>estimators_ : list<br ALIGN="LEFT"/>feature_importances_<br ALIGN="LEFT"/>learning_rate : float<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>staged_score(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.mixture._bayesian_mixture.BayesianGaussianMixture" [color="black", fontcolor="black", label=<{BayesianGaussianMixture|covariance_prior : NoneType, ndarray<br ALIGN="LEFT"/>covariance_prior_ : ndarray, tuple<br ALIGN="LEFT"/>covariance_type : str<br ALIGN="LEFT"/>covariances_ : ndarray<br ALIGN="LEFT"/>degrees_of_freedom_<br ALIGN="LEFT"/>degrees_of_freedom_prior : NoneType<br ALIGN="LEFT"/>degrees_of_freedom_prior_<br ALIGN="LEFT"/>mean_precision_<br ALIGN="LEFT"/>mean_precision_prior : NoneType<br ALIGN="LEFT"/>mean_precision_prior_ : float<br ALIGN="LEFT"/>mean_prior : NoneType<br ALIGN="LEFT"/>mean_prior_<br ALIGN="LEFT"/>means_<br ALIGN="LEFT"/>precisions_ : ndarray<br ALIGN="LEFT"/>precisions_cholesky_ : ndarray<br ALIGN="LEFT"/>weight_concentration_ : tuple<br ALIGN="LEFT"/>weight_concentration_prior : NoneType<br ALIGN="LEFT"/>weight_concentration_prior_<br ALIGN="LEFT"/>weight_concentration_prior_type : str<br ALIGN="LEFT"/>weights_<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._bayes.BayesianRidge" [color="black", fontcolor="black", label=<{BayesianRidge|X_offset_ : ndarray<br ALIGN="LEFT"/>X_scale_<br ALIGN="LEFT"/>alpha_<br ALIGN="LEFT"/>alpha_1 : float<br ALIGN="LEFT"/>alpha_2 : float<br ALIGN="LEFT"/>alpha_init : NoneType<br ALIGN="LEFT"/>coef_ : ndarray<br ALIGN="LEFT"/>compute_score : bool<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>lambda_<br ALIGN="LEFT"/>lambda_1 : float<br ALIGN="LEFT"/>lambda_2 : float<br ALIGN="LEFT"/>lambda_init : NoneType<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>scores_ : list, ndarray<br ALIGN="LEFT"/>sigma_<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict(X, return_std)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.naive_bayes.BernoulliNB" [color="black", fontcolor="black", label=<{BernoulliNB|binarize : float<br ALIGN="LEFT"/>class_count_<br ALIGN="LEFT"/>feature_count_<br ALIGN="LEFT"/>feature_log_prob_<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.neural_network._rbm.BernoulliRBM" [color="black", fontcolor="black", label=<{BernoulliRBM|batch_size : int<br ALIGN="LEFT"/>components_<br ALIGN="LEFT"/>h_samples_ : ndarray<br ALIGN="LEFT"/>intercept_hidden_ : ndarray<br ALIGN="LEFT"/>intercept_visible_ : ndarray<br ALIGN="LEFT"/>learning_rate : float<br ALIGN="LEFT"/>n_components : int<br ALIGN="LEFT"/>n_iter : int<br ALIGN="LEFT"/>random_state : NoneType, int<br ALIGN="LEFT"/>random_state_ : NoneType, int<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>gibbs(v)<br ALIGN="LEFT"/>partial_fit(X, y)<br ALIGN="LEFT"/>score_samples(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.base.BiclusterMixin" [color="black", fontcolor="black", label=<{BiclusterMixin|biclusters_<br ALIGN="LEFT"/>|get_indices(i)<br ALIGN="LEFT"/>get_shape(i)<br ALIGN="LEFT"/>get_submatrix(i, data)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.preprocessing._data.Binarizer" [color="black", fontcolor="black", label=<{Binarizer|copy : bool<br ALIGN="LEFT"/>threshold : float<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X, copy)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._glm.tests.test_glm.BinomialRegressor" [color="black", fontcolor="black", label=<{BinomialRegressor|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.cluster._birch.Birch" [color="black", fontcolor="black", label=<{Birch|branching_factor : int<br ALIGN="LEFT"/>compute_labels : bool<br ALIGN="LEFT"/>copy : str<br ALIGN="LEFT"/>dummy_leaf_<br ALIGN="LEFT"/>labels_<br ALIGN="LEFT"/>n_clusters : int<br ALIGN="LEFT"/>root_<br ALIGN="LEFT"/>subcluster_centers_ : ndarray<br ALIGN="LEFT"/>subcluster_labels_<br ALIGN="LEFT"/>threshold : float<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>partial_fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.cluster._bisect_k_means.BisectingKMeans" [color="black", fontcolor="black", label=<{BisectingKMeans|algorithm : str<br ALIGN="LEFT"/>bisecting_strategy : str<br ALIGN="LEFT"/>cluster_centers_ : ndarray<br ALIGN="LEFT"/>copy_x : bool<br ALIGN="LEFT"/>inertia_<br ALIGN="LEFT"/>labels_ : ndarray<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_set_output.test_set_output_mixin_custom_mixin.BothMixinEstimator" [color="black", fontcolor="black", label=<{BothMixinEstimator|<br ALIGN="LEFT"/>|get_feature_names_out(input_features)<br ALIGN="LEFT"/>transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.BrokenArrayAPI" [color="black", fontcolor="black", label=<{BrokenArrayAPI|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_search.BrokenClassifier" [color="black", fontcolor="black", label=<{BrokenClassifier|has_been_fit_ : bool<br ALIGN="LEFT"/>parameter : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_search.test_random_search_bad_cv.BrokenKFold" [color="black", fontcolor="black", label=<{BrokenKFold|<br ALIGN="LEFT"/>|get_n_splits()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.Buggy" [color="black", fontcolor="black", label=<{Buggy|a : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils._bunch.Bunch" [color="black", fontcolor="black", label=<{Bunch|data<br ALIGN="LEFT"/>estimator<br ALIGN="LEFT"/>final_estimator_<br ALIGN="LEFT"/>fit : dict<br ALIGN="LEFT"/>predict : dict<br ALIGN="LEFT"/>scorer<br ALIGN="LEFT"/>splitter<br ALIGN="LEFT"/>target<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_set_output.test_set_output_mro.C" [color="black", fontcolor="black", label=<{C|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.cross_decomposition._pls.CCA" [color="black", fontcolor="black", label=<{CCA|param : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.externals._arff.COOData" [color="black", fontcolor="black", label=<{COOData|<br ALIGN="LEFT"/>|decode_rows(stream, conversors)<br ALIGN="LEFT"/>encode_data(data, attributes)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model.tests.test_coordinate_descent.test_multitask_cv_estimators_with_sample_weight.CVSplitter" [color="black", fontcolor="black", label=<{CVSplitter|<br ALIGN="LEFT"/>|<I>get_n_splits</I>(X, y, groups, metadata)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model.tests.test_coordinate_descent.test_multitask_cv_estimators_with_sample_weight.CVSplitterSampleWeight" [color="black", fontcolor="black", label=<{CVSplitterSampleWeight|<br ALIGN="LEFT"/>|split(X, y, groups, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.calibration.CalibratedClassifierCV" [color="black", fontcolor="black", label=<{CalibratedClassifierCV|calibrated_classifiers_ : list<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>cv : NoneType<br ALIGN="LEFT"/>ensemble : str<br ALIGN="LEFT"/>estimator : NoneType<br ALIGN="LEFT"/>feature_names_in_<br ALIGN="LEFT"/>method : str<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.calibration.CalibrationDisplay" [color="black", fontcolor="black", label=<{CalibrationDisplay|ax_ : NoneType<br ALIGN="LEFT"/>estimator_name : NoneType<br ALIGN="LEFT"/>figure_<br ALIGN="LEFT"/>line_<br ALIGN="LEFT"/>pos_label : NoneType<br ALIGN="LEFT"/>prob_pred<br ALIGN="LEFT"/>prob_true<br ALIGN="LEFT"/>y_prob<br ALIGN="LEFT"/>|from_estimator(estimator, X, y)<br ALIGN="LEFT"/>from_predictions(y_true, y_prob)<br ALIGN="LEFT"/>plot()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_common.CallableEstimator" [color="black", fontcolor="black", label=<{CallableEstimator|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.naive_bayes.CategoricalNB" [color="black", fontcolor="black", label=<{CategoricalNB|category_count_<br ALIGN="LEFT"/>class_count_ : ndarray<br ALIGN="LEFT"/>feature_log_prob_ : list<br ALIGN="LEFT"/>min_categories : NoneType<br ALIGN="LEFT"/>n_categories_<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>partial_fit(X, y, classes, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.ChangesDict" [color="black", fontcolor="black", label=<{ChangesDict|key : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.ChangesUnderscoreAttribute" [color="black", fontcolor="black", label=<{ChangesUnderscoreAttribute|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.ChangesWrongAttribute" [color="black", fontcolor="black", label=<{ChangesWrongAttribute|wrong_attribute : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._mocking.CheckingClassifier" [color="black", fontcolor="black", label=<{CheckingClassifier|check_X : NoneType<br ALIGN="LEFT"/>check_X_params : NoneType<br ALIGN="LEFT"/>check_y : NoneType<br ALIGN="LEFT"/>check_y_params : NoneType<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>expected_fit_params : NoneType<br ALIGN="LEFT"/>expected_sample_weight : NoneType<br ALIGN="LEFT"/>foo_param : int<br ALIGN="LEFT"/>methods_to_check : str<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>score(X, Y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.test_get_tags_backward_compatibility.ChildClass" [color="black", fontcolor="black", label=<{ChildClass|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.test_safe_tags_backward_compatibility.ChildClass" [color="black", fontcolor="black", label=<{ChildClass|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.test__get_tags_backward_compatibility.ChildClass" [color="black", fontcolor="black", label=<{ChildClass|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.base.ClassNamePrefixFeaturesOutMixin" [color="black", fontcolor="black", label=<{ClassNamePrefixFeaturesOutMixin|<br ALIGN="LEFT"/>|get_feature_names_out(input_features)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_metadata_routing.test_default_request_override.Class_1" [color="black", fontcolor="black", label=<{Class_1|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.multioutput.ClassifierChain" [color="black", fontcolor="black", label=<{ClassifierChain|chain_method : str<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, Y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble.tests.test_voting.test_sample_weight.ClassifierErrorFit" [color="black", fontcolor="black", label=<{ClassifierErrorFit|<br ALIGN="LEFT"/>|fit(X_scaled, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.ClassifierEstimator" [color="black", fontcolor="black", label=<{ClassifierEstimator|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.base.ClassifierMixin" [color="black", fontcolor="black", label=<{ClassifierMixin|<br ALIGN="LEFT"/>|score(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._tags.ClassifierTags" [color="black", fontcolor="black", label=<{ClassifierTags|multi_class : bool<br ALIGN="LEFT"/>multi_label : bool<br ALIGN="LEFT"/>poor_score : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_calibration.test_calibration_without_sample_weight_estimator.ClfWithoutSampleWeight" [color="black", fontcolor="black", label=<{ClfWithoutSampleWeight|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.base.ClusterMixin" [color="black", fontcolor="black", label=<{ClusterMixin|<br ALIGN="LEFT"/>|fit_predict(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.compose._column_transformer.ColumnTransformer" [color="black", fontcolor="black", label=<{ColumnTransformer|force_int_remainder_cols : bool<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>named_transformers_<br ALIGN="LEFT"/>output_indices_ : dict<br ALIGN="LEFT"/>remainder : str<br ALIGN="LEFT"/>sparse_output_ : bool<br ALIGN="LEFT"/>sparse_threshold : float<br ALIGN="LEFT"/>transformer_weights : NoneType<br ALIGN="LEFT"/>transformers<br ALIGN="LEFT"/>transformers_ : list<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>verbose_feature_names_out : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>get_params(deep)<br ALIGN="LEFT"/>set_output()<br ALIGN="LEFT"/>set_params()<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.naive_bayes.ComplementNB" [color="black", fontcolor="black", label=<{ComplementNB|class_count_<br ALIGN="LEFT"/>feature_all_ : ndarray<br ALIGN="LEFT"/>feature_count_<br ALIGN="LEFT"/>feature_log_prob_<br ALIGN="LEFT"/>norm : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.gaussian_process.kernels.CompoundKernel" [color="black", fontcolor="black", label=<{CompoundKernel|bounds<br ALIGN="LEFT"/>kernels<br ALIGN="LEFT"/>requires_vector_input<br ALIGN="LEFT"/>theta<br ALIGN="LEFT"/>|diag(X)<br ALIGN="LEFT"/>get_params(deep)<br ALIGN="LEFT"/>is_stationary()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.test_check_no_attributes_set_in_init.ConformantEstimatorClassAttribute" [color="black", fontcolor="black", label=<{ConformantEstimatorClassAttribute|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.metrics._plot.confusion_matrix.ConfusionMatrixDisplay" [color="black", fontcolor="black", label=<{ConfusionMatrixDisplay|ax_ : NoneType<br ALIGN="LEFT"/>confusion_matrix<br ALIGN="LEFT"/>display_labels : NoneType<br ALIGN="LEFT"/>figure_<br ALIGN="LEFT"/>im_<br ALIGN="LEFT"/>text_ : NoneType, ndarray<br ALIGN="LEFT"/>|from_estimator(estimator, X, y)<br ALIGN="LEFT"/>from_predictions(y_true, y_pred)<br ALIGN="LEFT"/>plot()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.gaussian_process.kernels.ConstantKernel" [color="black", fontcolor="black", label=<{ConstantKernel|constant_value : float<br ALIGN="LEFT"/>constant_value_bounds : tuple<br ALIGN="LEFT"/>hyperparameter_constant_value<br ALIGN="LEFT"/>|diag(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_metadata_routing.test_get_routing_for_object.Consumer" [color="black", fontcolor="black", label=<{Consumer|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.frozen.tests.test_frozen.test_frozen_metadata_routing.ConsumesMetadata" [color="black", fontcolor="black", label=<{ConsumesMetadata|fitted_ : bool<br ALIGN="LEFT"/>on_fit : NoneType<br ALIGN="LEFT"/>on_predict : NoneType<br ALIGN="LEFT"/>|fit(X, y, metadata)<br ALIGN="LEFT"/>predict(X, metadata)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.metadata_routing_common.ConsumingClassifier" [color="black", fontcolor="black", label=<{ConsumingClassifier|alpha : float<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>coef_ : ndarray<br ALIGN="LEFT"/>registry : NoneType<br ALIGN="LEFT"/>|decision_function(X, sample_weight, metadata)<br ALIGN="LEFT"/>fit(X, y, sample_weight, metadata)<br ALIGN="LEFT"/>partial_fit(X, y, classes, sample_weight, metadata)<br ALIGN="LEFT"/>predict(X, sample_weight, metadata)<br ALIGN="LEFT"/>predict_log_proba(X, sample_weight, metadata)<br ALIGN="LEFT"/>predict_proba(X, sample_weight, metadata)<br ALIGN="LEFT"/>score(X, y, sample_weight, metadata)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.metadata_routing_common.ConsumingNoFitTransformTransformer" [color="black", fontcolor="black", label=<{ConsumingNoFitTransformTransformer|registry : NoneType<br ALIGN="LEFT"/>|fit(X, y, sample_weight, metadata)<br ALIGN="LEFT"/>transform(X, sample_weight, metadata)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.metadata_routing_common.ConsumingRegressor" [color="black", fontcolor="black", label=<{ConsumingRegressor|registry : NoneType<br ALIGN="LEFT"/>|fit(X, y, sample_weight, metadata)<br ALIGN="LEFT"/>partial_fit(X, y, sample_weight, metadata)<br ALIGN="LEFT"/>predict(X, y, sample_weight, metadata)<br ALIGN="LEFT"/>score(X, y, sample_weight, metadata)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_metadata_routing.test_estimator_warnings.ConsumingRegressorWarn" [color="black", fontcolor="black", label=<{ConsumingRegressorWarn|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.metadata_routing_common.ConsumingScorer" [color="black", fontcolor="black", label=<{ConsumingScorer|registry : NoneType<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.metadata_routing_common.ConsumingSplitter" [color="black", fontcolor="black", label=<{ConsumingSplitter|registry : NoneType<br ALIGN="LEFT"/>|get_n_splits(X, y, groups, metadata)<br ALIGN="LEFT"/>split(X, y, groups, metadata)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.metadata_routing_common.ConsumingTransformer" [color="black", fontcolor="black", label=<{ConsumingTransformer|fitted_ : bool<br ALIGN="LEFT"/>registry : NoneType<br ALIGN="LEFT"/>|fit(X, y, sample_weight, metadata)<br ALIGN="LEFT"/>fit_transform(X, y, sample_weight, metadata)<br ALIGN="LEFT"/>inverse_transform(X, sample_weight, metadata)<br ALIGN="LEFT"/>transform(X, sample_weight, metadata)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._set_output.ContainerAdapterProtocol" [color="black", fontcolor="black", label=<{ContainerAdapterProtocol|container_lib : str<br ALIGN="LEFT"/>|<I>create_container</I>(X_output, X_original, columns, inplace)<br ALIGN="LEFT"/><I>hstack</I>(Xs)<br ALIGN="LEFT"/><I>is_supported_container</I>(X)<br ALIGN="LEFT"/><I>rename_columns</I>(X, columns)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._set_output.ContainerAdaptersManager" [color="black", fontcolor="black", label=<{ContainerAdaptersManager|adapters : dict<br ALIGN="LEFT"/>supported_outputs<br ALIGN="LEFT"/>|register(adapter)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.exceptions.ConvergenceWarning" [color="black", fontcolor="red", label=<{ConvergenceWarning|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.CorrectNotFittedError" [color="black", fontcolor="red", label=<{CorrectNotFittedError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.CorrectNotFittedErrorClassifier" [color="black", fontcolor="black", label=<{CorrectNotFittedErrorClassifier|coef_ : ndarray<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.feature_extraction.text.CountVectorizer" [color="black", fontcolor="black", label=<{CountVectorizer|analyzer : str<br ALIGN="LEFT"/>binary : bool<br ALIGN="LEFT"/>decode_error : str<br ALIGN="LEFT"/>dtype<br ALIGN="LEFT"/>encoding : str<br ALIGN="LEFT"/>input : str<br ALIGN="LEFT"/>lowercase : bool<br ALIGN="LEFT"/>max_df : float, int<br ALIGN="LEFT"/>max_features : NoneType<br ALIGN="LEFT"/>min_df : float, int<br ALIGN="LEFT"/>ngram_range : tuple<br ALIGN="LEFT"/>preprocessor : NoneType<br ALIGN="LEFT"/>set_params : str<br ALIGN="LEFT"/>stop_words : NoneType<br ALIGN="LEFT"/>strip_accents : NoneType<br ALIGN="LEFT"/>token_pattern : str<br ALIGN="LEFT"/>tokenizer : NoneType<br ALIGN="LEFT"/>vocabulary : NoneType<br ALIGN="LEFT"/>vocabulary_ : defaultdict<br ALIGN="LEFT"/>|fit(raw_documents, y)<br ALIGN="LEFT"/>fit_transform(raw_documents, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>transform(raw_documents)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_pprint.CountVectorizer" [color="black", fontcolor="black", label=<{CountVectorizer|analyzer : str<br ALIGN="LEFT"/>binary : bool<br ALIGN="LEFT"/>decode_error : str<br ALIGN="LEFT"/>dtype<br ALIGN="LEFT"/>encoding : str<br ALIGN="LEFT"/>input : str<br ALIGN="LEFT"/>lowercase : bool<br ALIGN="LEFT"/>max_df : float<br ALIGN="LEFT"/>max_features : NoneType<br ALIGN="LEFT"/>min_df : int<br ALIGN="LEFT"/>ngram_range : tuple<br ALIGN="LEFT"/>preprocessor : NoneType<br ALIGN="LEFT"/>stop_words : NoneType<br ALIGN="LEFT"/>strip_accents : NoneType<br ALIGN="LEFT"/>token_pattern : str<br ALIGN="LEFT"/>tokenizer : NoneType<br ALIGN="LEFT"/>vocabulary : NoneType<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.feature_extraction.tests.test_text.test_stop_word_validation_custom_preprocessor.CustomEstimator" [color="black", fontcolor="black", label=<{CustomEstimator|<br ALIGN="LEFT"/>|build_preprocessor()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.gaussian_process.tests.test_gpr.CustomKernel" [color="black", fontcolor="black", label=<{CustomKernel|<br ALIGN="LEFT"/>|diag(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.test_outlier_mixin_fit_predict_with_metadata_in_predict.CustomOutlierDetector" [color="black", fontcolor="black", label=<{CustomOutlierDetector|<br ALIGN="LEFT"/>|fit(X, y, prop)<br ALIGN="LEFT"/>predict(X, prop)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble.tests.test_bagging.test_sparse_classification.CustomSVC" [color="black", fontcolor="black", label=<{CustomSVC|data_type_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble.tests.test_weight_boosting.test_sparse_classification.CustomSVC" [color="black", fontcolor="black", label=<{CustomSVC|data_type_<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble.tests.test_bagging.test_sparse_regression.CustomSVR" [color="black", fontcolor="black", label=<{CustomSVR|data_type_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble.tests.test_weight_boosting.test_sparse_regression.CustomSVR" [color="black", fontcolor="black", label=<{CustomSVR|data_type_<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_search.test_custom_run_search.CustomSearchCV" [color="black", fontcolor="black", label=<{CustomSearchCV|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_base.test_transformer_fit_transform_with_metadata_in_transform.CustomTransformer" [color="black", fontcolor="black", label=<{CustomTransformer|<br ALIGN="LEFT"/>|fit(X, y, prop)<br ALIGN="LEFT"/>transform(X, prop)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.cluster._dbscan.DBSCAN" [color="black", fontcolor="black", label=<{DBSCAN|algorithm : str<br ALIGN="LEFT"/>components_ : ndarray<br ALIGN="LEFT"/>core_sample_indices_<br ALIGN="LEFT"/>eps : float<br ALIGN="LEFT"/>labels_ : ndarray<br ALIGN="LEFT"/>leaf_size : int<br ALIGN="LEFT"/>metric : str<br ALIGN="LEFT"/>metric_params : NoneType<br ALIGN="LEFT"/>min_samples : int<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>p : NoneType<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>fit_predict(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.externals._arff.Data" [color="black", fontcolor="black", label=<{Data|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.exceptions.DataConversionWarning" [color="black", fontcolor="red", label=<{DataConversionWarning|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_validation.DataDependentFailingClassifier" [color="black", fontcolor="black", label=<{DataDependentFailingClassifier|max_x_value : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>score(X, Y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.exceptions.DataDimensionalityWarning" [color="black", fontcolor="red", label=<{DataDimensionalityWarning|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.inspection._plot.decision_boundary.DecisionBoundaryDisplay" [color="black", fontcolor="black", label=<{DecisionBoundaryDisplay|ax_ : NoneType<br ALIGN="LEFT"/>figure_<br ALIGN="LEFT"/>response<br ALIGN="LEFT"/>surface_<br ALIGN="LEFT"/>xlabel : NoneType<br ALIGN="LEFT"/>xx0<br ALIGN="LEFT"/>xx1<br ALIGN="LEFT"/>ylabel : NoneType<br ALIGN="LEFT"/>|from_estimator(estimator, X)<br ALIGN="LEFT"/>plot(plot_method, ax, xlabel, ylabel)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tree._classes.DecisionTreeClassifier" [color="black", fontcolor="black", label=<{DecisionTreeClassifier|<br ALIGN="LEFT"/>|fit(X, y, sample_weight, check_input)<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X, check_input)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tree._classes.DecisionTreeRegressor" [color="black", fontcolor="black", label=<{DecisionTreeRegressor|<br ALIGN="LEFT"/>|fit(X, y, sample_weight, check_input)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_metaestimators.DelegatorData" [color="black", fontcolor="black", label=<{DelegatorData|construct<br ALIGN="LEFT"/>fit_args : tuple<br ALIGN="LEFT"/>name<br ALIGN="LEFT"/>skip_methods : tuple<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.externals._arff.DenseGeneratorData" [color="black", fontcolor="black", label=<{DenseGeneratorData|<br ALIGN="LEFT"/>|decode_rows(stream, conversors)<br ALIGN="LEFT"/>encode_data(data, attributes)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.base.DensityMixin" [color="black", fontcolor="black", label=<{DensityMixin|<br ALIGN="LEFT"/>|<I>score</I>(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.metrics._plot.det_curve.DetCurveDisplay" [color="black", fontcolor="black", label=<{DetCurveDisplay|ax_ : NoneType<br ALIGN="LEFT"/>estimator_name : NoneType<br ALIGN="LEFT"/>figure_<br ALIGN="LEFT"/>fnr<br ALIGN="LEFT"/>fpr<br ALIGN="LEFT"/>line_<br ALIGN="LEFT"/>pos_label : NoneType<br ALIGN="LEFT"/>|from_estimator(estimator, X, y)<br ALIGN="LEFT"/>from_predictions(y_true, y_pred)<br ALIGN="LEFT"/>plot(ax)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_array_api.test_device_inspection.Device" [color="black", fontcolor="black", label=<{Device|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_base.DiamondOverwriteTag" [color="black", fontcolor="black", label=<{DiamondOverwriteTag|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.feature_extraction._dict_vectorizer.DictVectorizer" [color="black", fontcolor="black", label=<{DictVectorizer|dtype<br ALIGN="LEFT"/>feature_names_ : list<br ALIGN="LEFT"/>separator : str<br ALIGN="LEFT"/>sort : bool<br ALIGN="LEFT"/>sparse : bool<br ALIGN="LEFT"/>vocabulary_ : dict<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>inverse_transform(X, dict_type)<br ALIGN="LEFT"/>restrict(support, indices)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.decomposition._dict_learning.DictionaryLearning" [color="black", fontcolor="black", label=<{DictionaryLearning|alpha : int<br ALIGN="LEFT"/>callback : NoneType<br ALIGN="LEFT"/>code_init : NoneType<br ALIGN="LEFT"/>components_ : matrix, ndarray<br ALIGN="LEFT"/>dict_init : NoneType<br ALIGN="LEFT"/>error_ : list<br ALIGN="LEFT"/>fit_algorithm : str<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_components : NoneType<br ALIGN="LEFT"/>n_iter_ : int<br ALIGN="LEFT"/>positive_dict : bool<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>split_sign : bool<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.discriminant_analysis.DiscriminantAnalysisPredictionMixin" [color="black", fontcolor="black", label=<{DiscriminantAnalysisPredictionMixin|<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.DontPickleAttributeMixin" [color="black", fontcolor="black", label=<{DontPickleAttributeMixin|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.gaussian_process.kernels.DotProduct" [color="black", fontcolor="black", label=<{DotProduct|hyperparameter_sigma_0<br ALIGN="LEFT"/>sigma_0 : float<br ALIGN="LEFT"/>sigma_0_bounds : tuple<br ALIGN="LEFT"/>|diag(X)<br ALIGN="LEFT"/>is_stationary()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.compose.tests.test_column_transformer.DoubleTrans" [color="black", fontcolor="black", label=<{DoubleTrans|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tree._reingold_tilford.DrawTree" [color="black", fontcolor="black", label=<{DrawTree|ancestor<br ALIGN="LEFT"/>change : int<br ALIGN="LEFT"/>children<br ALIGN="LEFT"/>lmost_sibling<br ALIGN="LEFT"/>mod : int<br ALIGN="LEFT"/>number : int<br ALIGN="LEFT"/>parent : NoneType<br ALIGN="LEFT"/>shift : int<br ALIGN="LEFT"/>thread : NoneType<br ALIGN="LEFT"/>tree<br ALIGN="LEFT"/>x : float<br ALIGN="LEFT"/>y : int<br ALIGN="LEFT"/>|get_lmost_sibling()<br ALIGN="LEFT"/>lbrother()<br ALIGN="LEFT"/>left()<br ALIGN="LEFT"/>max_extents()<br ALIGN="LEFT"/>right()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.compose.tests.test_target.DummyCheckerArrayTransformer" [color="black", fontcolor="black", label=<{DummyCheckerArrayTransformer|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.compose.tests.test_target.DummyCheckerListRegressor" [color="black", fontcolor="black", label=<{DummyCheckerListRegressor|<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_calibration.test_float32_predict_proba.DummyClassifer32" [color="black", fontcolor="black", label=<{DummyClassifer32|<br ALIGN="LEFT"/>|predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.dummy.DummyClassifier" [color="black", fontcolor="black", label=<{DummyClassifier|class_prior_ : list<br ALIGN="LEFT"/>classes_ : list<br ALIGN="LEFT"/>constant : NoneType<br ALIGN="LEFT"/>n_classes_ : list<br ALIGN="LEFT"/>n_outputs_<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>sparse_output_<br ALIGN="LEFT"/>strategy : str<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>score(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_multioutput.DummyClassifierWithFitParams" [color="black", fontcolor="black", label=<{DummyClassifierWithFitParams|<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble.tests.test_weight_boosting.test_sample_weight_adaboost_regressor.DummyEstimator" [color="black", fontcolor="black", label=<{DummyEstimator|<br ALIGN="LEFT"/>|<I>fit</I>(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.test_clone_pandas_dataframe.DummyEstimator" [color="black", fontcolor="black", label=<{DummyEstimator|df : NoneType<br ALIGN="LEFT"/>scalar_param : int<br ALIGN="LEFT"/>|<I>fit</I>(X, y)<br ALIGN="LEFT"/><I>transform</I>(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_pprint.test_complexity_print_changed_only.DummyEstimator" [color="black", fontcolor="black", label=<{DummyEstimator|estimator : NoneType<br ALIGN="LEFT"/>nb_times_repr_called : int<br ALIGN="LEFT"/>|transform(X, copy)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_pipeline.DummyEstimatorParams" [color="black", fontcolor="black", label=<{DummyEstimatorParams|got_attribute : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X, got_attribute)<br ALIGN="LEFT"/>predict_log_proba(X, got_attribute)<br ALIGN="LEFT"/>predict_proba(X, got_attribute)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_validation.DummyMemory" [color="black", fontcolor="black", label=<{DummyMemory|<br ALIGN="LEFT"/>|cache(func)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.dummy.DummyRegressor" [color="black", fontcolor="black", label=<{DummyRegressor|constant : NoneType<br ALIGN="LEFT"/>constant_ : NoneType, ndarray, tuple<br ALIGN="LEFT"/>n_outputs_<br ALIGN="LEFT"/>quantile : NoneType<br ALIGN="LEFT"/>strategy : str<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict(X, return_std)<br ALIGN="LEFT"/>score(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.compose.tests.test_target.DummyRegressorWithExtraFitParams" [color="black", fontcolor="black", label=<{DummyRegressorWithExtraFitParams|<br ALIGN="LEFT"/>|fit(X, y, sample_weight, check_input)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.compose.tests.test_target.DummyRegressorWithExtraPredictParams" [color="black", fontcolor="black", label=<{DummyRegressorWithExtraPredictParams|predict_called : bool<br ALIGN="LEFT"/>|predict(X, check_input)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_multioutput.DummyRegressorWithFitParams" [color="black", fontcolor="black", label=<{DummyRegressorWithFitParams|<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.metrics.tests.test_score_objects.DummyScorer" [color="black", fontcolor="black", label=<{DummyScorer|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.ensemble.tests.test_bagging.DummySizeEstimator" [color="black", fontcolor="black", label=<{DummySizeEstimator|training_hash_<br ALIGN="LEFT"/>training_size_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_pipeline.DummyTransf" [color="black", fontcolor="black", label=<{DummyTransf|means_<br ALIGN="LEFT"/>timestamp_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.compose.tests.test_target.DummyTransformer" [color="black", fontcolor="black", label=<{DummyTransformer|fit_counter : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_pipeline.test_feature_union_fit_params.DummyTransformer" [color="black", fontcolor="black", label=<{DummyTransformer|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_pipeline.test_feature_union_fit_params_without_fit_transform.DummyTransformer" [color="black", fontcolor="black", label=<{DummyTransformer|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble.tests.test_bagging.DummyZeroEstimator" [color="black", fontcolor="black", label=<{DummyZeroEstimator|classes_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.exceptions.EfficiencyWarning" [color="black", fontcolor="red", label=<{EfficiencyWarning|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._coordinate_descent.ElasticNet" [color="black", fontcolor="black", label=<{ElasticNet|alpha : float<br ALIGN="LEFT"/>coef_ : list, ndarray<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>dual_gap_ : ndarray<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>l1_ratio : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_iter_ : list<br ALIGN="LEFT"/>path : staticmethod<br ALIGN="LEFT"/>positive : bool<br ALIGN="LEFT"/>precompute : bool<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>selection : str<br ALIGN="LEFT"/>sparse_coef_<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>warm_start : bool<br ALIGN="LEFT"/>|fit(X, y, sample_weight, check_input)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._coordinate_descent.ElasticNetCV" [color="black", fontcolor="black", label=<{ElasticNetCV|alphas : NoneType<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>cv : NoneType<br ALIGN="LEFT"/>eps : float<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>l1_ratio : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_alphas : int<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>path : staticmethod<br ALIGN="LEFT"/>positive : bool<br ALIGN="LEFT"/>precompute : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>selection : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.covariance._elliptic_envelope.EllipticEnvelope" [color="black", fontcolor="black", label=<{EllipticEnvelope|contamination : float<br ALIGN="LEFT"/>offset_ : ndarray<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>score(X, y, sample_weight)<br ALIGN="LEFT"/>score_samples(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.covariance._empirical_covariance.EmpiricalCovariance" [color="black", fontcolor="black", label=<{EmpiricalCovariance|assume_centered : bool<br ALIGN="LEFT"/>covariance_ : ndarray<br ALIGN="LEFT"/>location_ : ndarray<br ALIGN="LEFT"/>precision_ : NoneType, tuple<br ALIGN="LEFT"/>store_precision : bool<br ALIGN="LEFT"/>|error_norm(comp_cov, norm, scaling, squared)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>get_precision()<br ALIGN="LEFT"/>mahalanobis(X)<br ALIGN="LEFT"/>score(X_test, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.EmptyEstimator" [color="black", fontcolor="black", label=<{EmptyEstimator|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.EmptyRegressor" [color="black", fontcolor="black", label=<{EmptyRegressor|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils._metadata_requests.process_routing.EmptyRequest" [color="black", fontcolor="black", label=<{EmptyRequest|<br ALIGN="LEFT"/>|get(name, default)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.EmptyTransformer" [color="black", fontcolor="black", label=<{EmptyTransformer|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.externals._arff.EncodedNominalConversor" [color="black", fontcolor="black", label=<{EncodedNominalConversor|values<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_metadata_routing.test_no_metadata_always_works.Estimator" [color="black", fontcolor="black", label=<{Estimator|<br ALIGN="LEFT"/>|fit(X, y, metadata)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.test_estimator_getstate_using_slots_error_message.Estimator" [color="black", fontcolor="black", label=<{Estimator|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_pipeline.test_pipeline_check_if_fitted.Estimator" [color="black", fontcolor="black", label=<{Estimator|fitted_ : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_pipeline.test_transform_input_explicit_value_check.Estimator" [color="black", fontcolor="black", label=<{Estimator|<br ALIGN="LEFT"/>|fit(X, y, X_val, y_val)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_pipeline.test_transform_tuple_input.Estimator" [color="black", fontcolor="black", label=<{Estimator|fitted_ : bool<br ALIGN="LEFT"/>|fit(X, y, X_val, y_val)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_validation.test_check_is_fitted_with_is_fitted.Estimator" [color="black", fontcolor="black", label=<{Estimator|<br ALIGN="LEFT"/>|fit()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.test_check_fit_check_is_fitted.Estimator" [color="black", fontcolor="black", label=<{Estimator|behavior : str<br ALIGN="LEFT"/>is_fitted_ : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.test_check_requires_y_none.Estimator" [color="black", fontcolor="black", label=<{Estimator|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.frozen.tests.test_frozen.test_composite_fit.Estimator" [color="black", fontcolor="black", label=<{Estimator|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_predict(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.frozen.tests.test_frozen.test_frozen_tags.Estimator" [color="black", fontcolor="black", label=<{Estimator|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.exceptions.EstimatorCheckFailedWarning" [color="black", fontcolor="red", label=<{EstimatorCheckFailedWarning|check_name<br ALIGN="LEFT"/>estimator<br ALIGN="LEFT"/>exception<br ALIGN="LEFT"/>expected_to_fail<br ALIGN="LEFT"/>expected_to_fail_reason<br ALIGN="LEFT"/>status<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.EstimatorInconsistentForPandas" [color="black", fontcolor="black", label=<{EstimatorInconsistentForPandas|value_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_set_output.EstimatorNoSetOutputWithTransform" [color="black", fontcolor="black", label=<{EstimatorNoSetOutputWithTransform|<br ALIGN="LEFT"/>|transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_set_output.EstimatorNoSetOutputWithTransformNoFeatureNamesOut" [color="black", fontcolor="black", label=<{EstimatorNoSetOutputWithTransformNoFeatureNamesOut|<br ALIGN="LEFT"/>|transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_search.test_search_cv__pairwise_property_delegated_to_base_estimator.EstimatorPairwise" [color="black", fontcolor="black", label=<{EstimatorPairwise|pairwise : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_set_output.EstimatorReturnTuple" [color="black", fontcolor="black", label=<{EstimatorReturnTuple|OutputTuple<br ALIGN="LEFT"/>|transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.metrics.tests.test_score_objects.EstimatorWithFit" [color="black", fontcolor="black", label=<{EstimatorWithFit|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.metrics.tests.test_score_objects.EstimatorWithFitAndPredict" [color="black", fontcolor="black", label=<{EstimatorWithFitAndPredict|y<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.metrics.tests.test_score_objects.EstimatorWithFitAndScore" [color="black", fontcolor="black", label=<{EstimatorWithFitAndScore|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>score(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_set_output.EstimatorWithListInput" [color="black", fontcolor="black", label=<{EstimatorWithListInput|n_features_in_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_set_output.EstimatorWithSetOutput" [color="black", fontcolor="black", label=<{EstimatorWithSetOutput|n_features_in_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_set_output.EstimatorWithSetOutputIndex" [color="black", fontcolor="black", label=<{EstimatorWithSetOutputIndex|n_features_in_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_set_output.EstimatorWithSetOutputNoAutoWrap" [color="black", fontcolor="black", label=<{EstimatorWithSetOutputNoAutoWrap|<br ALIGN="LEFT"/>|transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.test_check_estimator_sparse_tag.EstimatorWithSparseConfig" [color="black", fontcolor="black", label=<{EstimatorWithSparseConfig|accept_sparse<br ALIGN="LEFT"/>fit_error : NoneType<br ALIGN="LEFT"/>tag_sparse<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_set_output.EstimatorWithoutSetOutputAndWithoutTransform" [color="black", fontcolor="black", label=<{EstimatorWithoutSetOutputAndWithoutTransform|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.gaussian_process.kernels.ExpSineSquared" [color="black", fontcolor="black", label=<{ExpSineSquared|hyperparameter_length_scale<br ALIGN="LEFT"/>hyperparameter_periodicity<br ALIGN="LEFT"/>length_scale : float<br ALIGN="LEFT"/>length_scale_bounds : tuple<br ALIGN="LEFT"/>periodicity : float<br ALIGN="LEFT"/>periodicity_bounds : tuple<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_metadata_routing.test_setting_default_requests.ExplicitRequest" [color="black", fontcolor="black", label=<{ExplicitRequest|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_metadata_routing.test_setting_default_requests.ExplicitRequestOverwrite" [color="black", fontcolor="black", label=<{ExplicitRequestOverwrite|<br ALIGN="LEFT"/>|fit(X, y, prop)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn._loss.loss.ExponentialLoss" [color="black", fontcolor="black", label=<{ExponentialLoss|interval_y_true<br ALIGN="LEFT"/>|constant_to_optimal_zero(y_true, sample_weight)<br ALIGN="LEFT"/>predict_proba(raw_prediction)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.gaussian_process.kernels.Exponentiation" [color="black", fontcolor="black", label=<{Exponentiation|bounds<br ALIGN="LEFT"/>exponent<br ALIGN="LEFT"/>hyperparameters<br ALIGN="LEFT"/>kernel<br ALIGN="LEFT"/>requires_vector_input<br ALIGN="LEFT"/>theta<br ALIGN="LEFT"/>|diag(X)<br ALIGN="LEFT"/>get_params(deep)<br ALIGN="LEFT"/>is_stationary()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tree._classes.ExtraTreeClassifier" [color="black", fontcolor="black", label=<{ExtraTreeClassifier|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tree._classes.ExtraTreeRegressor" [color="black", fontcolor="black", label=<{ExtraTreeRegressor|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.ensemble._forest.ExtraTreesClassifier" [color="black", fontcolor="black", label=<{ExtraTreesClassifier|ccp_alpha : float<br ALIGN="LEFT"/>criterion : str<br ALIGN="LEFT"/>max_depth : NoneType<br ALIGN="LEFT"/>max_features : str<br ALIGN="LEFT"/>max_leaf_nodes : NoneType<br ALIGN="LEFT"/>min_impurity_decrease : float<br ALIGN="LEFT"/>min_samples_leaf : int<br ALIGN="LEFT"/>min_samples_split : int<br ALIGN="LEFT"/>min_weight_fraction_leaf : float<br ALIGN="LEFT"/>monotonic_cst : NoneType<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.ensemble._forest.ExtraTreesRegressor" [color="black", fontcolor="black", label=<{ExtraTreesRegressor|ccp_alpha : float<br ALIGN="LEFT"/>criterion : str<br ALIGN="LEFT"/>max_depth : NoneType<br ALIGN="LEFT"/>max_features : float<br ALIGN="LEFT"/>max_leaf_nodes : NoneType<br ALIGN="LEFT"/>min_impurity_decrease : float<br ALIGN="LEFT"/>min_samples_leaf : int<br ALIGN="LEFT"/>min_samples_split : int<br ALIGN="LEFT"/>min_weight_fraction_leaf : float<br ALIGN="LEFT"/>monotonic_cst : NoneType<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.decomposition._factor_analysis.FactorAnalysis" [color="black", fontcolor="black", label=<{FactorAnalysis|components_<br ALIGN="LEFT"/>copy : bool<br ALIGN="LEFT"/>iterated_power : int<br ALIGN="LEFT"/>loglike_ : list<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>mean_<br ALIGN="LEFT"/>n_components : NoneType, int<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>noise_variance_ : ndarray<br ALIGN="LEFT"/>noise_variance_init : NoneType<br ALIGN="LEFT"/>random_state : int<br ALIGN="LEFT"/>rotation : NoneType<br ALIGN="LEFT"/>svd_method : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_covariance()<br ALIGN="LEFT"/>get_precision()<br ALIGN="LEFT"/>score(X, y)<br ALIGN="LEFT"/>score_samples(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_search.FailingClassifier" [color="black", fontcolor="black", label=<{FailingClassifier|FAILING_PARAMETER : int<br ALIGN="LEFT"/>parameter : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>score(X, Y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_search.test_searchcv_raise_warning_with_non_finite_score.FailingScorer" [color="black", fontcolor="black", label=<{FailingScorer|n_counts : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.cluster.tests.test_hierarchical.test_affinity_passed_to_fix_connectivity.FakeAffinity" [color="black", fontcolor="black", label=<{FakeAffinity|counter : int<br ALIGN="LEFT"/>|increment()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_successive_halving.FastClassifier" [color="black", fontcolor="black", label=<{FastClassifier|<br ALIGN="LEFT"/>|get_params(deep)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_successive_halving.test_base_estimator_inputs.FastClassifierBookKeeping" [color="black", fontcolor="black", label=<{FastClassifierBookKeeping|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>set_params()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.decomposition._fastica.FastICA" [color="black", fontcolor="black", label=<{FastICA|algorithm : str<br ALIGN="LEFT"/>components_ : ndarray<br ALIGN="LEFT"/>fun : str<br ALIGN="LEFT"/>fun_args : NoneType<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>mean_<br ALIGN="LEFT"/>mixing_ : tuple<br ALIGN="LEFT"/>n_components : NoneType<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>w_init : NoneType<br ALIGN="LEFT"/>whiten : str<br ALIGN="LEFT"/>whiten_solver : str<br ALIGN="LEFT"/>whitening_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>inverse_transform(X, copy)<br ALIGN="LEFT"/>transform(X, copy)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.cluster._agglomerative.FeatureAgglomeration" [color="black", fontcolor="black", label=<{FeatureAgglomeration|fit_predict<br ALIGN="LEFT"/>pooling_func<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.feature_extraction._hash.FeatureHasher" [color="black", fontcolor="black", label=<{FeatureHasher|alternate_sign : bool<br ALIGN="LEFT"/>dtype<br ALIGN="LEFT"/>input_type : str<br ALIGN="LEFT"/>n_features : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(raw_X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_pipeline.FeatureNameSaver" [color="black", fontcolor="black", label=<{FeatureNameSaver|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.pipeline.FeatureUnion" [color="black", fontcolor="black", label=<{FeatureUnion|feature_names_in_<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>named_transformers<br ALIGN="LEFT"/>transformer_list : list<br ALIGN="LEFT"/>transformer_weights : NoneType<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>verbose_feature_names_out : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>get_params(deep)<br ALIGN="LEFT"/>set_output()<br ALIGN="LEFT"/>set_params()<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.exceptions.FitFailedWarning" [color="black", fontcolor="red", label=<{FitFailedWarning|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_pipeline.FitParamT" [color="black", fontcolor="black", label=<{FitParamT|fitted_ : bool<br ALIGN="LEFT"/>successful : bool<br ALIGN="LEFT"/>|fit(X, y, should_succeed)<br ALIGN="LEFT"/>fit_predict(X, y, should_succeed)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>score(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.feature_selection.tests.test_from_model.FixedImportanceEstimator" [color="black", fontcolor="black", label=<{FixedImportanceEstimator|feature_importances_ : ndarray<br ALIGN="LEFT"/>importances<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._classification_threshold.FixedThresholdClassifier" [color="black", fontcolor="black", label=<{FixedThresholdClassifier|classes_<br ALIGN="LEFT"/>estimator_<br ALIGN="LEFT"/>pos_label : NoneType<br ALIGN="LEFT"/>threshold : str<br ALIGN="LEFT"/>|get_metadata_routing()<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_html_repr.test_html_documentation_link_mixin_get_doc_link_instance.FooBar" [color="black", fontcolor="black", label=<{FooBar|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_html_repr.test_html_documentation_link_mixin_get_doc_link_class.FooBar" [color="black", fontcolor="black", label=<{FooBar|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_html_repr.test_html_documentation_link_mixin_doc_link_url_param_generator_class.FooBar" [color="black", fontcolor="black", label=<{FooBar|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.ensemble._forest.ForestClassifier" [color="black", fontcolor="black", label=<{ForestClassifier|classes_ : list<br ALIGN="LEFT"/>n_classes_ : list<br ALIGN="LEFT"/>oob_decision_function_ : ndarray<br ALIGN="LEFT"/>oob_score_ : float<br ALIGN="LEFT"/>|predict(X)<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble._forest.ForestRegressor" [color="black", fontcolor="black", label=<{ForestRegressor|oob_prediction_ : ndarray<br ALIGN="LEFT"/>oob_score_ : float<br ALIGN="LEFT"/>|predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.test_clone_protocol.FrozenEstimator" [color="black", fontcolor="black", label=<{FrozenEstimator|fitted_estimator<br ALIGN="LEFT"/>|fit()<br ALIGN="LEFT"/>fit_transform()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.frozen._frozen.FrozenEstimator" [color="black", fontcolor="black", label=<{FrozenEstimator|estimator<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_params(deep)<br ALIGN="LEFT"/>set_params()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.preprocessing._function_transformer.FunctionTransformer" [color="black", fontcolor="black", label=<{FunctionTransformer|accept_sparse : bool<br ALIGN="LEFT"/>check_inverse : bool<br ALIGN="LEFT"/>feature_names_out : NoneType<br ALIGN="LEFT"/>func : NoneType<br ALIGN="LEFT"/>inv_kw_args : NoneType<br ALIGN="LEFT"/>inverse_func : NoneType<br ALIGN="LEFT"/>kw_args : NoneType, dict<br ALIGN="LEFT"/>validate : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>set_output()<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._glm.glm.GammaRegressor" [color="black", fontcolor="black", label=<{GammaRegressor|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.mixture._gaussian_mixture.GaussianMixture" [color="black", fontcolor="black", label=<{GaussianMixture|covariance_type : str<br ALIGN="LEFT"/>covariances_ : NoneType<br ALIGN="LEFT"/>means_<br ALIGN="LEFT"/>means_init : NoneType<br ALIGN="LEFT"/>precisions_ : ndarray<br ALIGN="LEFT"/>precisions_cholesky_ : ndarray<br ALIGN="LEFT"/>precisions_init : NoneType, ndarray<br ALIGN="LEFT"/>weights_<br ALIGN="LEFT"/>weights_init : NoneType<br ALIGN="LEFT"/>|aic(X)<br ALIGN="LEFT"/>bic(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.naive_bayes.GaussianNB" [color="black", fontcolor="black", label=<{GaussianNB|class_count_ : ndarray<br ALIGN="LEFT"/>class_prior_ : ndarray<br ALIGN="LEFT"/>classes_ : NoneType<br ALIGN="LEFT"/>epsilon_<br ALIGN="LEFT"/>priors : NoneType<br ALIGN="LEFT"/>theta_ : ndarray<br ALIGN="LEFT"/>var_ : ndarray<br ALIGN="LEFT"/>var_smoothing : float<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>partial_fit(X, y, classes, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.gaussian_process._gpc.GaussianProcessClassifier" [color="black", fontcolor="black", label=<{GaussianProcessClassifier|base_estimator_<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>copy_X_train : bool<br ALIGN="LEFT"/>kernel : NoneType<br ALIGN="LEFT"/>kernel_<br ALIGN="LEFT"/>log_marginal_likelihood_value_<br ALIGN="LEFT"/>max_iter_predict : int<br ALIGN="LEFT"/>multi_class : str<br ALIGN="LEFT"/>n_classes_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>n_restarts_optimizer : int<br ALIGN="LEFT"/>optimizer : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>warm_start : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>log_marginal_likelihood(theta, eval_gradient, clone_kernel)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.gaussian_process._gpr.GaussianProcessRegressor" [color="black", fontcolor="black", label=<{GaussianProcessRegressor|L_ : tuple<br ALIGN="LEFT"/>X_train_<br ALIGN="LEFT"/>alpha : float<br ALIGN="LEFT"/>alpha_ : tuple<br ALIGN="LEFT"/>copy_X_train : bool<br ALIGN="LEFT"/>kernel : NoneType<br ALIGN="LEFT"/>kernel_<br ALIGN="LEFT"/>log_marginal_likelihood_value_ : tuple<br ALIGN="LEFT"/>n_restarts_optimizer : int<br ALIGN="LEFT"/>n_targets : NoneType<br ALIGN="LEFT"/>normalize_y : bool<br ALIGN="LEFT"/>optimizer : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>y_train_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>log_marginal_likelihood(theta, eval_gradient, clone_kernel)<br ALIGN="LEFT"/>predict(X, return_std, return_cov)<br ALIGN="LEFT"/>sample_y(X, n_samples, random_state)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.random_projection.GaussianRandomProjection" [color="black", fontcolor="black", label=<{GaussianRandomProjection|<br ALIGN="LEFT"/>|transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.gaussian_process.kernels.GenericKernelMixin" [color="black", fontcolor="black", label=<{GenericKernelMixin|requires_vector_input<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.feature_selection._univariate_selection.GenericUnivariateSelect" [color="black", fontcolor="black", label=<{GenericUnivariateSelect|mode : str<br ALIGN="LEFT"/>param : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.ensemble._gb.GradientBoostingClassifier" [color="black", fontcolor="black", label=<{GradientBoostingClassifier|classes_<br ALIGN="LEFT"/>n_classes_<br ALIGN="LEFT"/>n_trees_per_iteration_<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>staged_decision_function(X)<br ALIGN="LEFT"/>staged_predict(X)<br ALIGN="LEFT"/>staged_predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble._gb.GradientBoostingRegressor" [color="black", fontcolor="black", label=<{GradientBoostingRegressor|n_trees_per_iteration_ : int<br ALIGN="LEFT"/>|apply(X)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>staged_predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.covariance._graph_lasso.GraphicalLasso" [color="black", fontcolor="black", label=<{GraphicalLasso|alpha : float<br ALIGN="LEFT"/>costs_ : list, tuple<br ALIGN="LEFT"/>covariance : NoneType<br ALIGN="LEFT"/>covariance_<br ALIGN="LEFT"/>location_ : ndarray<br ALIGN="LEFT"/>n_iter_ : int<br ALIGN="LEFT"/>precision_ : ndarray, tuple<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.covariance._graph_lasso.GraphicalLassoCV" [color="black", fontcolor="black", label=<{GraphicalLassoCV|alpha_<br ALIGN="LEFT"/>alphas : int<br ALIGN="LEFT"/>costs_ : list, tuple<br ALIGN="LEFT"/>covariance_<br ALIGN="LEFT"/>cv : NoneType<br ALIGN="LEFT"/>cv_results_ : dict<br ALIGN="LEFT"/>location_ : ndarray<br ALIGN="LEFT"/>n_iter_ : int<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>n_refinements : int<br ALIGN="LEFT"/>precision_ : ndarray, tuple<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_pprint.GridSearchCV" [color="black", fontcolor="black", label=<{GridSearchCV|cv : str<br ALIGN="LEFT"/>error_score : str<br ALIGN="LEFT"/>estimator<br ALIGN="LEFT"/>iid : str<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>param_grid<br ALIGN="LEFT"/>pre_dispatch : str<br ALIGN="LEFT"/>refit : bool<br ALIGN="LEFT"/>return_train_score : bool<br ALIGN="LEFT"/>scoring : NoneType<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.model_selection._search.GridSearchCV" [color="black", fontcolor="black", label=<{GridSearchCV|param_grid<br ALIGN="LEFT"/>scoring : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.model_selection._split.GroupKFold" [color="black", fontcolor="black", label=<{GroupKFold|<br ALIGN="LEFT"/>|split(X, y, groups)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._split.GroupShuffleSplit" [color="black", fontcolor="black", label=<{GroupShuffleSplit|<br ALIGN="LEFT"/>|split(X, y, groups)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._split.GroupsConsumerMixin" [color="black", fontcolor="black", label=<{GroupsConsumerMixin|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.cluster._hdbscan.hdbscan.HDBSCAN" [color="black", fontcolor="black", label=<{HDBSCAN|algorithm : str<br ALIGN="LEFT"/>allow_single_cluster : bool<br ALIGN="LEFT"/>alpha : float<br ALIGN="LEFT"/>centroids_ : ndarray<br ALIGN="LEFT"/>cluster_selection_epsilon : float<br ALIGN="LEFT"/>cluster_selection_method : str<br ALIGN="LEFT"/>copy : bool<br ALIGN="LEFT"/>labels_ : ndarray<br ALIGN="LEFT"/>leaf_size : int<br ALIGN="LEFT"/>max_cluster_size : NoneType<br ALIGN="LEFT"/>medoids_ : ndarray<br ALIGN="LEFT"/>metric : str<br ALIGN="LEFT"/>metric_params : NoneType<br ALIGN="LEFT"/>min_cluster_size : int<br ALIGN="LEFT"/>min_samples : NoneType<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>probabilities_ : ndarray<br ALIGN="LEFT"/>store_centers : NoneType<br ALIGN="LEFT"/>|dbscan_clustering(cut_distance, min_cluster_size)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>fit_predict(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn._loss.loss.HalfBinomialLoss" [color="black", fontcolor="black", label=<{HalfBinomialLoss|interval_y_true<br ALIGN="LEFT"/>|constant_to_optimal_zero(y_true, sample_weight)<br ALIGN="LEFT"/>predict_proba(raw_prediction)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn._loss.loss.HalfGammaLoss" [color="black", fontcolor="black", label=<{HalfGammaLoss|interval_y_true<br ALIGN="LEFT"/>|constant_to_optimal_zero(y_true, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn._loss.link.HalfLogitLink" [color="black", fontcolor="black", label=<{HalfLogitLink|interval_y_pred<br ALIGN="LEFT"/>|inverse(raw_prediction, out)<br ALIGN="LEFT"/>link(y_pred, out)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn._loss.loss.HalfMultinomialLoss" [color="black", fontcolor="black", label=<{HalfMultinomialLoss|interval_y_pred<br ALIGN="LEFT"/>interval_y_true<br ALIGN="LEFT"/>is_multiclass : bool<br ALIGN="LEFT"/>|fit_intercept_only(y_true, sample_weight)<br ALIGN="LEFT"/>gradient_proba(y_true, raw_prediction, sample_weight, gradient_out, proba_out, n_threads)<br ALIGN="LEFT"/>in_y_true_range(y)<br ALIGN="LEFT"/>predict_proba(raw_prediction)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn._loss.loss.HalfPoissonLoss" [color="black", fontcolor="black", label=<{HalfPoissonLoss|interval_y_true<br ALIGN="LEFT"/>|constant_to_optimal_zero(y_true, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn._loss.loss.HalfSquaredError" [color="black", fontcolor="black", label=<{HalfSquaredError|constant_hessian<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn._loss.loss.HalfTweedieLoss" [color="black", fontcolor="black", label=<{HalfTweedieLoss|interval_y_true<br ALIGN="LEFT"/>|constant_to_optimal_zero(y_true, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn._loss.loss.HalfTweedieLossIdentity" [color="black", fontcolor="black", label=<{HalfTweedieLossIdentity|interval_y_pred<br ALIGN="LEFT"/>interval_y_true<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.model_selection._search_successive_halving.HalvingGridSearchCV" [color="black", fontcolor="black", label=<{HalvingGridSearchCV|param_grid<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.model_selection._search_successive_halving.HalvingRandomSearchCV" [color="black", fontcolor="black", label=<{HalvingRandomSearchCV|n_candidates : str<br ALIGN="LEFT"/>param_distributions<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.HasImmutableParameters" [color="black", fontcolor="black", label=<{HasImmutableParameters|p : int<br ALIGN="LEFT"/>q<br ALIGN="LEFT"/>r : object<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._param_validation.HasMethods" [color="black", fontcolor="black", label=<{HasMethods|methods : list<br ALIGN="LEFT"/>|is_satisfied_by(val)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.HasMutableParameters" [color="black", fontcolor="black", label=<{HasMutableParameters|p : object<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.feature_extraction.text.HashingVectorizer" [color="black", fontcolor="black", label=<{HashingVectorizer|alternate_sign : bool<br ALIGN="LEFT"/>analyzer : str<br ALIGN="LEFT"/>binary : bool<br ALIGN="LEFT"/>decode_error : str<br ALIGN="LEFT"/>dtype<br ALIGN="LEFT"/>encoding : str<br ALIGN="LEFT"/>input : str<br ALIGN="LEFT"/>lowercase : bool<br ALIGN="LEFT"/>n_features : int<br ALIGN="LEFT"/>ngram_range : tuple<br ALIGN="LEFT"/>norm : str<br ALIGN="LEFT"/>preprocessor : NoneType<br ALIGN="LEFT"/>stop_words : NoneType<br ALIGN="LEFT"/>strip_accents : NoneType<br ALIGN="LEFT"/>token_pattern : str<br ALIGN="LEFT"/>tokenizer : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>partial_fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._param_validation.Hidden" [color="black", fontcolor="black", label=<{Hidden|constraint<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.ensemble._hist_gradient_boosting.gradient_boosting.HistGradientBoostingClassifier" [color="black", fontcolor="black", label=<{HistGradientBoostingClassifier|class_weight : NoneType<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>n_trees_per_iteration_<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>staged_decision_function(X)<br ALIGN="LEFT"/>staged_predict(X)<br ALIGN="LEFT"/>staged_predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble._hist_gradient_boosting.gradient_boosting.HistGradientBoostingRegressor" [color="black", fontcolor="black", label=<{HistGradientBoostingRegressor|n_trees_per_iteration_ : int<br ALIGN="LEFT"/>quantile : NoneType<br ALIGN="LEFT"/>|predict(X)<br ALIGN="LEFT"/>staged_predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn._loss.loss.HuberLoss" [color="black", fontcolor="black", label=<{HuberLoss|approx_hessian : bool<br ALIGN="LEFT"/>constant_hessian : bool<br ALIGN="LEFT"/>differentiable : bool<br ALIGN="LEFT"/>need_update_leaves_values : bool<br ALIGN="LEFT"/>quantile : float<br ALIGN="LEFT"/>|fit_intercept_only(y_true, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._huber.HuberRegressor" [color="black", fontcolor="black", label=<{HuberRegressor|alpha : float<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>epsilon : float<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_ : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>outliers_<br ALIGN="LEFT"/>scale_<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>warm_start : bool<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.gaussian_process.kernels.Hyperparameter" [color="black", fontcolor="black", label=<{Hyperparameter|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn._loss.link.IdentityLink" [color="black", fontcolor="black", label=<{IdentityLink|inverse<br ALIGN="LEFT"/>|link(y_pred, out)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_metadata_routing.test_setting_default_requests.ImplicitRequest" [color="black", fontcolor="black", label=<{ImplicitRequest|<br ALIGN="LEFT"/>|fit(X, y, prop)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_metadata_routing.test_setting_default_requests.ImplicitRequestRemoval" [color="black", fontcolor="black", label=<{ImplicitRequestRemoval|<br ALIGN="LEFT"/>|fit(X, y, prop)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.exceptions.InconsistentVersionWarning" [color="black", fontcolor="red", label=<{InconsistentVersionWarning|current_sklearn_version<br ALIGN="LEFT"/>estimator_name<br ALIGN="LEFT"/>original_sklearn_version<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.decomposition._incremental_pca.IncrementalPCA" [color="black", fontcolor="black", label=<{IncrementalPCA|batch_size : NoneType<br ALIGN="LEFT"/>batch_size_<br ALIGN="LEFT"/>components_ : NoneType<br ALIGN="LEFT"/>copy : bool<br ALIGN="LEFT"/>explained_variance_ : NoneType<br ALIGN="LEFT"/>explained_variance_ratio_ : NoneType<br ALIGN="LEFT"/>mean_ : float<br ALIGN="LEFT"/>n_components : NoneType<br ALIGN="LEFT"/>n_components_<br ALIGN="LEFT"/>n_samples_seen_ : float, int<br ALIGN="LEFT"/>noise_variance_ : NoneType, float<br ALIGN="LEFT"/>singular_values_ : NoneType<br ALIGN="LEFT"/>var_ : NoneType, float<br ALIGN="LEFT"/>whiten : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>partial_fit(X, y, check_input)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.externals._packaging._structures.InfinityType" [color="black", fontcolor="black", label=<{InfinityType|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_base.InheritDiamondOverwriteTag" [color="black", fontcolor="black", label=<{InheritDiamondOverwriteTag|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils._tags.InputTags" [color="black", fontcolor="black", label=<{InputTags|allow_nan : bool<br ALIGN="LEFT"/>categorical : bool<br ALIGN="LEFT"/>dict : bool<br ALIGN="LEFT"/>one_d_array : bool<br ALIGN="LEFT"/>pairwise : bool<br ALIGN="LEFT"/>positive_only : bool<br ALIGN="LEFT"/>sparse : bool<br ALIGN="LEFT"/>string : bool<br ALIGN="LEFT"/>three_d_array : bool<br ALIGN="LEFT"/>two_d_array : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn._loss.link.Interval" [color="black", fontcolor="black", label=<{Interval|high : float<br ALIGN="LEFT"/>high_inclusive : bool<br ALIGN="LEFT"/>low : float<br ALIGN="LEFT"/>low_inclusive : bool<br ALIGN="LEFT"/>|includes(x)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._param_validation.Interval" [color="black", fontcolor="black", label=<{Interval|closed<br ALIGN="LEFT"/>left<br ALIGN="LEFT"/>right<br ALIGN="LEFT"/>type<br ALIGN="LEFT"/>|is_satisfied_by(val)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_metadata_routing.test_process_routing_invalid_object.InvalidObject" [color="black", fontcolor="black", label=<{InvalidObject|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils._param_validation.InvalidParameterError" [color="black", fontcolor="red", label=<{InvalidParameterError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_metadata_routing.test_removing_non_existing_param_raises.InvalidRequestRemoval" [color="black", fontcolor="black", label=<{InvalidRequestRemoval|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.externals._packaging.version.InvalidVersion" [color="black", fontcolor="red", label=<{InvalidVersion|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.ensemble._iforest.IsolationForest" [color="black", fontcolor="black", label=<{IsolationForest|contamination : str<br ALIGN="LEFT"/>max_samples_ : float, int<br ALIGN="LEFT"/>offset_ : float, ndarray<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>score_samples(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.manifold._isomap.Isomap" [color="black", fontcolor="black", label=<{Isomap|dist_matrix_<br ALIGN="LEFT"/>eigen_solver : str<br ALIGN="LEFT"/>embedding_<br ALIGN="LEFT"/>feature_names_in_<br ALIGN="LEFT"/>kernel_pca_<br ALIGN="LEFT"/>max_iter : NoneType<br ALIGN="LEFT"/>metric : str<br ALIGN="LEFT"/>metric_params : NoneType<br ALIGN="LEFT"/>n_components : int<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>n_neighbors : int<br ALIGN="LEFT"/>nbrs_<br ALIGN="LEFT"/>neighbors_algorithm : str<br ALIGN="LEFT"/>p : int<br ALIGN="LEFT"/>path_method : str<br ALIGN="LEFT"/>radius : NoneType<br ALIGN="LEFT"/>tol : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>reconstruction_error()<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.isotonic.IsotonicRegression" [color="black", fontcolor="black", label=<{IsotonicRegression|X_max_<br ALIGN="LEFT"/>X_min_<br ALIGN="LEFT"/>X_thresholds_<br ALIGN="LEFT"/>f_ : interp1d<br ALIGN="LEFT"/>increasing : bool<br ALIGN="LEFT"/>increasing_ : bool<br ALIGN="LEFT"/>out_of_bounds : str<br ALIGN="LEFT"/>y_max : NoneType<br ALIGN="LEFT"/>y_min : NoneType<br ALIGN="LEFT"/>y_thresholds_<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>predict(T)<br ALIGN="LEFT"/>transform(T)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.impute._iterative.IterativeImputer" [color="black", fontcolor="black", label=<{IterativeImputer|estimator : NoneType<br ALIGN="LEFT"/>fill_value : NoneType<br ALIGN="LEFT"/>imputation_order : str<br ALIGN="LEFT"/>imputation_sequence_ : list<br ALIGN="LEFT"/>initial_imputer_ : NoneType<br ALIGN="LEFT"/>initial_strategy : str<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>max_value<br ALIGN="LEFT"/>min_value<br ALIGN="LEFT"/>n_features_with_missing_<br ALIGN="LEFT"/>n_iter_ : int<br ALIGN="LEFT"/>n_nearest_features : NoneType<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>random_state_<br ALIGN="LEFT"/>sample_posterior : bool<br ALIGN="LEFT"/>skip_complete : bool<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.K" [color="black", fontcolor="black", label=<{K|c : NoneType<br ALIGN="LEFT"/>d : NoneType<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.preprocessing._discretization.KBinsDiscretizer" [color="black", fontcolor="black", label=<{KBinsDiscretizer|bin_edges_ : ndarray<br ALIGN="LEFT"/>dtype : NoneType<br ALIGN="LEFT"/>encode : str<br ALIGN="LEFT"/>n_bins : int<br ALIGN="LEFT"/>n_bins_ : ndarray<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>strategy : str<br ALIGN="LEFT"/>subsample : int<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._split.KFold" [color="black", fontcolor="black", label=<{KFold|random_state<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.cluster._kmeans.KMeans" [color="black", fontcolor="black", label=<{KMeans|algorithm : str<br ALIGN="LEFT"/>cluster_centers_ : NoneType, ndarray<br ALIGN="LEFT"/>copy_x : bool<br ALIGN="LEFT"/>inertia_ : NoneType<br ALIGN="LEFT"/>labels_ : NoneType, ndarray<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.impute._knn.KNNImputer" [color="black", fontcolor="black", label=<{KNNImputer|copy : bool<br ALIGN="LEFT"/>metric : str<br ALIGN="LEFT"/>n_neighbors : int<br ALIGN="LEFT"/>weights : str<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.neighbors._classification.KNeighborsClassifier" [color="black", fontcolor="black", label=<{KNeighborsClassifier|weights : str<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>score(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.neighbors._base.KNeighborsMixin" [color="black", fontcolor="black", label=<{KNeighborsMixin|<br ALIGN="LEFT"/>|kneighbors(X, n_neighbors, return_distance)<br ALIGN="LEFT"/>kneighbors_graph(X, n_neighbors, mode)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.neighbors._regression.KNeighborsRegressor" [color="black", fontcolor="black", label=<{KNeighborsRegressor|weights : str<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.neighbors._graph.KNeighborsTransformer" [color="black", fontcolor="black", label=<{KNeighborsTransformer|mode : str<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.gaussian_process.kernels.Kernel" [color="black", fontcolor="black", label=<{Kernel|bounds<br ALIGN="LEFT"/>hyperparameters<br ALIGN="LEFT"/>n_dims<br ALIGN="LEFT"/>requires_vector_input<br ALIGN="LEFT"/>theta<br ALIGN="LEFT"/>|clone_with_theta(theta)<br ALIGN="LEFT"/><I>diag</I>(X)<br ALIGN="LEFT"/>get_params(deep)<br ALIGN="LEFT"/><I>is_stationary</I>()<br ALIGN="LEFT"/>set_params()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.preprocessing._data.KernelCenterer" [color="black", fontcolor="black", label=<{KernelCenterer|K_fit_all_<br ALIGN="LEFT"/>K_fit_rows_<br ALIGN="LEFT"/>|fit(K, y)<br ALIGN="LEFT"/>transform(K, copy)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.neighbors._kde.KernelDensity" [color="black", fontcolor="black", label=<{KernelDensity|algorithm : str<br ALIGN="LEFT"/>atol : int<br ALIGN="LEFT"/>bandwidth : float<br ALIGN="LEFT"/>bandwidth_ : float<br ALIGN="LEFT"/>breadth_first : bool<br ALIGN="LEFT"/>kernel : str<br ALIGN="LEFT"/>leaf_size : int<br ALIGN="LEFT"/>metric : str<br ALIGN="LEFT"/>metric_params : NoneType<br ALIGN="LEFT"/>rtol : int<br ALIGN="LEFT"/>tree_<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>sample(n_samples, random_state)<br ALIGN="LEFT"/>score(X, y)<br ALIGN="LEFT"/>score_samples(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.gaussian_process.kernels.KernelOperator" [color="black", fontcolor="black", label=<{KernelOperator|bounds<br ALIGN="LEFT"/>hyperparameters<br ALIGN="LEFT"/>k1<br ALIGN="LEFT"/>k2<br ALIGN="LEFT"/>requires_vector_input<br ALIGN="LEFT"/>theta<br ALIGN="LEFT"/>|get_params(deep)<br ALIGN="LEFT"/>is_stationary()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.decomposition._kernel_pca.KernelPCA" [color="black", fontcolor="black", label=<{KernelPCA|X_fit_ : str, tuple<br ALIGN="LEFT"/>X_transformed_fit_<br ALIGN="LEFT"/>alpha : float<br ALIGN="LEFT"/>coef0 : int<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>degree : int<br ALIGN="LEFT"/>dual_coef_ : ndarray<br ALIGN="LEFT"/>eigen_solver : str<br ALIGN="LEFT"/>eigenvalues_ : ndarray<br ALIGN="LEFT"/>eigenvectors_<br ALIGN="LEFT"/>fit_inverse_transform : bool<br ALIGN="LEFT"/>gamma : NoneType<br ALIGN="LEFT"/>gamma_ : NoneType<br ALIGN="LEFT"/>iterated_power : str<br ALIGN="LEFT"/>kernel : str<br ALIGN="LEFT"/>kernel_params : NoneType<br ALIGN="LEFT"/>max_iter : NoneType<br ALIGN="LEFT"/>n_components : NoneType<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>remove_zero_eig : bool<br ALIGN="LEFT"/>tol : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.kernel_ridge.KernelRidge" [color="black", fontcolor="black", label=<{KernelRidge|X_fit_<br ALIGN="LEFT"/>alpha : int<br ALIGN="LEFT"/>coef0 : int<br ALIGN="LEFT"/>degree : int<br ALIGN="LEFT"/>dual_coef_ : ndarray<br ALIGN="LEFT"/>gamma : NoneType<br ALIGN="LEFT"/>kernel : str<br ALIGN="LEFT"/>kernel_params : NoneType<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._pprint.KeyValTuple" [color="black", fontcolor="black", label=<{KeyValTuple|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils._pprint.KeyValTupleParam" [color="black", fontcolor="black", label=<{KeyValTupleParam|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_testing.Klass" [color="black", fontcolor="black", label=<{Klass|<br ALIGN="LEFT"/>|<I>f_bad_sections</I>(X, y)<br ALIGN="LEFT"/><I>f_missing</I>(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.externals._arff.LODData" [color="black", fontcolor="black", label=<{LODData|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.externals._arff.LODGeneratorData" [color="black", fontcolor="black", label=<{LODGeneratorData|<br ALIGN="LEFT"/>|decode_rows(stream, conversors)<br ALIGN="LEFT"/>encode_data(data, attributes)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.preprocessing._label.LabelBinarizer" [color="black", fontcolor="black", label=<{LabelBinarizer|classes_<br ALIGN="LEFT"/>neg_label : int<br ALIGN="LEFT"/>pos_label : int<br ALIGN="LEFT"/>sparse_input_<br ALIGN="LEFT"/>sparse_output : bool<br ALIGN="LEFT"/>y_type_ : str<br ALIGN="LEFT"/>|fit(y)<br ALIGN="LEFT"/>fit_transform(y)<br ALIGN="LEFT"/>inverse_transform(Y, threshold)<br ALIGN="LEFT"/>transform(y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.preprocessing._label.LabelEncoder" [color="black", fontcolor="black", label=<{LabelEncoder|classes_ : ndarray<br ALIGN="LEFT"/>|fit(y)<br ALIGN="LEFT"/>fit_transform(y)<br ALIGN="LEFT"/>inverse_transform(y)<br ALIGN="LEFT"/>transform(y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.semi_supervised._label_propagation.LabelPropagation" [color="black", fontcolor="black", label=<{LabelPropagation|nn_fit : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.semi_supervised._label_propagation.LabelSpreading" [color="black", fontcolor="black", label=<{LabelSpreading|nn_fit : NoneType<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.LargeSparseNotSupportedClassifier" [color="black", fontcolor="black", label=<{LargeSparseNotSupportedClassifier|raise_for_type : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._least_angle.Lars" [color="black", fontcolor="black", label=<{Lars|active_ : list<br ALIGN="LEFT"/>alphas_ : list<br ALIGN="LEFT"/>coef_ : ndarray<br ALIGN="LEFT"/>coef_path_ : list<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>eps<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>fit_path : bool<br ALIGN="LEFT"/>jitter : NoneType<br ALIGN="LEFT"/>method : str<br ALIGN="LEFT"/>n_iter_ : list<br ALIGN="LEFT"/>n_nonzero_coefs : int<br ALIGN="LEFT"/>positive : bool<br ALIGN="LEFT"/>precompute : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|fit(X, y, Xy)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._least_angle.LarsCV" [color="black", fontcolor="black", label=<{LarsCV|alpha_<br ALIGN="LEFT"/>cv : NoneType<br ALIGN="LEFT"/>cv_alphas_<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>max_n_alphas : int<br ALIGN="LEFT"/>method : str<br ALIGN="LEFT"/>mse_path_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>parameter : str<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._coordinate_descent.Lasso" [color="black", fontcolor="black", label=<{Lasso|alpha<br ALIGN="LEFT"/>coef_ : ndarray<br ALIGN="LEFT"/>path : staticmethod<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._coordinate_descent.LassoCV" [color="black", fontcolor="black", label=<{LassoCV|path : staticmethod<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._least_angle.LassoLars" [color="black", fontcolor="black", label=<{LassoLars|alpha : float<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>eps<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>fit_path : bool<br ALIGN="LEFT"/>jitter : NoneType<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>method : str<br ALIGN="LEFT"/>positive : bool<br ALIGN="LEFT"/>precompute : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._least_angle.LassoLarsCV" [color="black", fontcolor="black", label=<{LassoLarsCV|copy_X : bool<br ALIGN="LEFT"/>cv : NoneType<br ALIGN="LEFT"/>eps<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>max_n_alphas : int<br ALIGN="LEFT"/>method : str<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>positive : bool<br ALIGN="LEFT"/>precompute : str<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._least_angle.LassoLarsIC" [color="black", fontcolor="black", label=<{LassoLarsIC|alpha_<br ALIGN="LEFT"/>alphas_ : ndarray<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>criterion : str<br ALIGN="LEFT"/>criterion_<br ALIGN="LEFT"/>eps<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>fit_path : bool<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_iter_ : int<br ALIGN="LEFT"/>noise_variance : NoneType<br ALIGN="LEFT"/>noise_variance_<br ALIGN="LEFT"/>parameter : str<br ALIGN="LEFT"/>positive : bool<br ALIGN="LEFT"/>precompute : str<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|fit(X, y, copy_X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model.tests.test_coordinate_descent.test_lassoCV_does_not_set_precompute.LassoMock" [color="black", fontcolor="black", label=<{LassoMock|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.decomposition._lda.LatentDirichletAllocation" [color="black", fontcolor="black", label=<{LatentDirichletAllocation|batch_size : int<br ALIGN="LEFT"/>bound_<br ALIGN="LEFT"/>components_<br ALIGN="LEFT"/>doc_topic_prior : NoneType<br ALIGN="LEFT"/>doc_topic_prior_ : float<br ALIGN="LEFT"/>evaluate_every : int<br ALIGN="LEFT"/>exp_dirichlet_component_<br ALIGN="LEFT"/>learning_decay : float<br ALIGN="LEFT"/>learning_method : str<br ALIGN="LEFT"/>learning_offset : float<br ALIGN="LEFT"/>max_doc_update_iter : int<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>mean_change_tol : float<br ALIGN="LEFT"/>n_batch_iter_ : int<br ALIGN="LEFT"/>n_components : int<br ALIGN="LEFT"/>n_iter_ : int<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>perp_tol : float<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>random_state_ : NoneType<br ALIGN="LEFT"/>topic_word_prior : NoneType<br ALIGN="LEFT"/>topic_word_prior_ : float<br ALIGN="LEFT"/>total_samples : float<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>partial_fit(X, y)<br ALIGN="LEFT"/>perplexity(X, sub_sampling)<br ALIGN="LEFT"/>score(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._plot.LearningCurveDisplay" [color="black", fontcolor="black", label=<{LearningCurveDisplay|score_name : NoneType<br ALIGN="LEFT"/>test_scores<br ALIGN="LEFT"/>train_scores<br ALIGN="LEFT"/>train_sizes<br ALIGN="LEFT"/>|from_estimator(estimator, X, y)<br ALIGN="LEFT"/>plot(ax)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._split.LeaveOneGroupOut" [color="black", fontcolor="black", label=<{LeaveOneGroupOut|<br ALIGN="LEFT"/>|get_n_splits(X, y, groups)<br ALIGN="LEFT"/>split(X, y, groups)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._split.LeaveOneOut" [color="black", fontcolor="black", label=<{LeaveOneOut|<br ALIGN="LEFT"/>|get_n_splits(X, y, groups)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._split.LeavePGroupsOut" [color="black", fontcolor="black", label=<{LeavePGroupsOut|n_groups<br ALIGN="LEFT"/>|get_n_splits(X, y, groups)<br ALIGN="LEFT"/>split(X, y, groups)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._split.LeavePOut" [color="black", fontcolor="black", label=<{LeavePOut|p<br ALIGN="LEFT"/>|get_n_splits(X, y, groups)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.covariance._shrunk_covariance.LedoitWolf" [color="black", fontcolor="black", label=<{LedoitWolf|block_size : int<br ALIGN="LEFT"/>location_ : ndarray<br ALIGN="LEFT"/>shrinkage_ : float, int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.externals._packaging.version.LegacyVersion" [color="black", fontcolor="black", label=<{LegacyVersion|base_version<br ALIGN="LEFT"/>dev<br ALIGN="LEFT"/>epoch<br ALIGN="LEFT"/>is_devrelease<br ALIGN="LEFT"/>is_postrelease<br ALIGN="LEFT"/>is_prerelease<br ALIGN="LEFT"/>local<br ALIGN="LEFT"/>post<br ALIGN="LEFT"/>pre<br ALIGN="LEFT"/>public<br ALIGN="LEFT"/>release<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._base.LinearClassifierMixin" [color="black", fontcolor="black", label=<{LinearClassifierMixin|<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.discriminant_analysis.LinearDiscriminantAnalysis" [color="black", fontcolor="black", label=<{LinearDiscriminantAnalysis|classes_<br ALIGN="LEFT"/>coef_ : ndarray<br ALIGN="LEFT"/>covariance_ : ndarray<br ALIGN="LEFT"/>covariance_estimator : NoneType<br ALIGN="LEFT"/>explained_variance_ratio_<br ALIGN="LEFT"/>intercept_<br ALIGN="LEFT"/>means_<br ALIGN="LEFT"/>n_components : NoneType<br ALIGN="LEFT"/>priors : NoneType<br ALIGN="LEFT"/>priors_ : ndarray<br ALIGN="LEFT"/>scalings_<br ALIGN="LEFT"/>shrinkage : NoneType<br ALIGN="LEFT"/>solver : str<br ALIGN="LEFT"/>store_covariance : bool<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>xbar_<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._base.LinearModel" [color="black", fontcolor="black", label=<{LinearModel|coef_<br ALIGN="LEFT"/>intercept_ : float<br ALIGN="LEFT"/>|<I>fit</I>(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._coordinate_descent.LinearModelCV" [color="black", fontcolor="black", label=<{LinearModelCV|alpha_<br ALIGN="LEFT"/>alphas : NoneType<br ALIGN="LEFT"/>alphas_<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>cv : NoneType<br ALIGN="LEFT"/>dual_gap_<br ALIGN="LEFT"/>eps : float<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_<br ALIGN="LEFT"/>l1_ratio_<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>mse_path_<br ALIGN="LEFT"/>n_alphas : int<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>positive : bool<br ALIGN="LEFT"/>precompute : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>selection : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/><I>path</I>(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._linear_loss.LinearModelLoss" [color="black", fontcolor="black", label=<{LinearModelLoss|base_loss<br ALIGN="LEFT"/>fit_intercept<br ALIGN="LEFT"/>|gradient(coef, X, y, sample_weight, l2_reg_strength, n_threads, raw_prediction)<br ALIGN="LEFT"/>gradient_hessian(coef, X, y, sample_weight, l2_reg_strength, n_threads, gradient_out, hessian_out, raw_prediction)<br ALIGN="LEFT"/>gradient_hessian_product(coef, X, y, sample_weight, l2_reg_strength, n_threads)<br ALIGN="LEFT"/>init_zero_coef(X, dtype)<br ALIGN="LEFT"/>l2_penalty(weights, l2_reg_strength)<br ALIGN="LEFT"/>loss(coef, X, y, sample_weight, l2_reg_strength, n_threads, raw_prediction)<br ALIGN="LEFT"/>loss_gradient(coef, X, y, sample_weight, l2_reg_strength, n_threads, raw_prediction)<br ALIGN="LEFT"/>weight_intercept(coef)<br ALIGN="LEFT"/>weight_intercept_raw(coef, X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._base.LinearRegression" [color="black", fontcolor="black", label=<{LinearRegression|coef_ : list, ndarray, tuple<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>positive : bool<br ALIGN="LEFT"/>rank_ : int<br ALIGN="LEFT"/>singular_ : NoneType, ndarray<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.svm._classes.LinearSVC" [color="black", fontcolor="black", label=<{LinearSVC|C : float<br ALIGN="LEFT"/>class_weight : NoneType<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>dual : str<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_ : float, ndarray<br ALIGN="LEFT"/>intercept_scaling : int<br ALIGN="LEFT"/>loss : str<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>multi_class : str<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>penalty : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_search.LinearSVCNoScore" [color="black", fontcolor="black", label=<{LinearSVCNoScore|score<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.svm._classes.LinearSVR" [color="black", fontcolor="black", label=<{LinearSVR|C : float<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>dual : str<br ALIGN="LEFT"/>epsilon : float<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_ : float<br ALIGN="LEFT"/>intercept_scaling : float<br ALIGN="LEFT"/>loss : str<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.neighbors._lof.LocalOutlierFactor" [color="black", fontcolor="black", label=<{LocalOutlierFactor|contamination : str<br ALIGN="LEFT"/>n_neighbors_<br ALIGN="LEFT"/>negative_outlier_factor_<br ALIGN="LEFT"/>novelty : bool<br ALIGN="LEFT"/>offset_ : float, ndarray<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>fit_predict(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>score_samples(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.manifold._locally_linear.LocallyLinearEmbedding" [color="black", fontcolor="black", label=<{LocallyLinearEmbedding|eigen_solver : str<br ALIGN="LEFT"/>embedding_<br ALIGN="LEFT"/>hessian_tol : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>method : str<br ALIGN="LEFT"/>modified_tol : float<br ALIGN="LEFT"/>n_components : int<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>n_neighbors : int<br ALIGN="LEFT"/>nbrs_<br ALIGN="LEFT"/>neighbors_algorithm : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>reconstruction_error_<br ALIGN="LEFT"/>reg : float<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn._loss.link.LogLink" [color="black", fontcolor="black", label=<{LogLink|interval_y_pred<br ALIGN="LEFT"/>|inverse(raw_prediction, out)<br ALIGN="LEFT"/>link(y_pred, out)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._logistic.LogisticRegression" [color="black", fontcolor="black", label=<{LogisticRegression|C : float<br ALIGN="LEFT"/>class_weight : NoneType<br ALIGN="LEFT"/>classes_ : ndarray, tuple<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>dual : bool<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_ : float, ndarray<br ALIGN="LEFT"/>intercept_scaling : int<br ALIGN="LEFT"/>l1_ratio : NoneType<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>multi_class : str<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>penalty : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>solver : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>warm_start : bool<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_pprint.LogisticRegression" [color="black", fontcolor="black", label=<{LogisticRegression|C : float<br ALIGN="LEFT"/>class_weight : NoneType<br ALIGN="LEFT"/>dual : bool<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_scaling : int<br ALIGN="LEFT"/>l1_ratio : NoneType<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>multi_class : str<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>penalty : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>solver : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>warm_start : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._logistic.LogisticRegressionCV" [color="black", fontcolor="black", label=<{LogisticRegressionCV|C_ : list<br ALIGN="LEFT"/>Cs : int<br ALIGN="LEFT"/>Cs_<br ALIGN="LEFT"/>class_weight : NoneType<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>coef_ : ndarray<br ALIGN="LEFT"/>coefs_paths_ : dict<br ALIGN="LEFT"/>cv : NoneType<br ALIGN="LEFT"/>dual : bool<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_ : ndarray<br ALIGN="LEFT"/>intercept_scaling : float<br ALIGN="LEFT"/>l1_ratio_ : list<br ALIGN="LEFT"/>l1_ratios : NoneType<br ALIGN="LEFT"/>l1_ratios_<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>multi_class : str<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>param : str<br ALIGN="LEFT"/>penalty : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>refit : bool<br ALIGN="LEFT"/>scores_ : dict<br ALIGN="LEFT"/>scoring : NoneType<br ALIGN="LEFT"/>solver : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>score(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn._loss.link.LogitLink" [color="black", fontcolor="black", label=<{LogitLink|interval_y_pred<br ALIGN="LEFT"/>|inverse(raw_prediction, out)<br ALIGN="LEFT"/>link(y_pred, out)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_validation.test__is_polars_df.LooksLikePolars" [color="black", fontcolor="black", label=<{LooksLikePolars|columns : list<br ALIGN="LEFT"/>schema : list<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.neighbors.tests.test_nca.test_toy_example_collapse_points.LossStorer" [color="black", fontcolor="black", label=<{LossStorer|X<br ALIGN="LEFT"/>fake_nca<br ALIGN="LEFT"/>loss<br ALIGN="LEFT"/>same_class_mask<br ALIGN="LEFT"/>|callback(transformation, n_iter)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.manifold._mds.MDS" [color="black", fontcolor="black", label=<{MDS|dissimilarity : str<br ALIGN="LEFT"/>dissimilarity_matrix_ : str, tuple<br ALIGN="LEFT"/>embedding_ : NoneType<br ALIGN="LEFT"/>eps : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>metric : bool<br ALIGN="LEFT"/>n_components : int<br ALIGN="LEFT"/>n_init : int<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>normalized_stress : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>stress_ : NoneType<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|fit(X, y, init)<br ALIGN="LEFT"/>fit_transform(X, y, init)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.neural_network._multilayer_perceptron.MLPClassifier" [color="black", fontcolor="black", label=<{MLPClassifier|best_loss_<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>coefs_ : list<br ALIGN="LEFT"/>intercepts_ : list<br ALIGN="LEFT"/>learning_rate_ : float<br ALIGN="LEFT"/>loss_curve_ : list<br ALIGN="LEFT"/>n_features_in_ : int<br ALIGN="LEFT"/>n_iter_ : int<br ALIGN="LEFT"/>n_layers_ : int<br ALIGN="LEFT"/>n_outputs_ : int<br ALIGN="LEFT"/>out_activation_ : str<br ALIGN="LEFT"/>t_ : int<br ALIGN="LEFT"/>|partial_fit(X, y, classes)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.neural_network._multilayer_perceptron.MLPRegressor" [color="black", fontcolor="black", label=<{MLPRegressor|<br ALIGN="LEFT"/>|partial_fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.gaussian_process.kernels.Matern" [color="black", fontcolor="black", label=<{Matern|nu : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.preprocessing._data.MaxAbsScaler" [color="black", fontcolor="black", label=<{MaxAbsScaler|copy : bool<br ALIGN="LEFT"/>max_abs_ : ndarray<br ALIGN="LEFT"/>n_samples_seen_<br ALIGN="LEFT"/>scale_ : float, ndarray<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>partial_fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.cluster._mean_shift.MeanShift" [color="black", fontcolor="black", label=<{MeanShift|bandwidth : NoneType<br ALIGN="LEFT"/>bin_seeding : bool<br ALIGN="LEFT"/>cluster_all : bool<br ALIGN="LEFT"/>cluster_centers_<br ALIGN="LEFT"/>labels_ : ndarray<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>min_bin_freq : int<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>seeds : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_search.test_cv_results_dtype_issue_29074.MetaEstimator" [color="black", fontcolor="black", label=<{MetaEstimator|base_clf<br ALIGN="LEFT"/>parameter1 : NoneType<br ALIGN="LEFT"/>parameter2 : NoneType<br ALIGN="LEFT"/>parameter3 : NoneType<br ALIGN="LEFT"/>parameter4 : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>score(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.base.MetaEstimatorMixin" [color="black", fontcolor="black", label=<{MetaEstimatorMixin|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.metadata_routing_common.MetaRegressor" [color="black", fontcolor="black", label=<{MetaRegressor|estimator<br ALIGN="LEFT"/>estimator_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.metadata_routing_common.MetaTransformer" [color="black", fontcolor="black", label=<{MetaTransformer|transformer<br ALIGN="LEFT"/>transformer_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._metadata_requests.MetadataRequest" [color="black", fontcolor="black", label=<{MetadataRequest|owner<br ALIGN="LEFT"/>score<br ALIGN="LEFT"/>|consumes(method, params)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._metadata_requests.MetadataRouter" [color="black", fontcolor="black", label=<{MetadataRouter|owner<br ALIGN="LEFT"/>|add()<br ALIGN="LEFT"/>add_self_request(obj)<br ALIGN="LEFT"/>consumes(method, params)<br ALIGN="LEFT"/>route_params()<br ALIGN="LEFT"/>validate_metadata()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._metadata_requests.MethodMapping" [color="black", fontcolor="black", label=<{MethodMapping|<br ALIGN="LEFT"/>|add()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._metadata_requests.MethodMetadataRequest" [color="black", fontcolor="black", label=<{MethodMetadataRequest|method<br ALIGN="LEFT"/>owner<br ALIGN="LEFT"/>requests<br ALIGN="LEFT"/>|add_request()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.covariance._robust_covariance.MinCovDet" [color="black", fontcolor="black", label=<{MinCovDet|assume_centered : bool<br ALIGN="LEFT"/>dist_<br ALIGN="LEFT"/>location_ : ndarray<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>raw_covariance_<br ALIGN="LEFT"/>raw_location_ : ndarray<br ALIGN="LEFT"/>raw_support_ : ndarray<br ALIGN="LEFT"/>store_precision : bool<br ALIGN="LEFT"/>support_ : ndarray<br ALIGN="LEFT"/>support_fraction : NoneType<br ALIGN="LEFT"/>|correct_covariance(data)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>reweight_covariance(data)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble._hist_gradient_boosting.tests.test_gradient_boosting.test_missing_values_minmax_imputation.MinMaxImputer" [color="black", fontcolor="black", label=<{MinMaxImputer|data_max_ : ndarray<br ALIGN="LEFT"/>data_min_ : ndarray<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.preprocessing._data.MinMaxScaler" [color="black", fontcolor="black", label=<{MinMaxScaler|clip : bool<br ALIGN="LEFT"/>copy : bool<br ALIGN="LEFT"/>data_max_ : ndarray<br ALIGN="LEFT"/>data_min_ : ndarray<br ALIGN="LEFT"/>data_range_<br ALIGN="LEFT"/>feature_range : tuple<br ALIGN="LEFT"/>min_<br ALIGN="LEFT"/>n_samples_seen_<br ALIGN="LEFT"/>scale_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>partial_fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.decomposition._dict_learning.MiniBatchDictionaryLearning" [color="black", fontcolor="black", label=<{MiniBatchDictionaryLearning|alpha : int<br ALIGN="LEFT"/>batch_size : int<br ALIGN="LEFT"/>callback : NoneType<br ALIGN="LEFT"/>components_ : ndarray<br ALIGN="LEFT"/>dict_init : NoneType<br ALIGN="LEFT"/>fit_algorithm : str<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>max_no_improvement : int<br ALIGN="LEFT"/>n_components : NoneType<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>n_steps_ : int<br ALIGN="LEFT"/>positive_dict : bool<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>shuffle : bool<br ALIGN="LEFT"/>split_sign : bool<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>partial_fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.cluster._kmeans.MiniBatchKMeans" [color="black", fontcolor="black", label=<{MiniBatchKMeans|batch_size : int<br ALIGN="LEFT"/>cluster_centers_ : ndarray<br ALIGN="LEFT"/>compute_labels : bool<br ALIGN="LEFT"/>inertia_<br ALIGN="LEFT"/>init_size : NoneType<br ALIGN="LEFT"/>labels_<br ALIGN="LEFT"/>max_no_improvement : int<br ALIGN="LEFT"/>n_iter_ : int<br ALIGN="LEFT"/>n_steps_<br ALIGN="LEFT"/>reassignment_ratio : float<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>partial_fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.decomposition._nmf.MiniBatchNMF" [color="black", fontcolor="black", label=<{MiniBatchNMF|batch_size : int<br ALIGN="LEFT"/>components_ : NoneType<br ALIGN="LEFT"/>forget_factor : float<br ALIGN="LEFT"/>fresh_restarts : bool<br ALIGN="LEFT"/>fresh_restarts_max_iter : int<br ALIGN="LEFT"/>max_no_improvement : int<br ALIGN="LEFT"/>n_components_<br ALIGN="LEFT"/>n_iter_ : int<br ALIGN="LEFT"/>n_steps_ : int<br ALIGN="LEFT"/>reconstruction_err_ : ndarray<br ALIGN="LEFT"/>transform_max_iter : NoneType<br ALIGN="LEFT"/>|fit_transform(X, y, W, H)<br ALIGN="LEFT"/>partial_fit(X, y, W, H)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.decomposition._sparse_pca.MiniBatchSparsePCA" [color="black", fontcolor="black", label=<{MiniBatchSparsePCA|batch_size : int<br ALIGN="LEFT"/>callback : NoneType<br ALIGN="LEFT"/>components_<br ALIGN="LEFT"/>max_no_improvement : int<br ALIGN="LEFT"/>n_components_<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>shuffle : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.gaussian_process.tests._mini_sequence_kernel.MiniSeqKernel" [color="black", fontcolor="black", label=<{MiniSeqKernel|baseline_similarity : float<br ALIGN="LEFT"/>baseline_similarity_bounds : tuple<br ALIGN="LEFT"/>hyperparameter_baseline_similarity<br ALIGN="LEFT"/>|clone_with_theta(theta)<br ALIGN="LEFT"/>diag(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._testing.MinimalClassifier" [color="black", fontcolor="black", label=<{MinimalClassifier|classes_<br ALIGN="LEFT"/>param : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_params(deep)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>score(X, y)<br ALIGN="LEFT"/>set_params()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._testing.MinimalRegressor" [color="black", fontcolor="black", label=<{MinimalRegressor|is_fitted_ : bool<br ALIGN="LEFT"/>param : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_params(deep)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>score(X, y)<br ALIGN="LEFT"/>set_params()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._testing.MinimalTransformer" [color="black", fontcolor="black", label=<{MinimalTransformer|is_fitted_ : bool<br ALIGN="LEFT"/>param : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>get_params(deep)<br ALIGN="LEFT"/>set_params()<br ALIGN="LEFT"/>transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.impute._base.MissingIndicator" [color="black", fontcolor="black", label=<{MissingIndicator|error_on_new : bool<br ALIGN="LEFT"/>features : str<br ALIGN="LEFT"/>features_<br ALIGN="LEFT"/>missing_values<br ALIGN="LEFT"/>sparse : str<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._encode.MissingValues" [color="black", fontcolor="black", label=<{MissingValues|nan : bool<br ALIGN="LEFT"/>none : bool<br ALIGN="LEFT"/>|to_list()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._param_validation.MissingValues" [color="black", fontcolor="black", label=<{MissingValues|numeric_only : bool<br ALIGN="LEFT"/>|is_satisfied_by(val)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.MixinAllowNanNewTags" [color="black", fontcolor="black", label=<{MixinAllowNanNewTags|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.MixinAllowNanOldNewTags" [color="black", fontcolor="black", label=<{MixinAllowNanOldNewTags|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.MixinAllowNanOldTags" [color="black", fontcolor="black", label=<{MixinAllowNanOldTags|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.MixinArrayApiSupportNewTags" [color="black", fontcolor="black", label=<{MixinArrayApiSupportNewTags|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.MixinArrayApiSupportOldNewTags" [color="black", fontcolor="black", label=<{MixinArrayApiSupportOldNewTags|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.MixinArrayApiSupportOldTags" [color="black", fontcolor="black", label=<{MixinArrayApiSupportOldTags|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.cluster.tests.test_bicluster.MockBiclustering" [color="black", fontcolor="black", label=<{MockBiclustering|<br ALIGN="LEFT"/>|get_indices(i)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_deprecation.test_deprecated_class_signature.MockClass" [color="black", fontcolor="black", label=<{MockClass|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_deprecation.MockClass1" [color="black", fontcolor="black", label=<{MockClass1|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_deprecation.MockClass2" [color="black", fontcolor="black", label=<{MockClass2|n_features_<br ALIGN="LEFT"/>|<I>method</I>()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_deprecation.MockClass3" [color="black", fontcolor="black", label=<{MockClass3|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_deprecation.MockClass4" [color="black", fontcolor="black", label=<{MockClass4|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_deprecation.MockClass5" [color="black", fontcolor="black", label=<{MockClass5|a<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_deprecation.MockClass6" [color="black", fontcolor="black", label=<{MockClass6|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.ensemble.tests.test_voting.test_sample_weight_kwargs.MockClassifier" [color="black", fontcolor="black", label=<{MockClassifier|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.feature_selection.tests.test_rfe.MockClassifier" [color="black", fontcolor="black", label=<{MockClassifier|classes_<br ALIGN="LEFT"/>coef_ : ndarray<br ALIGN="LEFT"/>decision_function<br ALIGN="LEFT"/>foo_param : int<br ALIGN="LEFT"/>predict_proba<br ALIGN="LEFT"/>transform<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_params(deep)<br ALIGN="LEFT"/>predict(T)<br ALIGN="LEFT"/>score(X, y)<br ALIGN="LEFT"/>set_params()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_validation.MockClassifier" [color="black", fontcolor="black", label=<{MockClassifier|a : int<br ALIGN="LEFT"/>allow_nd : bool<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>dummy_int : NoneType<br ALIGN="LEFT"/>dummy_obj : NoneType<br ALIGN="LEFT"/>dummy_str : NoneType<br ALIGN="LEFT"/>|fit(X, Y, sample_weight, class_prior, sparse_sample_weight, sparse_param, dummy_int, dummy_str, dummy_obj, callback)<br ALIGN="LEFT"/>get_params(deep)<br ALIGN="LEFT"/>predict(T)<br ALIGN="LEFT"/>predict_proba(T)<br ALIGN="LEFT"/>score(X, Y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_search.MockClassifier" [color="black", fontcolor="black", label=<{MockClassifier|classes_<br ALIGN="LEFT"/>decision_function<br ALIGN="LEFT"/>foo_param : int<br ALIGN="LEFT"/>predict_log_proba<br ALIGN="LEFT"/>predict_proba<br ALIGN="LEFT"/>|fit(X, Y)<br ALIGN="LEFT"/>get_params(deep)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>predict(T)<br ALIGN="LEFT"/>score(X, Y)<br ALIGN="LEFT"/>set_params()<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._mocking.MockDataFrame" [color="black", fontcolor="black", label=<{MockDataFrame|array<br ALIGN="LEFT"/>iloc<br ALIGN="LEFT"/>ndim<br ALIGN="LEFT"/>shape<br ALIGN="LEFT"/>values<br ALIGN="LEFT"/>|take(indices, axis)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_indexing.test_get_column_indices_interchange.MockDataFrame" [color="black", fontcolor="black", label=<{MockDataFrame|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.metrics.tests.test_score_objects.test_multimetric_scorer_calls_method_once_regressor_threshold.MockDecisionTreeRegressor" [color="black", fontcolor="black", label=<{MockDecisionTreeRegressor|<br ALIGN="LEFT"/>|predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_testing.MockEst" [color="black", fontcolor="black", label=<{MockEst|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>score(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble.tests.test_weight_boosting.test_samme_proba.MockEstimator" [color="black", fontcolor="black", label=<{MockEstimator|<br ALIGN="LEFT"/>|predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_validation.test_estimator_has.MockEstimator" [color="black", fontcolor="black", label=<{MockEstimator|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_validation.MockEstimatorWithParameter" [color="black", fontcolor="black", label=<{MockEstimatorWithParameter|X_subset : NoneType<br ALIGN="LEFT"/>param : float<br ALIGN="LEFT"/>train_sizes<br ALIGN="LEFT"/>|fit(X_subset, y_subset)<br ALIGN="LEFT"/><I>predict</I>(X)<br ALIGN="LEFT"/>score(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_validation.MockEstimatorWithSingleFitCallAllowed" [color="black", fontcolor="black", label=<{MockEstimatorWithSingleFitCallAllowed|fit_called_ : bool<br ALIGN="LEFT"/>|fit(X_subset, y_subset)<br ALIGN="LEFT"/><I>predict</I>(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_validation.MockImprovingEstimator" [color="black", fontcolor="black", label=<{MockImprovingEstimator|X_subset : NoneType<br ALIGN="LEFT"/>n_max_train_sizes<br ALIGN="LEFT"/>train_sizes : int<br ALIGN="LEFT"/>|fit(X_subset, y_subset)<br ALIGN="LEFT"/><I>predict</I>(X)<br ALIGN="LEFT"/>score(X, Y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_validation.MockIncrementalImprovingEstimator" [color="black", fontcolor="black", label=<{MockIncrementalImprovingEstimator|expected_fit_params : NoneType<br ALIGN="LEFT"/>train_sizes<br ALIGN="LEFT"/>x : NoneType<br ALIGN="LEFT"/>|partial_fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.metrics.tests.test_score_objects.test_multimetric_scorer_calls_method_once_classifier_no_decision.MockKNeighborsClassifier" [color="black", fontcolor="black", label=<{MockKNeighborsClassifier|<br ALIGN="LEFT"/>|predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_testing.MockMetaEstimator" [color="black", fontcolor="black", label=<{MockMetaEstimator|delegate<br ALIGN="LEFT"/>|<I>fit</I>(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/><I>score</I>(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model.tests.test_logistic.test_logistic_cv_mock_scorer.MockScorer" [color="black", fontcolor="black", label=<{MockScorer|calls : int<br ALIGN="LEFT"/>scores : list<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_split.test_build_repr.MockSplitter" [color="black", fontcolor="black", label=<{MockSplitter|a<br ALIGN="LEFT"/>b : int<br ALIGN="LEFT"/>c : NoneType<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_calibration.test_calibration_accepts_ndarray.MockTensorClassifier" [color="black", fontcolor="black", label=<{MockTensorClassifier|classes_<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.ModifiesAnotherValue" [color="black", fontcolor="black", label=<{ModifiesAnotherValue|a : int<br ALIGN="LEFT"/>b : str<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>set_params()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.ModifiesValueInsteadOfRaisingError" [color="black", fontcolor="black", label=<{ModifiesValueInsteadOfRaisingError|p : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>set_params()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.ModifyInitParams" [color="black", fontcolor="black", label=<{ModifyInitParams|a<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.test_no___sklearn_tags__with_more_tags.MoreTagsEstimator" [color="black", fontcolor="black", label=<{MoreTagsEstimator|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_pipeline.Mult" [color="black", fontcolor="black", label=<{Mult|decision_function<br ALIGN="LEFT"/>get_feature_names_out<br ALIGN="LEFT"/>mult : int<br ALIGN="LEFT"/>predict_log_proba<br ALIGN="LEFT"/>predict_proba<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>score(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.MultiInheritanceEstimator" [color="black", fontcolor="black", label=<{MultiInheritanceEstimator|attribute_pickled : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.preprocessing._label.MultiLabelBinarizer" [color="black", fontcolor="black", label=<{MultiLabelBinarizer|classes : NoneType, list<br ALIGN="LEFT"/>classes_ : ndarray<br ALIGN="LEFT"/>sparse_output : bool<br ALIGN="LEFT"/>|fit(y)<br ALIGN="LEFT"/>fit_transform(y)<br ALIGN="LEFT"/>inverse_transform(yt)<br ALIGN="LEFT"/>transform(y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.inspection._plot.tests.test_boundary_decision_display.test_check_boundary_response_method_error.MultiLabelClassifier" [color="black", fontcolor="black", label=<{MultiLabelClassifier|classes_ : list<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.test_check_classifiers_multilabel_output_format_decision_function.MultiLabelClassifierDecisionFunction" [color="black", fontcolor="black", label=<{MultiLabelClassifierDecisionFunction|<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.test_check_classifiers_multilabel_output_format_predict.MultiLabelClassifierPredict" [color="black", fontcolor="black", label=<{MultiLabelClassifierPredict|<br ALIGN="LEFT"/>|predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.test_check_classifiers_multilabel_output_format_predict_proba.MultiLabelClassifierPredictProba" [color="black", fontcolor="black", label=<{MultiLabelClassifierPredictProba|<br ALIGN="LEFT"/>|predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.multioutput.MultiOutputClassifier" [color="black", fontcolor="black", label=<{MultiOutputClassifier|classes_<br ALIGN="LEFT"/>|fit(X, Y, sample_weight)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>score(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.base.MultiOutputMixin" [color="black", fontcolor="black", label=<{MultiOutputMixin|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.multioutput.MultiOutputRegressor" [color="black", fontcolor="black", label=<{MultiOutputRegressor|<br ALIGN="LEFT"/>|partial_fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._coordinate_descent.MultiTaskElasticNet" [color="black", fontcolor="black", label=<{MultiTaskElasticNet|alpha : float<br ALIGN="LEFT"/>coef_ : ndarray<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>dual_gap_<br ALIGN="LEFT"/>eps_<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>l1_ratio : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>param : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>selection : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>warm_start : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._coordinate_descent.MultiTaskElasticNetCV" [color="black", fontcolor="black", label=<{MultiTaskElasticNetCV|alphas : NoneType<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>cv : NoneType<br ALIGN="LEFT"/>eps : float<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>l1_ratio : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_alphas : int<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>path : staticmethod<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>selection : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._coordinate_descent.MultiTaskLasso" [color="black", fontcolor="black", label=<{MultiTaskLasso|alpha : float<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>l1_ratio : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>selection : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>warm_start : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._coordinate_descent.MultiTaskLassoCV" [color="black", fontcolor="black", label=<{MultiTaskLassoCV|path : staticmethod<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.inspection._plot.tests.test_boundary_decision_display.test_check_boundary_response_method_error.MulticlassClassifier" [color="black", fontcolor="black", label=<{MulticlassClassifier|classes_ : list<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn._loss.link.MultinomialLogit" [color="black", fontcolor="black", label=<{MultinomialLogit|interval_y_pred<br ALIGN="LEFT"/>is_multiclass : bool<br ALIGN="LEFT"/>|inverse(raw_prediction, out)<br ALIGN="LEFT"/>link(y_pred, out)<br ALIGN="LEFT"/>symmetrize_raw_prediction(raw_prediction)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.naive_bayes.MultinomialNB" [color="black", fontcolor="black", label=<{MultinomialNB|class_count_<br ALIGN="LEFT"/>feature_count_<br ALIGN="LEFT"/>feature_log_prob_<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.ensemble.tests.test_forest.MyBackend" [color="black", fontcolor="black", label=<{MyBackend|count : int<br ALIGN="LEFT"/>|start_call()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.test_old_tags.MyClass" [color="black", fontcolor="black", label=<{MyClass|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.metrics._plot.tests.test_common_curve_display.test_display_curve_error_no_response.MyClassifier" [color="black", fontcolor="black", label=<{MyClassifier|classes_ : list<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.metrics.tests.test_score_objects.test_multimetric_scorer_calls_method_once.MyClassifier" [color="black", fontcolor="black", label=<{MyClassifier|classes_<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.inspection._plot.tests.test_boundary_decision_display.test_error_bad_response.MyClassifier" [color="black", fontcolor="black", label=<{MyClassifier|classes_ : list<br ALIGN="LEFT"/>fitted_ : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble.tests.test_bagging.test_bagging_get_estimators_indices.MyEstimator" [color="black", fontcolor="black", label=<{MyEstimator|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble.tests.test_stacking.test_stacking_without_n_features_in.MyEstimator" [color="black", fontcolor="black", label=<{MyEstimator|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.MyEstimator" [color="black", fontcolor="black", label=<{MyEstimator|empty : NoneType<br ALIGN="LEFT"/>l1 : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_base.test_raises_on_get_params_non_attribute.MyEstimator" [color="black", fontcolor="black", label=<{MyEstimator|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_validation.test_check_is_fitted_attributes.MyEstimator" [color="black", fontcolor="black", label=<{MyEstimator|a_ : str<br ALIGN="LEFT"/>b_ : str<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.test_tag_test_passes_with_inheritance.MyEstimator" [color="black", fontcolor="black", label=<{MyEstimator|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.test_tags_no_sklearn_tags_concrete_implementation.MyEstimator" [color="black", fontcolor="black", label=<{MyEstimator|is_fitted_ : bool<br ALIGN="LEFT"/>param : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.test_non_deterministic_estimator_skip_tests.MyEstimator" [color="black", fontcolor="black", label=<{MyEstimator|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_html_repr.test_estimator_get_params_return_cls.MyEstimator" [color="black", fontcolor="black", label=<{MyEstimator|<br ALIGN="LEFT"/>|get_params(deep)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_html_repr.test_estimator_html_repr_unfitted_vs_fitted.MyEstimator" [color="black", fontcolor="black", label=<{MyEstimator|fitted_ : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.test_tags_no_sklearn_tags_concrete_implementation.MyEstimator2" [color="black", fontcolor="black", label=<{MyEstimator2|error_type : AttributeError<br ALIGN="LEFT"/>param : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model.tests.test_passive_aggressive.MyPassiveAggressive" [color="black", fontcolor="black", label=<{MyPassiveAggressive|C : float<br ALIGN="LEFT"/>b : float<br ALIGN="LEFT"/>epsilon : float<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>loss : str<br ALIGN="LEFT"/>n_iter : int<br ALIGN="LEFT"/>w : ndarray<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>project(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model.tests.test_perceptron.MyPerceptron" [color="black", fontcolor="black", label=<{MyPerceptron|b : float<br ALIGN="LEFT"/>n_iter : int<br ALIGN="LEFT"/>w : ndarray<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>project(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_multioutput.test_regressor_chain_w_fit_params.MySGD" [color="black", fontcolor="black", label=<{MySGD|sample_weight_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.test_tag_test_passes_with_inheritance.MyTags" [color="black", fontcolor="black", label=<{MyTags|my_tag : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_pprint.NMF" [color="black", fontcolor="black", label=<{NMF|alpha : float<br ALIGN="LEFT"/>beta_loss : str<br ALIGN="LEFT"/>init : NoneType<br ALIGN="LEFT"/>l1_ratio : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_components : NoneType<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>shuffle : bool<br ALIGN="LEFT"/>solver : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.decomposition._nmf.NMF" [color="black", fontcolor="black", label=<{NMF|components_ : NoneType<br ALIGN="LEFT"/>n_components_<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>reconstruction_err_ : ndarray<br ALIGN="LEFT"/>shuffle : bool<br ALIGN="LEFT"/>solver : str<br ALIGN="LEFT"/>|fit_transform(X, y, W, H)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.NaNTag" [color="black", fontcolor="black", label=<{NaNTag|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.feature_selection.tests.test_from_model.NaNTag" [color="black", fontcolor="black", label=<{NaNTag|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.feature_selection.tests.test_from_model.NaNTagRandomForest" [color="black", fontcolor="black", label=<{NaNTagRandomForest|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.neighbors._nearest_centroid.NearestCentroid" [color="black", fontcolor="black", label=<{NearestCentroid|centroids_ : ndarray<br ALIGN="LEFT"/>class_prior_ : ndarray<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>decision_function<br ALIGN="LEFT"/>deviations_ : ndarray<br ALIGN="LEFT"/>metric : str<br ALIGN="LEFT"/>predict_log_proba<br ALIGN="LEFT"/>predict_proba<br ALIGN="LEFT"/>priors : str<br ALIGN="LEFT"/>shrink_threshold : NoneType<br ALIGN="LEFT"/>within_class_std_dev_ : ndarray<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.neighbors._unsupervised.NearestNeighbors" [color="black", fontcolor="black", label=<{NearestNeighbors|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.externals._packaging._structures.NegativeInfinityType" [color="black", fontcolor="black", label=<{NegativeInfinityType|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.neighbors._nca.NeighborhoodComponentsAnalysis" [color="black", fontcolor="black", label=<{NeighborhoodComponentsAnalysis|callback : NoneType<br ALIGN="LEFT"/>components_ : ndarray<br ALIGN="LEFT"/>init : str<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_components : NoneType<br ALIGN="LEFT"/>n_iter_ : int<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>random_state_ : NoneType<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>warm_start : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.neighbors._base.NeighborsBase" [color="black", fontcolor="black", label=<{NeighborsBase|algorithm : str<br ALIGN="LEFT"/>classes_ : list<br ALIGN="LEFT"/>effective_metric_ : str<br ALIGN="LEFT"/>effective_metric_params_ : dict<br ALIGN="LEFT"/>leaf_size : int<br ALIGN="LEFT"/>metric : str<br ALIGN="LEFT"/>metric_params : NoneType<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>n_neighbors : NoneType<br ALIGN="LEFT"/>n_samples_fit_<br ALIGN="LEFT"/>outputs_2d_ : bool<br ALIGN="LEFT"/>p : int<br ALIGN="LEFT"/>radius : NoneType<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._glm._newton_solver.NewtonCholeskySolver" [color="black", fontcolor="black", label=<{NewtonCholeskySolver|coef : ndarray<br ALIGN="LEFT"/>coef_newton : matrix, ndarray<br ALIGN="LEFT"/>gradient : ndarray<br ALIGN="LEFT"/>gradient_times_newton<br ALIGN="LEFT"/>hessian : ndarray<br ALIGN="LEFT"/>hessian_warning : bool<br ALIGN="LEFT"/>is_multinomial_no_penalty<br ALIGN="LEFT"/>is_multinomial_with_intercept<br ALIGN="LEFT"/>iteration : int<br ALIGN="LEFT"/>use_fallback_lbfgs_solve : bool<br ALIGN="LEFT"/>|finalize(X, y, sample_weight)<br ALIGN="LEFT"/>inner_solve(X, y, sample_weight)<br ALIGN="LEFT"/>setup(X, y, sample_weight)<br ALIGN="LEFT"/>update_gradient_hessian(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._glm._newton_solver.NewtonSolver" [color="black", fontcolor="black", label=<{NewtonSolver|coef : ndarray<br ALIGN="LEFT"/>coef_old : ndarray<br ALIGN="LEFT"/>converged : bool<br ALIGN="LEFT"/>gradient : ndarray<br ALIGN="LEFT"/>gradient_old : ndarray<br ALIGN="LEFT"/>iteration : int<br ALIGN="LEFT"/>l2_reg_strength : float<br ALIGN="LEFT"/>linear_loss<br ALIGN="LEFT"/>loss_value<br ALIGN="LEFT"/>loss_value_old<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_threads : int<br ALIGN="LEFT"/>raw_prediction<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>use_fallback_lbfgs_solve : bool<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|check_convergence(X, y, sample_weight)<br ALIGN="LEFT"/>fallback_lbfgs_solve(X, y, sample_weight)<br ALIGN="LEFT"/><I>finalize</I>(X, y, sample_weight)<br ALIGN="LEFT"/><I>inner_solve</I>(X, y, sample_weight)<br ALIGN="LEFT"/>line_search(X, y, sample_weight)<br ALIGN="LEFT"/>setup(X, y, sample_weight)<br ALIGN="LEFT"/>solve(X, y, sample_weight)<br ALIGN="LEFT"/><I>update_gradient_hessian</I>(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.NoCheckinPredict" [color="black", fontcolor="black", label=<{NoCheckinPredict|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.NoEstimator" [color="black", fontcolor="black", label=<{NoEstimator|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_pipeline.NoFit" [color="black", fontcolor="black", label=<{NoFit|a : NoneType<br ALIGN="LEFT"/>b : NoneType<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.impute.tests.test_base.NoFitIndicatorImputer" [color="black", fontcolor="black", label=<{NoFitIndicatorImputer|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.compose.tests.test_column_transformer.test_metadata_routing_no_fit_transform.NoFitTransform" [color="black", fontcolor="black", label=<{NoFitTransform|<br ALIGN="LEFT"/>|fit(X, y, sample_weight, metadata)<br ALIGN="LEFT"/>transform(X, sample_weight, metadata)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_pipeline.NoInvTransf" [color="black", fontcolor="black", label=<{NoInvTransf|<br ALIGN="LEFT"/>|transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.NoNaNTag" [color="black", fontcolor="black", label=<{NoNaNTag|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.feature_selection.tests.test_from_model.NoNaNTag" [color="black", fontcolor="black", label=<{NoNaNTag|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_base.test_feature_names_in.NoOpTransformer" [color="black", fontcolor="black", label=<{NoOpTransformer|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.test_validate_data_skip_check_array.NoOpTransformer" [color="black", fontcolor="black", label=<{NoOpTransformer|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_base.test_dataframe_protocol.NoOpTransformer" [color="black", fontcolor="black", label=<{NoOpTransformer|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.impute.tests.test_base.NoPrecomputedMaskFit" [color="black", fontcolor="black", label=<{NoPrecomputedMaskFit|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.impute.tests.test_base.NoPrecomputedMaskTransform" [color="black", fontcolor="black", label=<{NoPrecomputedMaskTransform|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.inspection.tests.test_partial_dependence.NoPredictProbaNoDecisionFunction" [color="black", fontcolor="black", label=<{NoPredictProbaNoDecisionFunction|classes_ : list<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_search.test__custom_fit_no_run_search.NoRunSearchSearchCV" [color="black", fontcolor="black", label=<{NoRunSearchSearchCV|<br ALIGN="LEFT"/>|fit(X, y, groups)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.NoSampleWeightPandasSeriesType" [color="black", fontcolor="black", label=<{NoSampleWeightPandasSeriesType|<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._mocking.NoSampleWeightWrapper" [color="black", fontcolor="black", label=<{NoSampleWeightWrapper|est : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.NoSparseClassifier" [color="black", fontcolor="black", label=<{NoSparseClassifier|raise_for_type : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.NoTagsEstimator" [color="black", fontcolor="black", label=<{NoTagsEstimator|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.compose.tests.test_column_transformer.test_column_transformer_invalid_transformer.NoTrans" [color="black", fontcolor="black", label=<{NoTrans|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_pipeline.NoTrans" [color="black", fontcolor="black", label=<{NoTrans|a<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_params(deep)<br ALIGN="LEFT"/>set_params()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.impute.tests.test_base.NoTransformIndicatorImputer" [color="black", fontcolor="black", label=<{NoTransformIndicatorImputer|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble.tests.test_stacking.NoWeightClassifier" [color="black", fontcolor="black", label=<{NoWeightClassifier|clf<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble.tests.test_stacking.NoWeightRegressor" [color="black", fontcolor="black", label=<{NoWeightRegressor|reg<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.externals._arff.NominalConversor" [color="black", fontcolor="black", label=<{NominalConversor|values : set<br ALIGN="LEFT"/>zero_value<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.test_check_no_attributes_set_in_init.NonConformantEstimatorNoParamSet" [color="black", fontcolor="black", label=<{NonConformantEstimatorNoParamSet|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.test_check_no_attributes_set_in_init.NonConformantEstimatorPrivateSet" [color="black", fontcolor="black", label=<{NonConformantEstimatorPrivateSet|you_should_not_set_this_ : NoneType<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.metadata_routing_common.NonConsumingClassifier" [color="black", fontcolor="black", label=<{NonConsumingClassifier|alpha : float<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>coef_ : ndarray<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>partial_fit(X, y, classes)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.metadata_routing_common.NonConsumingRegressor" [color="black", fontcolor="black", label=<{NonConsumingRegressor|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>partial_fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tree.tests.test_tree.test_different_endianness_joblib_pickle.NonNativeEndiannessNumpyPickler" [color="black", fontcolor="black", label=<{NonNativeEndiannessNumpyPickler|<br ALIGN="LEFT"/>|save(obj)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.gaussian_process.kernels.NormalizedKernelMixin" [color="black", fontcolor="black", label=<{NormalizedKernelMixin|<br ALIGN="LEFT"/>|diag(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.preprocessing._data.Normalizer" [color="black", fontcolor="black", label=<{Normalizer|copy : bool<br ALIGN="LEFT"/>norm : str<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X, copy)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_validation.test_is_polars_df_for_duck_typed_polars_dataframe.NotAPolarsDataFrame" [color="black", fontcolor="black", label=<{NotAPolarsDataFrame|columns : list<br ALIGN="LEFT"/>schema : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.test_check_estimator_cloneable_error.NotCloneable" [color="black", fontcolor="black", label=<{NotCloneable|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.exceptions.NotFittedError" [color="black", fontcolor="red", label=<{NotFittedError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.NotInvariantPredict" [color="black", fontcolor="black", label=<{NotInvariantPredict|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.NotInvariantSampleOrder" [color="black", fontcolor="black", label=<{NotInvariantSampleOrder|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.test_estimator_repr_error.NotRepr" [color="black", fontcolor="black", label=<{NotRepr|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.svm._classes.NuSVC" [color="black", fontcolor="black", label=<{NuSVC|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.svm._classes.NuSVR" [color="black", fontcolor="black", label=<{NuSVR|unused_param : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.kernel_approximation.Nystroem" [color="black", fontcolor="black", label=<{Nystroem|coef0 : NoneType<br ALIGN="LEFT"/>component_indices_<br ALIGN="LEFT"/>components_<br ALIGN="LEFT"/>degree : NoneType<br ALIGN="LEFT"/>gamma : NoneType<br ALIGN="LEFT"/>kernel : str<br ALIGN="LEFT"/>kernel_params : NoneType<br ALIGN="LEFT"/>n_components : int<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>normalization_ : ndarray<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.covariance._shrunk_covariance.OAS" [color="black", fontcolor="black", label=<{OAS|location_ : ndarray<br ALIGN="LEFT"/>shrinkage_ : float<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.cluster._optics.OPTICS" [color="black", fontcolor="black", label=<{OPTICS|algorithm : str<br ALIGN="LEFT"/>cluster_hierarchy_ : ndarray<br ALIGN="LEFT"/>cluster_method : str<br ALIGN="LEFT"/>core_distances_<br ALIGN="LEFT"/>eps : NoneType<br ALIGN="LEFT"/>labels_ : ndarray<br ALIGN="LEFT"/>leaf_size : int<br ALIGN="LEFT"/>max_eps<br ALIGN="LEFT"/>memory : NoneType<br ALIGN="LEFT"/>metric : str<br ALIGN="LEFT"/>metric_params : NoneType<br ALIGN="LEFT"/>min_cluster_size : NoneType<br ALIGN="LEFT"/>min_samples : int<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>ordering_<br ALIGN="LEFT"/>p : int<br ALIGN="LEFT"/>predecessor_<br ALIGN="LEFT"/>predecessor_correction : bool<br ALIGN="LEFT"/>reachability_<br ALIGN="LEFT"/>xi : float<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.manifold.tests.test_t_sne.test_gradient_descent_stops.ObjectiveSmallGradient" [color="black", fontcolor="black", label=<{ObjectiveSmallGradient|it : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_metadata_routing.test_default_requests.OddEstimator" [color="black", fontcolor="black", label=<{OddEstimator|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.test_check_estimator_tags_renamed.OkayEstimator" [color="black", fontcolor="black", label=<{OkayEstimator|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_common.test_transition_public_api_deprecations.OldEstimator" [color="black", fontcolor="black", label=<{OldEstimator|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.svm._classes.OneClassSVM" [color="black", fontcolor="black", label=<{OneClassSVM|offset_<br ALIGN="LEFT"/>unused_param : str<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>score_samples(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.OneClassSampleErrorClassifier" [color="black", fontcolor="black", label=<{OneClassSampleErrorClassifier|classes_<br ALIGN="LEFT"/>has_single_class_ : bool<br ALIGN="LEFT"/>raise_when_single_class : bool<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.preprocessing._encoders.OneHotEncoder" [color="black", fontcolor="black", label=<{OneHotEncoder|categories : str<br ALIGN="LEFT"/>drop : NoneType<br ALIGN="LEFT"/>drop_idx_ : NoneType, ndarray<br ALIGN="LEFT"/>dtype : NoneType<br ALIGN="LEFT"/>feature_name_combiner : str<br ALIGN="LEFT"/>handle_unknown : str<br ALIGN="LEFT"/>max_categories : NoneType<br ALIGN="LEFT"/>min_frequency : NoneType<br ALIGN="LEFT"/>sparse_output : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection.tests.common.OneTimeSplitter" [color="black", fontcolor="black", label=<{OneTimeSplitter|indices<br ALIGN="LEFT"/>n_samples : int<br ALIGN="LEFT"/>n_splits : int<br ALIGN="LEFT"/>|get_n_splits(X, y, groups)<br ALIGN="LEFT"/>split(X, y, groups)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.base.OneToOneFeatureMixin" [color="black", fontcolor="black", label=<{OneToOneFeatureMixin|<br ALIGN="LEFT"/>|get_feature_names_out(input_features)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.multiclass.OneVsOneClassifier" [color="black", fontcolor="black", label=<{OneVsOneClassifier|classes_<br ALIGN="LEFT"/>estimator<br ALIGN="LEFT"/>estimators_ : list<br ALIGN="LEFT"/>n_classes_<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>pairwise_indices_ : NoneType<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>partial_fit(X, y, classes)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.multiclass.OneVsRestClassifier" [color="black", fontcolor="black", label=<{OneVsRestClassifier|classes_ : tuple<br ALIGN="LEFT"/>estimator<br ALIGN="LEFT"/>estimators_ : list<br ALIGN="LEFT"/>feature_names_in_<br ALIGN="LEFT"/>label_binarizer_<br ALIGN="LEFT"/>multilabel_<br ALIGN="LEFT"/>n_classes_<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>partial_fit(X, y, classes)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.datasets._openml.OpenMLError" [color="black", fontcolor="red", label=<{OpenMLError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils._param_validation.Options" [color="black", fontcolor="black", label=<{Options|deprecated : set<br ALIGN="LEFT"/>options<br ALIGN="LEFT"/>type<br ALIGN="LEFT"/>|is_satisfied_by(val)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.preprocessing._encoders.OrdinalEncoder" [color="black", fontcolor="black", label=<{OrdinalEncoder|categories : str<br ALIGN="LEFT"/>dtype<br ALIGN="LEFT"/>encoded_missing_value<br ALIGN="LEFT"/>handle_unknown : str<br ALIGN="LEFT"/>max_categories : NoneType<br ALIGN="LEFT"/>min_frequency : NoneType<br ALIGN="LEFT"/>unknown_value : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._omp.OrthogonalMatchingPursuit" [color="black", fontcolor="black", label=<{OrthogonalMatchingPursuit|coef_ : ndarray<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>n_iter_ : list<br ALIGN="LEFT"/>n_nonzero_coefs : NoneType<br ALIGN="LEFT"/>n_nonzero_coefs_ : NoneType<br ALIGN="LEFT"/>precompute : str<br ALIGN="LEFT"/>tol : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._omp.OrthogonalMatchingPursuitCV" [color="black", fontcolor="black", label=<{OrthogonalMatchingPursuitCV|coef_<br ALIGN="LEFT"/>copy : bool<br ALIGN="LEFT"/>cv : NoneType<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_ : float<br ALIGN="LEFT"/>max_iter : NoneType<br ALIGN="LEFT"/>n_iter_ : list<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>n_nonzero_coefs_<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.test_check_outlier_contamination.OutlierDetectorWithConstraint" [color="black", fontcolor="black", label=<{OutlierDetectorWithConstraint|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.test_check_outlier_contamination.OutlierDetectorWithoutConstraint" [color="black", fontcolor="black", label=<{OutlierDetectorWithoutConstraint|contamination : float<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.base.OutlierMixin" [color="black", fontcolor="black", label=<{OutlierMixin|<br ALIGN="LEFT"/>|fit_predict(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.multiclass.OutputCodeClassifier" [color="black", fontcolor="black", label=<{OutputCodeClassifier|classes_<br ALIGN="LEFT"/>code_book_<br ALIGN="LEFT"/>code_size : float<br ALIGN="LEFT"/>estimator<br ALIGN="LEFT"/>estimators_ : list<br ALIGN="LEFT"/>feature_names_in_<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.OverrideTag" [color="black", fontcolor="black", label=<{OverrideTag|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_pprint.PCA" [color="black", fontcolor="black", label=<{PCA|copy : bool<br ALIGN="LEFT"/>iterated_power : str<br ALIGN="LEFT"/>n_components : NoneType<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>svd_solver : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>whiten : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.decomposition._pca.PCA" [color="black", fontcolor="black", label=<{PCA|components_<br ALIGN="LEFT"/>copy : bool<br ALIGN="LEFT"/>explained_variance_<br ALIGN="LEFT"/>explained_variance_ratio_<br ALIGN="LEFT"/>iterated_power : str<br ALIGN="LEFT"/>mean_<br ALIGN="LEFT"/>n_components : NoneType<br ALIGN="LEFT"/>n_components_<br ALIGN="LEFT"/>n_oversamples : int<br ALIGN="LEFT"/>n_samples_<br ALIGN="LEFT"/>noise_variance_ : float<br ALIGN="LEFT"/>power_iteration_normalizer : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>singular_values_<br ALIGN="LEFT"/>svd_solver : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>whiten : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>score(X, y)<br ALIGN="LEFT"/>score_samples(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.cross_decomposition._pls.PLSCanonical" [color="black", fontcolor="black", label=<{PLSCanonical|param : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.cross_decomposition._pls.PLSRegression" [color="black", fontcolor="black", label=<{PLSRegression|param : str<br ALIGN="LEFT"/>x_scores_ : ndarray<br ALIGN="LEFT"/>y_scores_ : ndarray<br ALIGN="LEFT"/>|fit(X, y, Y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.cross_decomposition._pls.PLSSVD" [color="black", fontcolor="black", label=<{PLSSVD|copy : bool<br ALIGN="LEFT"/>n_components : int<br ALIGN="LEFT"/>scale : bool<br ALIGN="LEFT"/>x_weights_<br ALIGN="LEFT"/>y_weights_<br ALIGN="LEFT"/>|fit(X, y, Y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>transform(X, y, Y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.gaussian_process.kernels.PairwiseKernel" [color="black", fontcolor="black", label=<{PairwiseKernel|gamma : float<br ALIGN="LEFT"/>gamma_bounds : tuple<br ALIGN="LEFT"/>hyperparameter_gamma<br ALIGN="LEFT"/>metric : str<br ALIGN="LEFT"/>pairwise_kernels_kwargs : NoneType<br ALIGN="LEFT"/>|diag(X)<br ALIGN="LEFT"/>is_stationary()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._set_output.PandasAdapter" [color="black", fontcolor="black", label=<{PandasAdapter|container_lib : str<br ALIGN="LEFT"/>|create_container(X_output, X_original, columns, inplace)<br ALIGN="LEFT"/>hstack(Xs)<br ALIGN="LEFT"/>is_supported_container(X)<br ALIGN="LEFT"/>rename_columns(X, columns)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.compose.tests.test_column_transformer.PandasOutTransformer" [color="black", fontcolor="black", label=<{PandasOutTransformer|offset : float<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>set_output(transform)<br ALIGN="LEFT"/>transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.parallel.Parallel" [color="black", fontcolor="black", label=<{Parallel|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.model_selection._search.ParameterGrid" [color="black", fontcolor="black", label=<{ParameterGrid|param_grid : list<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.model_selection._search.ParameterSampler" [color="black", fontcolor="black", label=<{ParameterSampler|n_iter<br ALIGN="LEFT"/>param_distributions : list<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.inspection._plot.partial_dependence.PartialDependenceDisplay" [color="black", fontcolor="black", label=<{PartialDependenceDisplay|axes_ : ndarray<br ALIGN="LEFT"/>bars_ : ndarray<br ALIGN="LEFT"/>bounding_ax_ : NoneType<br ALIGN="LEFT"/>contours_ : ndarray<br ALIGN="LEFT"/>deciles<br ALIGN="LEFT"/>deciles_hlines_ : ndarray<br ALIGN="LEFT"/>deciles_vlines_ : ndarray<br ALIGN="LEFT"/>feature_names<br ALIGN="LEFT"/>features<br ALIGN="LEFT"/>figure_<br ALIGN="LEFT"/>heatmaps_ : ndarray<br ALIGN="LEFT"/>is_categorical : NoneType<br ALIGN="LEFT"/>kind : list, str<br ALIGN="LEFT"/>lines_ : ndarray<br ALIGN="LEFT"/>pd_results<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>subsample : int<br ALIGN="LEFT"/>target_idx<br ALIGN="LEFT"/>|from_estimator(estimator, X, features)<br ALIGN="LEFT"/>plot()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.PartialFitChecksName" [color="black", fontcolor="black", label=<{PartialFitChecksName|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>partial_fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._passive_aggressive.PassiveAggressiveClassifier" [color="black", fontcolor="black", label=<{PassiveAggressiveClassifier|C : float<br ALIGN="LEFT"/>loss : str<br ALIGN="LEFT"/>|fit(X, y, coef_init, intercept_init)<br ALIGN="LEFT"/>partial_fit(X, y, classes)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._passive_aggressive.PassiveAggressiveRegressor" [color="black", fontcolor="black", label=<{PassiveAggressiveRegressor|C : float<br ALIGN="LEFT"/>loss : str<br ALIGN="LEFT"/>|fit(X, y, coef_init, intercept_init)<br ALIGN="LEFT"/>partial_fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_validation.PassthroughTransformer" [color="black", fontcolor="black", label=<{PassthroughTransformer|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.feature_extraction.image.PatchExtractor" [color="black", fontcolor="black", label=<{PatchExtractor|max_patches : NoneType<br ALIGN="LEFT"/>patch_size : NoneType<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._perceptron.Perceptron" [color="black", fontcolor="black", label=<{Perceptron|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn._loss.loss.PinballLoss" [color="black", fontcolor="black", label=<{PinballLoss|approx_hessian : bool<br ALIGN="LEFT"/>constant_hessian<br ALIGN="LEFT"/>differentiable : bool<br ALIGN="LEFT"/>need_update_leaves_values : bool<br ALIGN="LEFT"/>|fit_intercept_only(y_true, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.pipeline.Pipeline" [color="black", fontcolor="black", label=<{Pipeline|classes_<br ALIGN="LEFT"/>feature_names_in_<br ALIGN="LEFT"/>memory : NoneType<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>named_steps<br ALIGN="LEFT"/>steps : list<br ALIGN="LEFT"/>transform_input : NoneType<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>fit_predict(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>get_params(deep)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>score(X, y, sample_weight)<br ALIGN="LEFT"/>score_samples(X)<br ALIGN="LEFT"/>set_output()<br ALIGN="LEFT"/>set_params()<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_pprint.Pipeline" [color="black", fontcolor="black", label=<{Pipeline|memory : NoneType<br ALIGN="LEFT"/>steps<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._glm.glm.PoissonRegressor" [color="black", fontcolor="black", label=<{PoissonRegressor|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils._set_output.PolarsAdapter" [color="black", fontcolor="black", label=<{PolarsAdapter|container_lib : str<br ALIGN="LEFT"/>|create_container(X_output, X_original, columns, inplace)<br ALIGN="LEFT"/>hstack(Xs)<br ALIGN="LEFT"/>is_supported_container(X)<br ALIGN="LEFT"/>rename_columns(X, columns)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.kernel_approximation.PolynomialCountSketch" [color="black", fontcolor="black", label=<{PolynomialCountSketch|bitHash_<br ALIGN="LEFT"/>coef0 : int<br ALIGN="LEFT"/>degree : int<br ALIGN="LEFT"/>gamma : float<br ALIGN="LEFT"/>indexHash_<br ALIGN="LEFT"/>n_components : int<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.preprocessing._polynomial.PolynomialFeatures" [color="black", fontcolor="black", label=<{PolynomialFeatures|degree : int<br ALIGN="LEFT"/>include_bias : bool<br ALIGN="LEFT"/>interaction_only : bool<br ALIGN="LEFT"/>n_output_features_<br ALIGN="LEFT"/>order : str<br ALIGN="LEFT"/>powers_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.PoorScoreLogisticRegression" [color="black", fontcolor="black", label=<{PoorScoreLogisticRegression|<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.exceptions.PositiveSpectrumWarning" [color="black", fontcolor="red", label=<{PositiveSpectrumWarning|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.preprocessing._data.PowerTransformer" [color="black", fontcolor="black", label=<{PowerTransformer|copy : bool<br ALIGN="LEFT"/>lambdas_ : list, ndarray<br ALIGN="LEFT"/>method : str<br ALIGN="LEFT"/>standardize : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.metrics._plot.precision_recall_curve.PrecisionRecallDisplay" [color="black", fontcolor="black", label=<{PrecisionRecallDisplay|average_precision : NoneType<br ALIGN="LEFT"/>ax_ : NoneType<br ALIGN="LEFT"/>chance_level_ : NoneType<br ALIGN="LEFT"/>estimator_name : NoneType<br ALIGN="LEFT"/>figure_<br ALIGN="LEFT"/>line_<br ALIGN="LEFT"/>pos_label : NoneType<br ALIGN="LEFT"/>precision<br ALIGN="LEFT"/>prevalence_pos_label : NoneType<br ALIGN="LEFT"/>recall<br ALIGN="LEFT"/>|from_estimator(estimator, X, y)<br ALIGN="LEFT"/>from_predictions(y_true, y_pred)<br ALIGN="LEFT"/>plot(ax)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._split.PredefinedSplit" [color="black", fontcolor="black", label=<{PredefinedSplit|test_fold : ndarray<br ALIGN="LEFT"/>unique_folds<br ALIGN="LEFT"/>|get_n_splits(X, y, groups)<br ALIGN="LEFT"/>split(X, y, groups)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.metrics._plot.regression.PredictionErrorDisplay" [color="black", fontcolor="black", label=<{PredictionErrorDisplay|ax_ : NoneType<br ALIGN="LEFT"/>figure_<br ALIGN="LEFT"/>line_<br ALIGN="LEFT"/>scatter_<br ALIGN="LEFT"/>y_pred<br ALIGN="LEFT"/>y_true<br ALIGN="LEFT"/>|from_estimator(estimator, X, y)<br ALIGN="LEFT"/>from_predictions(y_true, y_pred)<br ALIGN="LEFT"/>plot(ax)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.PredictorNewTags" [color="black", fontcolor="black", label=<{PredictorNewTags|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.PredictorOldNewTags" [color="black", fontcolor="black", label=<{PredictorOldNewTags|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_tags.PredictorOldTags" [color="black", fontcolor="black", label=<{PredictorOldTags|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.gaussian_process.kernels.Product" [color="black", fontcolor="black", label=<{Product|theta : NoneType<br ALIGN="LEFT"/>|diag(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.discriminant_analysis.QuadraticDiscriminantAnalysis" [color="black", fontcolor="black", label=<{QuadraticDiscriminantAnalysis|classes_<br ALIGN="LEFT"/>covariance_ : NoneType, list<br ALIGN="LEFT"/>means_<br ALIGN="LEFT"/>priors : NoneType<br ALIGN="LEFT"/>priors_ : ndarray<br ALIGN="LEFT"/>reg_param : float<br ALIGN="LEFT"/>rotations_ : list<br ALIGN="LEFT"/>scalings_ : list<br ALIGN="LEFT"/>store_covariance : bool<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._quantile.QuantileRegressor" [color="black", fontcolor="black", label=<{QuantileRegressor|alpha : float<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_ : float<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>quantile : float<br ALIGN="LEFT"/>solver : str<br ALIGN="LEFT"/>solver_options : NoneType<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.preprocessing._data.QuantileTransformer" [color="black", fontcolor="black", label=<{QuantileTransformer|copy : bool<br ALIGN="LEFT"/>ignore_implicit_zeros : bool<br ALIGN="LEFT"/>n_quantiles : int<br ALIGN="LEFT"/>n_quantiles_<br ALIGN="LEFT"/>output_distribution : str<br ALIGN="LEFT"/>quantiles_ : list, ndarray<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>references_ : ndarray<br ALIGN="LEFT"/>subsample : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._ransac.RANSACRegressor" [color="black", fontcolor="black", label=<{RANSACRegressor|estimator : NoneType<br ALIGN="LEFT"/>estimator_<br ALIGN="LEFT"/>inlier_mask_ : NoneType<br ALIGN="LEFT"/>is_data_valid : NoneType<br ALIGN="LEFT"/>is_model_valid : NoneType<br ALIGN="LEFT"/>loss : str<br ALIGN="LEFT"/>max_skips<br ALIGN="LEFT"/>max_trials : int<br ALIGN="LEFT"/>min_samples : NoneType<br ALIGN="LEFT"/>n_skips_invalid_data_ : int<br ALIGN="LEFT"/>n_skips_invalid_model_ : int<br ALIGN="LEFT"/>n_skips_no_inliers_ : int<br ALIGN="LEFT"/>n_trials_ : int<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>residual_threshold : NoneType<br ALIGN="LEFT"/>stop_n_inliers<br ALIGN="LEFT"/>stop_probability : float<br ALIGN="LEFT"/>stop_score<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>score(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.gaussian_process.kernels.RBF" [color="black", fontcolor="black", label=<{RBF|anisotropic<br ALIGN="LEFT"/>hyperparameter_length_scale<br ALIGN="LEFT"/>length_scale : float<br ALIGN="LEFT"/>length_scale_bounds : tuple<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.kernel_approximation.RBFSampler" [color="black", fontcolor="black", label=<{RBFSampler|gamma : float<br ALIGN="LEFT"/>n_components : int<br ALIGN="LEFT"/>random_offset_<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>random_weights_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_pprint.RFE" [color="black", fontcolor="black", label=<{RFE|estimator<br ALIGN="LEFT"/>n_features_to_select : NoneType<br ALIGN="LEFT"/>step : int<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.feature_selection._rfe.RFE" [color="black", fontcolor="black", label=<{RFE|classes_<br ALIGN="LEFT"/>estimator<br ALIGN="LEFT"/>estimator_<br ALIGN="LEFT"/>importance_getter : str<br ALIGN="LEFT"/>n_features_ : ndarray<br ALIGN="LEFT"/>n_features_to_select : NoneType<br ALIGN="LEFT"/>ranking_ : ndarray<br ALIGN="LEFT"/>step : int<br ALIGN="LEFT"/>step_n_features_ : list<br ALIGN="LEFT"/>step_scores_ : list<br ALIGN="LEFT"/>support_ : ndarray<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>score(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.feature_selection._rfe.RFECV" [color="black", fontcolor="black", label=<{RFECV|cv : NoneType<br ALIGN="LEFT"/>cv_results_<br ALIGN="LEFT"/>estimator<br ALIGN="LEFT"/>estimator_<br ALIGN="LEFT"/>importance_getter : str<br ALIGN="LEFT"/>min_features_to_select : int<br ALIGN="LEFT"/>n_features_ : ndarray<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>ranking_ : ndarray<br ALIGN="LEFT"/>scoring : NoneType<br ALIGN="LEFT"/>step : int<br ALIGN="LEFT"/>support_ : ndarray<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>score(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_validation.RFWithDecisionFunction" [color="black", fontcolor="black", label=<{RFWithDecisionFunction|<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.metrics._pairwise_distances_reduction._dispatcher.RadiusNeighbors" [color="black", fontcolor="black", label=<{RadiusNeighbors|<br ALIGN="LEFT"/>|compute(X, Y, radius, metric, chunk_size, metric_kwargs, strategy, return_distance, sort_results)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.metrics._pairwise_distances_reduction._dispatcher.RadiusNeighborsClassMode" [color="black", fontcolor="black", label=<{RadiusNeighborsClassMode|<br ALIGN="LEFT"/>|compute(X, Y, radius, weights, Y_labels, unique_Y_labels, outlier_label, metric, chunk_size, metric_kwargs, strategy)<br ALIGN="LEFT"/>valid_metrics(): List[str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.neighbors._classification.RadiusNeighborsClassifier" [color="black", fontcolor="black", label=<{RadiusNeighborsClassifier|outlier_label : NoneType<br ALIGN="LEFT"/>outlier_label_ : NoneType, list<br ALIGN="LEFT"/>weights : str<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>score(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.neighbors._base.RadiusNeighborsMixin" [color="black", fontcolor="black", label=<{RadiusNeighborsMixin|<br ALIGN="LEFT"/>|radius_neighbors(X, radius, return_distance, sort_results)<br ALIGN="LEFT"/>radius_neighbors_graph(X, radius, mode, sort_results)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.neighbors._regression.RadiusNeighborsRegressor" [color="black", fontcolor="black", label=<{RadiusNeighborsRegressor|weights : str<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.neighbors._graph.RadiusNeighborsTransformer" [color="black", fontcolor="black", label=<{RadiusNeighborsTransformer|mode : str<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.RaisesErrorInSetParams" [color="black", fontcolor="black", label=<{RaisesErrorInSetParams|p : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>set_params()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.mixture.tests.test_gaussian_mixture.RandomData" [color="black", fontcolor="black", label=<{RandomData|X : dict<br ALIGN="LEFT"/>Y : list, tuple<br ALIGN="LEFT"/>covariances : dict<br ALIGN="LEFT"/>means<br ALIGN="LEFT"/>n_components : int<br ALIGN="LEFT"/>n_features : int<br ALIGN="LEFT"/>n_samples : int<br ALIGN="LEFT"/>precisions : dict<br ALIGN="LEFT"/>weights<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.ensemble._forest.RandomForestClassifier" [color="black", fontcolor="black", label=<{RandomForestClassifier|ccp_alpha : float<br ALIGN="LEFT"/>criterion : str<br ALIGN="LEFT"/>max_depth : NoneType<br ALIGN="LEFT"/>max_features : str<br ALIGN="LEFT"/>max_leaf_nodes : NoneType<br ALIGN="LEFT"/>min_impurity_decrease : float<br ALIGN="LEFT"/>min_samples_leaf : int<br ALIGN="LEFT"/>min_samples_split : int<br ALIGN="LEFT"/>min_weight_fraction_leaf : float<br ALIGN="LEFT"/>monotonic_cst : NoneType<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.ensemble._forest.RandomForestRegressor" [color="black", fontcolor="black", label=<{RandomForestRegressor|ccp_alpha : float<br ALIGN="LEFT"/>criterion : str<br ALIGN="LEFT"/>max_depth : NoneType<br ALIGN="LEFT"/>max_features : float<br ALIGN="LEFT"/>max_leaf_nodes : NoneType<br ALIGN="LEFT"/>min_impurity_decrease : float<br ALIGN="LEFT"/>min_samples_leaf : int<br ALIGN="LEFT"/>min_samples_split : int<br ALIGN="LEFT"/>min_weight_fraction_leaf : float<br ALIGN="LEFT"/>monotonic_cst : NoneType<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.ensemble._forest.RandomTreesEmbedding" [color="black", fontcolor="black", label=<{RandomTreesEmbedding|criterion : str<br ALIGN="LEFT"/>max_depth : int<br ALIGN="LEFT"/>max_features : int<br ALIGN="LEFT"/>max_leaf_nodes : NoneType<br ALIGN="LEFT"/>min_impurity_decrease : float<br ALIGN="LEFT"/>min_samples_leaf : int<br ALIGN="LEFT"/>min_samples_split : int<br ALIGN="LEFT"/>min_weight_fraction_leaf : float<br ALIGN="LEFT"/>one_hot_encoder_<br ALIGN="LEFT"/>param : str<br ALIGN="LEFT"/>sparse_output : bool<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>fit_transform(X, y, sample_weight)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._search.RandomizedSearchCV" [color="black", fontcolor="black", label=<{RandomizedSearchCV|n_iter : int<br ALIGN="LEFT"/>param_distributions<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.gaussian_process.kernels.RationalQuadratic" [color="black", fontcolor="black", label=<{RationalQuadratic|alpha : float<br ALIGN="LEFT"/>alpha_bounds : tuple<br ALIGN="LEFT"/>hyperparameter_alpha<br ALIGN="LEFT"/>hyperparameter_length_scale<br ALIGN="LEFT"/>length_scale : float<br ALIGN="LEFT"/>length_scale_bounds : tuple<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils._param_validation.RealNotInt" [color="black", fontcolor="black", label=<{RealNotInt|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_testing.RegistrationCounter" [color="black", fontcolor="black", label=<{RegistrationCounter|nb_calls : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.multioutput.RegressorChain" [color="black", fontcolor="black", label=<{RegressorChain|<br ALIGN="LEFT"/>|fit(X, Y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.base.RegressorMixin" [color="black", fontcolor="black", label=<{RegressorMixin|<br ALIGN="LEFT"/>|score(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._tags.RegressorTags" [color="black", fontcolor="black", label=<{RegressorTags|poor_score : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.model_selection._split.RepeatedKFold" [color="black", fontcolor="black", label=<{RepeatedKFold|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.model_selection._split.RepeatedStratifiedKFold" [color="black", fontcolor="black", label=<{RepeatedStratifiedKFold|<br ALIGN="LEFT"/>|split(X, y, groups)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._metadata_requests.RequestMethod" [color="black", fontcolor="black", label=<{RequestMethod|keys<br ALIGN="LEFT"/>name<br ALIGN="LEFT"/>validate_keys : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.test_check_positive_only_tag_during_fit.RequiresPositiveXBadTag" [color="black", fontcolor="black", label=<{RequiresPositiveXBadTag|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.RequiresPositiveXRegressor" [color="black", fontcolor="black", label=<{RequiresPositiveXRegressor|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.RequiresPositiveYRegressor" [color="black", fontcolor="black", label=<{RequiresPositiveYRegressor|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble.tests.test_base.test_set_random_states.RevParamPipeline" [color="black", fontcolor="black", label=<{RevParamPipeline|<br ALIGN="LEFT"/>|get_params()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._ridge.Ridge" [color="black", fontcolor="black", label=<{Ridge|<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._ridge.RidgeCV" [color="black", fontcolor="black", label=<{RidgeCV|<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._ridge.RidgeClassifier" [color="black", fontcolor="black", label=<{RidgeClassifier|class_weight : NoneType<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._ridge.RidgeClassifierCV" [color="black", fontcolor="black", label=<{RidgeClassifierCV|class_weight : NoneType<br ALIGN="LEFT"/>param : str<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.preprocessing._data.RobustScaler" [color="black", fontcolor="black", label=<{RobustScaler|center_ : NoneType, ndarray<br ALIGN="LEFT"/>copy : bool<br ALIGN="LEFT"/>quantile_range : tuple<br ALIGN="LEFT"/>scale_ : NoneType<br ALIGN="LEFT"/>unit_variance : bool<br ALIGN="LEFT"/>with_centering : bool<br ALIGN="LEFT"/>with_scaling : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.metrics._plot.roc_curve.RocCurveDisplay" [color="black", fontcolor="black", label=<{RocCurveDisplay|ax_ : NoneType<br ALIGN="LEFT"/>chance_level_ : NoneType<br ALIGN="LEFT"/>estimator_name : NoneType<br ALIGN="LEFT"/>figure_<br ALIGN="LEFT"/>fpr<br ALIGN="LEFT"/>line_<br ALIGN="LEFT"/>pos_label : NoneType<br ALIGN="LEFT"/>roc_auc : NoneType<br ALIGN="LEFT"/>tpr<br ALIGN="LEFT"/>|from_estimator(estimator, X, y)<br ALIGN="LEFT"/>from_predictions(y_true, y_pred)<br ALIGN="LEFT"/>plot(ax)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._stochastic_gradient.SGDClassifier" [color="black", fontcolor="black", label=<{SGDClassifier|<br ALIGN="LEFT"/>|predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._stochastic_gradient.SGDOneClassSVM" [color="black", fontcolor="black", label=<{SGDOneClassSVM|coef_ : NoneType, ndarray<br ALIGN="LEFT"/>loss_functions : dict<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>nu : float<br ALIGN="LEFT"/>offset_ : NoneType<br ALIGN="LEFT"/>t_ : float<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y, coef_init, offset_init, sample_weight)<br ALIGN="LEFT"/>partial_fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>score_samples(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.neural_network._stochastic_optimizers.SGDOptimizer" [color="black", fontcolor="black", label=<{SGDOptimizer|learning_rate<br ALIGN="LEFT"/>lr_schedule : str<br ALIGN="LEFT"/>momentum : float<br ALIGN="LEFT"/>nesterov : bool<br ALIGN="LEFT"/>power_t : float<br ALIGN="LEFT"/>velocities<br ALIGN="LEFT"/>|iteration_ends(time_step)<br ALIGN="LEFT"/>trigger_stopping(msg, verbose)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._stochastic_gradient.SGDRegressor" [color="black", fontcolor="black", label=<{SGDRegressor|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_pprint.SVC" [color="black", fontcolor="black", label=<{SVC|C : float<br ALIGN="LEFT"/>cache_size : int<br ALIGN="LEFT"/>class_weight : NoneType<br ALIGN="LEFT"/>coef0 : float<br ALIGN="LEFT"/>decision_function_shape : str<br ALIGN="LEFT"/>degree : int<br ALIGN="LEFT"/>gamma : str<br ALIGN="LEFT"/>kernel : str<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>probability : bool<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>shrinking : bool<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.svm._classes.SVC" [color="black", fontcolor="black", label=<{SVC|probability : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.svm._classes.SVR" [color="black", fontcolor="black", label=<{SVR|unused_param : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.feature_selection._univariate_selection.SelectFdr" [color="black", fontcolor="black", label=<{SelectFdr|alpha : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.feature_selection._univariate_selection.SelectFpr" [color="black", fontcolor="black", label=<{SelectFpr|alpha : float<br ALIGN="LEFT"/>own_attribute : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.feature_selection._from_model.SelectFromModel" [color="black", fontcolor="black", label=<{SelectFromModel|estimator<br ALIGN="LEFT"/>estimator_<br ALIGN="LEFT"/>feature_names_in_<br ALIGN="LEFT"/>importance_getter : str<br ALIGN="LEFT"/>max_features : NoneType<br ALIGN="LEFT"/>max_features_<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>norm_order : int<br ALIGN="LEFT"/>prefit : bool<br ALIGN="LEFT"/>threshold : NoneType, str<br ALIGN="LEFT"/>threshold_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>partial_fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.feature_selection._univariate_selection.SelectFwe" [color="black", fontcolor="black", label=<{SelectFwe|alpha : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.feature_selection._univariate_selection.SelectKBest" [color="black", fontcolor="black", label=<{SelectKBest|k : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.feature_selection._univariate_selection.SelectPercentile" [color="black", fontcolor="black", label=<{SelectPercentile|percentile : int<br ALIGN="LEFT"/>pvalues_ : NoneType<br ALIGN="LEFT"/>scores_<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.feature_selection._base.SelectorMixin" [color="black", fontcolor="black", label=<{SelectorMixin|<br ALIGN="LEFT"/>|get_feature_names_out(input_features)<br ALIGN="LEFT"/>get_support(indices)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.semi_supervised._self_training.SelfTrainingClassifier" [color="black", fontcolor="black", label=<{SelfTrainingClassifier|base_estimator : str<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>criterion : str<br ALIGN="LEFT"/>estimator : NoneType<br ALIGN="LEFT"/>estimator_<br ALIGN="LEFT"/>fitted_params_ : bool<br ALIGN="LEFT"/>k_best : int<br ALIGN="LEFT"/>labeled_iter_ : ndarray<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_iter_ : int<br ALIGN="LEFT"/>termination_condition_ : str<br ALIGN="LEFT"/>threshold : float<br ALIGN="LEFT"/>transduction_<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>score(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tree._export.Sentinel" [color="black", fontcolor="black", label=<{Sentinel|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.feature_selection._sequential.SequentialFeatureSelector" [color="black", fontcolor="black", label=<{SequentialFeatureSelector|cv : int<br ALIGN="LEFT"/>direction : str<br ALIGN="LEFT"/>estimator<br ALIGN="LEFT"/>n_features_to_select : str<br ALIGN="LEFT"/>n_features_to_select_ : int, ndarray, str<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>scoring : NoneType<br ALIGN="LEFT"/>support_ : ndarray<br ALIGN="LEFT"/>tol : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.SetsWrongAttribute" [color="black", fontcolor="black", label=<{SetsWrongAttribute|acceptable_key : int<br ALIGN="LEFT"/>wrong_attribute : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.covariance._shrunk_covariance.ShrunkCovariance" [color="black", fontcolor="black", label=<{ShrunkCovariance|location_ : ndarray<br ALIGN="LEFT"/>shrinkage : float<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._split.ShuffleSplit" [color="black", fontcolor="black", label=<{ShuffleSplit|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_metadata_routing.test_method_generation.SimpleEstimator" [color="black", fontcolor="black", label=<{SimpleEstimator|<br ALIGN="LEFT"/>|<I>decision_function</I>(X)<br ALIGN="LEFT"/><I>fit</I>(X, y)<br ALIGN="LEFT"/><I>fit_predict</I>(X, y)<br ALIGN="LEFT"/><I>fit_transform</I>(X, y)<br ALIGN="LEFT"/><I>inverse_transform</I>(X)<br ALIGN="LEFT"/><I>partial_fit</I>(X, y)<br ALIGN="LEFT"/><I>predict</I>(X)<br ALIGN="LEFT"/><I>predict_log_proba</I>(X)<br ALIGN="LEFT"/><I>predict_proba</I>(X)<br ALIGN="LEFT"/><I>score</I>(X, y)<br ALIGN="LEFT"/><I>split</I>(X, y)<br ALIGN="LEFT"/><I>transform</I>(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_metadata_routing.test_composite_methods.SimpleEstimator" [color="black", fontcolor="black", label=<{SimpleEstimator|<br ALIGN="LEFT"/>|<I>fit</I>(X, y, foo, bar)<br ALIGN="LEFT"/><I>predict</I>(X, foo, bar)<br ALIGN="LEFT"/><I>transform</I>(X, other_param)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_pipeline.SimpleEstimator" [color="black", fontcolor="black", label=<{SimpleEstimator|<br ALIGN="LEFT"/>|decision_function(X, sample_weight, prop)<br ALIGN="LEFT"/>fit(X, y, sample_weight, prop)<br ALIGN="LEFT"/>fit_predict(X, y, sample_weight, prop)<br ALIGN="LEFT"/>fit_transform(X, y, sample_weight, prop)<br ALIGN="LEFT"/>inverse_transform(X, sample_weight, prop)<br ALIGN="LEFT"/>predict(X, sample_weight, prop)<br ALIGN="LEFT"/>predict_log_proba(X, sample_weight, prop)<br ALIGN="LEFT"/>predict_proba(X, sample_weight, prop)<br ALIGN="LEFT"/>score(X, y, sample_weight, prop)<br ALIGN="LEFT"/>transform(X, sample_weight, prop)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_array_api.SimpleEstimator" [color="black", fontcolor="black", label=<{SimpleEstimator|X_<br ALIGN="LEFT"/>n_features_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.impute._base.SimpleImputer" [color="black", fontcolor="black", label=<{SimpleImputer|copy : bool<br ALIGN="LEFT"/>fill_value : NoneType<br ALIGN="LEFT"/>statistics_ : ndarray<br ALIGN="LEFT"/>strategy : str<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_pprint.SimpleImputer" [color="black", fontcolor="black", label=<{SimpleImputer|copy : bool<br ALIGN="LEFT"/>fill_value : NoneType<br ALIGN="LEFT"/>missing_values<br ALIGN="LEFT"/>strategy : str<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_metadata_routing.SimplePipeline" [color="black", fontcolor="black", label=<{SimplePipeline|steps<br ALIGN="LEFT"/>steps_ : list<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.SingleInheritanceEstimator" [color="black", fontcolor="black", label=<{SingleInheritanceEstimator|attribute_pickled : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.kernel_approximation.SkewedChi2Sampler" [color="black", fontcolor="black", label=<{SkewedChi2Sampler|n_components : int<br ALIGN="LEFT"/>random_offset_<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>random_weights_<br ALIGN="LEFT"/>skewedness : float<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.exceptions.SkipTestWarning" [color="black", fontcolor="red", label=<{SkipTestWarning|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_param_validation.test_no_validation.SomeType" [color="black", fontcolor="black", label=<{SomeType|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_successive_halving.SometimesFailClassifier" [color="black", fontcolor="black", label=<{SometimesFailClassifier|a : int<br ALIGN="LEFT"/>fail_fit : bool<br ALIGN="LEFT"/>fail_predict : bool<br ALIGN="LEFT"/>n_estimators : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.decomposition._dict_learning.SparseCoder" [color="black", fontcolor="black", label=<{SparseCoder|dictionary<br ALIGN="LEFT"/>n_components_<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._base.SparseCoefMixin" [color="black", fontcolor="black", label=<{SparseCoefMixin|coef_ : csr_matrix, ndarray<br ALIGN="LEFT"/>|densify()<br ALIGN="LEFT"/>sparsify()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.compose.tests.test_column_transformer.SparseMatrixTrans" [color="black", fontcolor="black", label=<{SparseMatrixTrans|csr_container<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.decomposition._sparse_pca.SparsePCA" [color="black", fontcolor="black", label=<{SparsePCA|U_init : NoneType<br ALIGN="LEFT"/>V_init : NoneType<br ALIGN="LEFT"/>components_<br ALIGN="LEFT"/>error_ : list<br ALIGN="LEFT"/>n_components_<br ALIGN="LEFT"/>n_iter_ : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.random_projection.SparseRandomProjection" [color="black", fontcolor="black", label=<{SparseRandomProjection|dense_output : bool<br ALIGN="LEFT"/>density : str<br ALIGN="LEFT"/>density_ : str<br ALIGN="LEFT"/>|transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.SparseTransformer" [color="black", fontcolor="black", label=<{SparseTransformer|sparse_container : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.cluster._bicluster.SpectralBiclustering" [color="black", fontcolor="black", label=<{SpectralBiclustering|column_labels_<br ALIGN="LEFT"/>columns_ : list, tuple<br ALIGN="LEFT"/>method : str<br ALIGN="LEFT"/>n_best : int<br ALIGN="LEFT"/>n_components : int<br ALIGN="LEFT"/>row_labels_<br ALIGN="LEFT"/>rows_ : list, tuple<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.cluster._spectral.SpectralClustering" [color="black", fontcolor="black", label=<{SpectralClustering|affinity : str<br ALIGN="LEFT"/>affinity_matrix_ : str, tuple<br ALIGN="LEFT"/>assign_labels : str<br ALIGN="LEFT"/>coef0 : int<br ALIGN="LEFT"/>degree : int<br ALIGN="LEFT"/>eigen_solver : NoneType<br ALIGN="LEFT"/>eigen_tol : str<br ALIGN="LEFT"/>gamma : float<br ALIGN="LEFT"/>kernel_params : NoneType<br ALIGN="LEFT"/>labels_ : NoneType, ndarray<br ALIGN="LEFT"/>n_clusters : int<br ALIGN="LEFT"/>n_components : NoneType<br ALIGN="LEFT"/>n_init : int<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>n_neighbors : int<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_predict(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.cluster._bicluster.SpectralCoclustering" [color="black", fontcolor="black", label=<{SpectralCoclustering|column_labels_<br ALIGN="LEFT"/>columns_ : list, tuple<br ALIGN="LEFT"/>row_labels_<br ALIGN="LEFT"/>rows_ : list, tuple<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.manifold._spectral_embedding.SpectralEmbedding" [color="black", fontcolor="black", label=<{SpectralEmbedding|affinity : str<br ALIGN="LEFT"/>affinity_matrix_<br ALIGN="LEFT"/>eigen_solver : NoneType<br ALIGN="LEFT"/>eigen_tol : str<br ALIGN="LEFT"/>embedding_<br ALIGN="LEFT"/>gamma : NoneType<br ALIGN="LEFT"/>gamma_ : NoneType<br ALIGN="LEFT"/>n_components : int<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>n_neighbors : NoneType<br ALIGN="LEFT"/>n_neighbors_ : NoneType<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.preprocessing._polynomial.SplineTransformer" [color="black", fontcolor="black", label=<{SplineTransformer|bsplines_<br ALIGN="LEFT"/>degree : int<br ALIGN="LEFT"/>extrapolation : str<br ALIGN="LEFT"/>include_bias : bool<br ALIGN="LEFT"/>knots : str<br ALIGN="LEFT"/>n_features_out_<br ALIGN="LEFT"/>n_knots : int<br ALIGN="LEFT"/>order : str<br ALIGN="LEFT"/>sparse_output : bool<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble._stacking.StackingClassifier" [color="black", fontcolor="black", label=<{StackingClassifier|classes_<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble._stacking.StackingRegressor" [color="black", fontcolor="black", label=<{StackingRegressor|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_pprint.StandardScaler" [color="black", fontcolor="black", label=<{StandardScaler|copy : bool<br ALIGN="LEFT"/>with_mean : bool<br ALIGN="LEFT"/>with_std : bool<br ALIGN="LEFT"/>|transform(X, copy)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.preprocessing._data.StandardScaler" [color="black", fontcolor="black", label=<{StandardScaler|copy : bool<br ALIGN="LEFT"/>mean_ : NoneType, float<br ALIGN="LEFT"/>n_samples_seen_ : ndarray<br ALIGN="LEFT"/>scale_ : NoneType, float, ndarray<br ALIGN="LEFT"/>var_ : NoneType, float<br ALIGN="LEFT"/>with_mean : bool<br ALIGN="LEFT"/>with_std : bool<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>inverse_transform(X, copy)<br ALIGN="LEFT"/>partial_fit(X, y, sample_weight)<br ALIGN="LEFT"/>transform(X, copy)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_discriminant_analysis.test_lda_ledoitwolf.StandardizedLedoitWolf" [color="black", fontcolor="black", label=<{StandardizedLedoitWolf|covariance_<br ALIGN="LEFT"/>|fit(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_pipeline.test_pipeline_warns_not_fitted.StatelessEstimator" [color="black", fontcolor="black", label=<{StatelessEstimator|<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>score(X, y)<br ALIGN="LEFT"/>score_samples(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_validation.test_check_is_fitted_stateless.StatelessEstimator" [color="black", fontcolor="black", label=<{StatelessEstimator|<br ALIGN="LEFT"/>|fit()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.gaussian_process.kernels.StationaryKernelMixin" [color="black", fontcolor="black", label=<{StationaryKernelMixin|<br ALIGN="LEFT"/>|is_stationary()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.feature_selection.tests.test_base.StepSelector" [color="black", fontcolor="black", label=<{StepSelector|step : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._param_validation.StrOptions" [color="black", fontcolor="black", label=<{StrOptions|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.model_selection._split.StratifiedGroupKFold" [color="black", fontcolor="black", label=<{StratifiedGroupKFold|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.model_selection._split.StratifiedKFold" [color="black", fontcolor="black", label=<{StratifiedKFold|random_state<br ALIGN="LEFT"/>|split(X, y, groups)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._split.StratifiedShuffleSplit" [color="black", fontcolor="black", label=<{StratifiedShuffleSplit|<br ALIGN="LEFT"/>|split(X, y, groups)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_metaestimators.test_metaestimator_delegation.SubEstimator" [color="black", fontcolor="black", label=<{SubEstimator|classes_ : list<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>decision_function<br ALIGN="LEFT"/>hidden_method : NoneType<br ALIGN="LEFT"/>inverse_transform<br ALIGN="LEFT"/>param : int<br ALIGN="LEFT"/>predict<br ALIGN="LEFT"/>predict_log_proba<br ALIGN="LEFT"/>predict_proba<br ALIGN="LEFT"/>score<br ALIGN="LEFT"/>transform<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.metrics._plot.tests.test_common_curve_display.test_classifier_display_curve_named_constructor_return_type.SubclassOfDisplay" [color="black", fontcolor="black", label=<{SubclassOfDisplay|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.inspection._plot.tests.test_plot_partial_dependence.test_subclass_named_constructors_return_type_is_subclass.SubclassOfDisplay" [color="black", fontcolor="black", label=<{SubclassOfDisplay|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.inspection._plot.tests.test_boundary_decision_display.test_subclass_named_constructors_return_type_is_subclass.SubclassOfDisplay" [color="black", fontcolor="black", label=<{SubclassOfDisplay|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_plot.test_subclassing_displays.SubclassOfDisplay" [color="black", fontcolor="black", label=<{SubclassOfDisplay|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.gaussian_process.kernels.Sum" [color="black", fontcolor="black", label=<{Sum|<br ALIGN="LEFT"/>|diag(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.T" [color="black", fontcolor="black", label=<{T|a : NoneType<br ALIGN="LEFT"/>b : NoneType<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.manifold._t_sne.TSNE" [color="black", fontcolor="black", label=<{TSNE|angle : float<br ALIGN="LEFT"/>early_exaggeration : float<br ALIGN="LEFT"/>embedding_<br ALIGN="LEFT"/>init : str<br ALIGN="LEFT"/>kl_divergence_<br ALIGN="LEFT"/>learning_rate : str<br ALIGN="LEFT"/>learning_rate_ : str<br ALIGN="LEFT"/>max_iter : NoneType<br ALIGN="LEFT"/>method : str<br ALIGN="LEFT"/>metric : str<br ALIGN="LEFT"/>metric_params : NoneType<br ALIGN="LEFT"/>min_grad_norm : float<br ALIGN="LEFT"/>n_components : int<br ALIGN="LEFT"/>n_iter : str<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>n_iter_without_progress : int<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>perplexity : float<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.TaggedBinaryClassifier" [color="black", fontcolor="black", label=<{TaggedBinaryClassifier|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._tags.Tags" [color="black", fontcolor="black", label=<{Tags|array_api_support : bool<br ALIGN="LEFT"/>classifier_tags : ClassifierTags \| None<br ALIGN="LEFT"/>estimator_type : str \| None<br ALIGN="LEFT"/>input_tags<br ALIGN="LEFT"/>no_validation : bool<br ALIGN="LEFT"/>non_deterministic : bool<br ALIGN="LEFT"/>regressor_tags : RegressorTags \| None<br ALIGN="LEFT"/>requires_fit : bool<br ALIGN="LEFT"/>target_tags<br ALIGN="LEFT"/>transformer_tags : TransformerTags \| None<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.preprocessing._target_encoder.TargetEncoder" [color="black", fontcolor="black", label=<{TargetEncoder|categories : str<br ALIGN="LEFT"/>classes_ : NoneType<br ALIGN="LEFT"/>cv : int<br ALIGN="LEFT"/>encodings_<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>shuffle : bool<br ALIGN="LEFT"/>smooth : str<br ALIGN="LEFT"/>target_mean_<br ALIGN="LEFT"/>target_type : str<br ALIGN="LEFT"/>target_type_ : str<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._tags.TargetTags" [color="black", fontcolor="black", label=<{TargetTags|multi_output : bool<br ALIGN="LEFT"/>one_d_labels : bool<br ALIGN="LEFT"/>positive_only : bool<br ALIGN="LEFT"/>required : bool<br ALIGN="LEFT"/>single_output : bool<br ALIGN="LEFT"/>two_d_labels : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils._testing.TempMemmap" [color="black", fontcolor="black", label=<{TempMemmap|data<br ALIGN="LEFT"/>mmap_mode : str<br ALIGN="LEFT"/>temp_folder : bytes, str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_validation.test_has_fit_parameter.TestClassWithDeprecatedFitMethod" [color="black", fontcolor="black", label=<{TestClassWithDeprecatedFitMethod|<br ALIGN="LEFT"/>|<I>fit</I>(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_calibration.test_calibration_with_non_sample_aligned_fit_param.TestClassifier" [color="black", fontcolor="black", label=<{TestClassifier|<br ALIGN="LEFT"/>|fit(X, y, sample_weight, fit_param)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.test_set_params_passes_all_parameters.TestDecisionTree" [color="black", fontcolor="black", label=<{TestDecisionTree|<br ALIGN="LEFT"/>|set_params()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_metadata_routing.test_get_metadata_routing.TestDefaults" [color="black", fontcolor="black", label=<{TestDefaults|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_metadata_routing.test_get_metadata_routing.TestDefaultsBadMethodName" [color="black", fontcolor="black", label=<{TestDefaultsBadMethodName|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.feature_selection.tests.test_rfe.test_RFE_fit_score_params.TestEstimator" [color="black", fontcolor="black", label=<{TestEstimator|coef_<br ALIGN="LEFT"/>svc_<br ALIGN="LEFT"/>|fit(X, y, prop)<br ALIGN="LEFT"/>score(X, y, prop)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_search.test_search_cv_pairwise_property_delegated_to_base_estimator.TestEstimator" [color="black", fontcolor="black", label=<{TestEstimator|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_search.test_scalar_fit_param.TestEstimator" [color="black", fontcolor="black", label=<{TestEstimator|a : NoneType<br ALIGN="LEFT"/>r_ : NoneType<br ALIGN="LEFT"/>|fit(X, y, r)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.test_check_fit_score_takes_y_works_on_deprecated_fit.TestEstimatorWithDeprecatedFitMethod" [color="black", fontcolor="black", label=<{TestEstimatorWithDeprecatedFitMethod|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_validation.test_retrieve_samples_from_non_standard_shape.TestNoLenWeirdShape" [color="black", fontcolor="black", label=<{TestNoLenWeirdShape|shape : tuple<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_validation.test_retrieve_samples_from_non_standard_shape.TestNonNumericShape" [color="black", fontcolor="black", label=<{TestNonNumericShape|shape : tuple<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.feature_extraction.text.TfidfTransformer" [color="black", fontcolor="black", label=<{TfidfTransformer|idf_ : ndarray<br ALIGN="LEFT"/>norm : str<br ALIGN="LEFT"/>smooth_idf : bool<br ALIGN="LEFT"/>sublinear_tf : bool<br ALIGN="LEFT"/>use_idf : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X, copy)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.feature_extraction.text.TfidfVectorizer" [color="black", fontcolor="black", label=<{TfidfVectorizer|idf_<br ALIGN="LEFT"/>max_df : float, int<br ALIGN="LEFT"/>norm : str<br ALIGN="LEFT"/>smooth_idf : bool<br ALIGN="LEFT"/>sublinear_tf : bool<br ALIGN="LEFT"/>use_idf : bool<br ALIGN="LEFT"/>|fit(raw_documents, y)<br ALIGN="LEFT"/>fit_transform(raw_documents, y)<br ALIGN="LEFT"/>transform(raw_documents)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._theil_sen.TheilSenRegressor" [color="black", fontcolor="black", label=<{TheilSenRegressor|breakdown_<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>copy_X : str<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_ : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>max_subpopulation : float<br ALIGN="LEFT"/>n_iter_ : int<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>n_subpopulation_ : int<br ALIGN="LEFT"/>n_subsamples : NoneType<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_param_validation.test_third_party_estimator.ThirdPartyEstimator" [color="black", fontcolor="black", label=<{ThirdPartyEstimator|b<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._split.TimeSeriesSplit" [color="black", fontcolor="black", label=<{TimeSeriesSplit|gap : int<br ALIGN="LEFT"/>max_train_size : NoneType<br ALIGN="LEFT"/>test_size : NoneType<br ALIGN="LEFT"/>|split(X, y, groups)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.compose.tests.test_column_transformer.Trans" [color="black", fontcolor="black", label=<{Trans|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.compose.tests.test_column_transformer.test_column_transformer_dataframe.TransAssert" [color="black", fontcolor="black", label=<{TransAssert|expected_type_transform<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.compose.tests.test_column_transformer.TransNo2D" [color="black", fontcolor="black", label=<{TransNo2D|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.compose.tests.test_column_transformer.TransRaise" [color="black", fontcolor="black", label=<{TransRaise|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.compose.tests.test_column_transformer.TransWithNames" [color="black", fontcolor="black", label=<{TransWithNames|feature_names_out : NoneType<br ALIGN="LEFT"/>|get_feature_names_out(input_features)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_pipeline.Transf" [color="black", fontcolor="black", label=<{Transf|<br ALIGN="LEFT"/>|inverse_transform(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_pipeline.TransfFitParams" [color="black", fontcolor="black", label=<{TransfFitParams|fit_params : dict<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.neighbors.tests.test_nca.test_expected_transformation_shape.TransformationStorer" [color="black", fontcolor="black", label=<{TransformationStorer|X<br ALIGN="LEFT"/>fake_nca<br ALIGN="LEFT"/>same_class_mask<br ALIGN="LEFT"/>transformation<br ALIGN="LEFT"/>|callback(transformation, n_iter)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.compose._target.TransformedTargetRegressor" [color="black", fontcolor="black", label=<{TransformedTargetRegressor|check_inverse : bool<br ALIGN="LEFT"/>feature_names_in_<br ALIGN="LEFT"/>func : NoneType<br ALIGN="LEFT"/>inverse_func : NoneType<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>regressor : NoneType<br ALIGN="LEFT"/>regressor_<br ALIGN="LEFT"/>transformer : NoneType<br ALIGN="LEFT"/>transformer_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_pipeline.test_transform_input_explicit_value_check.Transformer" [color="black", fontcolor="black", label=<{Transformer|fitted_ : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_pipeline.test_transform_tuple_input.Transformer" [color="black", fontcolor="black", label=<{Transformer|fitted_ : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.base.TransformerMixin" [color="black", fontcolor="black", label=<{TransformerMixin|<br ALIGN="LEFT"/>|fit_transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_parallel.test_dispatch_config_parallel.TransformerRequiredDataFrame" [color="black", fontcolor="black", label=<{TransformerRequiredDataFrame|<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._tags.TransformerTags" [color="black", fontcolor="black", label=<{TransformerTags|preserves_dtype : list[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tree._reingold_tilford.Tree" [color="black", fontcolor="black", label=<{Tree|children : list, tuple<br ALIGN="LEFT"/>label : str<br ALIGN="LEFT"/>node_id : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_base.TreeBadVersion" [color="black", fontcolor="black", label=<{TreeBadVersion|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower" [color="black", fontcolor="black", label=<{TreeGrower|X_binned<br ALIGN="LEFT"/>finalized_leaves : list<br ALIGN="LEFT"/>has_missing_values<br ALIGN="LEFT"/>histogram_builder<br ALIGN="LEFT"/>interaction_cst : NoneType<br ALIGN="LEFT"/>is_categorical : NoneType, ndarray<br ALIGN="LEFT"/>l2_regularization : float<br ALIGN="LEFT"/>max_depth : NoneType<br ALIGN="LEFT"/>max_leaf_nodes : NoneType<br ALIGN="LEFT"/>min_gain_to_split : float<br ALIGN="LEFT"/>min_samples_leaf : int<br ALIGN="LEFT"/>missing_values_bin_idx : int<br ALIGN="LEFT"/>monotonic_cst : NoneType, ndarray<br ALIGN="LEFT"/>n_bins_non_missing : NoneType, int, ndarray<br ALIGN="LEFT"/>n_categorical_splits : int<br ALIGN="LEFT"/>n_features<br ALIGN="LEFT"/>n_nodes : int<br ALIGN="LEFT"/>n_threads<br ALIGN="LEFT"/>root<br ALIGN="LEFT"/>shrinkage : float<br ALIGN="LEFT"/>splittable_nodes : list<br ALIGN="LEFT"/>splitter<br ALIGN="LEFT"/>total_apply_split_time : float<br ALIGN="LEFT"/>total_compute_hist_time : float<br ALIGN="LEFT"/>total_find_split_time : float<br ALIGN="LEFT"/>with_monotonic_cst<br ALIGN="LEFT"/>|grow()<br ALIGN="LEFT"/>make_predictor(binning_thresholds)<br ALIGN="LEFT"/>split_next()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.TreeNoVersion" [color="black", fontcolor="black", label=<{TreeNoVersion|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.ensemble._hist_gradient_boosting.grower.TreeNode" [color="black", fontcolor="black", label=<{TreeNode|allowed_features : NoneType<br ALIGN="LEFT"/>children_lower_bound<br ALIGN="LEFT"/>children_upper_bound<br ALIGN="LEFT"/>depth<br ALIGN="LEFT"/>histograms : NoneType<br ALIGN="LEFT"/>interaction_cst_indices : NoneType, list, range<br ALIGN="LEFT"/>is_leaf : bool<br ALIGN="LEFT"/>left_child : NoneType<br ALIGN="LEFT"/>n_samples<br ALIGN="LEFT"/>partition_start<br ALIGN="LEFT"/>partition_stop<br ALIGN="LEFT"/>right_child : NoneType<br ALIGN="LEFT"/>sample_indices<br ALIGN="LEFT"/>split_info : NoneType<br ALIGN="LEFT"/>sum_gradients<br ALIGN="LEFT"/>sum_hessians<br ALIGN="LEFT"/>value : NoneType<br ALIGN="LEFT"/>|set_children_bounds(lower, upper)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble._hist_gradient_boosting.predictor.TreePredictor" [color="black", fontcolor="black", label=<{TreePredictor|binned_left_cat_bitsets<br ALIGN="LEFT"/>nodes<br ALIGN="LEFT"/>raw_left_cat_bitsets<br ALIGN="LEFT"/>|compute_partial_dependence(grid, target_features, out)<br ALIGN="LEFT"/>get_max_depth()<br ALIGN="LEFT"/>get_n_leaf_nodes()<br ALIGN="LEFT"/>predict(X, known_cat_bitsets, f_idx_map, n_threads)<br ALIGN="LEFT"/>predict_binned(X, missing_values_bin_idx, n_threads)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.decomposition._truncated_svd.TruncatedSVD" [color="black", fontcolor="black", label=<{TruncatedSVD|algorithm : str<br ALIGN="LEFT"/>components_<br ALIGN="LEFT"/>explained_variance_<br ALIGN="LEFT"/>explained_variance_ratio_<br ALIGN="LEFT"/>n_components : int<br ALIGN="LEFT"/>n_iter : int<br ALIGN="LEFT"/>n_oversamples : int<br ALIGN="LEFT"/>power_iteration_normalizer : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>singular_values_<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._classification_threshold.TunedThresholdClassifierCV" [color="black", fontcolor="black", label=<{TunedThresholdClassifierCV|best_score_<br ALIGN="LEFT"/>best_threshold_<br ALIGN="LEFT"/>cv : NoneType<br ALIGN="LEFT"/>cv_results_ : dict<br ALIGN="LEFT"/>estimator_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>refit : bool<br ALIGN="LEFT"/>scoring : str<br ALIGN="LEFT"/>store_cv_results : bool<br ALIGN="LEFT"/>thresholds : int<br ALIGN="LEFT"/>|get_metadata_routing()<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._glm.glm.TweedieRegressor" [color="black", fontcolor="black", label=<{TweedieRegressor|link : str<br ALIGN="LEFT"/>power : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.exceptions.UndefinedMetricWarning" [color="black", fontcolor="red", label=<{UndefinedMetricWarning|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.exceptions.UnsetMetadataPassedError" [color="black", fontcolor="red", label=<{UnsetMetadataPassedError|routed_params<br ALIGN="LEFT"/>unrequested_params<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks.UntaggedBinaryClassifier" [color="black", fontcolor="black", label=<{UntaggedBinaryClassifier|<br ALIGN="LEFT"/>|fit(X, y, coef_init, intercept_init, sample_weight)<br ALIGN="LEFT"/>partial_fit(X, y, classes, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._plot.ValidationCurveDisplay" [color="black", fontcolor="black", label=<{ValidationCurveDisplay|param_name<br ALIGN="LEFT"/>param_range<br ALIGN="LEFT"/>score_name : NoneType<br ALIGN="LEFT"/>test_scores<br ALIGN="LEFT"/>train_scores<br ALIGN="LEFT"/>|from_estimator(estimator, X, y)<br ALIGN="LEFT"/>plot(ax)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.VargEstimator" [color="black", fontcolor="black", label=<{VargEstimator|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.feature_selection._variance_threshold.VarianceThreshold" [color="black", fontcolor="black", label=<{VarianceThreshold|threshold : float<br ALIGN="LEFT"/>variances_ : ndarray<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble._gb.VerboseReporter" [color="black", fontcolor="black", label=<{VerboseReporter|begin_at_stage : int<br ALIGN="LEFT"/>start_time<br ALIGN="LEFT"/>verbose<br ALIGN="LEFT"/>verbose_fmt : str<br ALIGN="LEFT"/>verbose_mod : int<br ALIGN="LEFT"/>|init(est, begin_at_stage)<br ALIGN="LEFT"/>update(j, est)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.externals._packaging.version.Version" [color="black", fontcolor="black", label=<{Version|base_version<br ALIGN="LEFT"/>dev<br ALIGN="LEFT"/>epoch<br ALIGN="LEFT"/>is_devrelease<br ALIGN="LEFT"/>is_postrelease<br ALIGN="LEFT"/>is_prerelease<br ALIGN="LEFT"/>local<br ALIGN="LEFT"/>major<br ALIGN="LEFT"/>micro<br ALIGN="LEFT"/>minor<br ALIGN="LEFT"/>post<br ALIGN="LEFT"/>pre<br ALIGN="LEFT"/>public<br ALIGN="LEFT"/>release<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.ensemble._voting.VotingClassifier" [color="black", fontcolor="black", label=<{VotingClassifier|classes_<br ALIGN="LEFT"/>flatten_transform : bool<br ALIGN="LEFT"/>le_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>voting : str<br ALIGN="LEFT"/>weights : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble._voting.VotingRegressor" [color="black", fontcolor="black", label=<{VotingRegressor|n_jobs : NoneType<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>weights : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._testing._get_warnings_filters_info_list.WarningInfo" [color="black", fontcolor="black", label=<{WarningInfo|action : str<br ALIGN="LEFT"/>category : type[Warning]<br ALIGN="LEFT"/>message : str<br ALIGN="LEFT"/>|to_filterwarning_str()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.metadata_routing_common.WeightedMetaClassifier" [color="black", fontcolor="black", label=<{WeightedMetaClassifier|estimator<br ALIGN="LEFT"/>estimator_<br ALIGN="LEFT"/>registry : NoneType<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.metadata_routing_common.WeightedMetaRegressor" [color="black", fontcolor="black", label=<{WeightedMetaRegressor|estimator<br ALIGN="LEFT"/>estimator_<br ALIGN="LEFT"/>registry : NoneType<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_metadata_routing.test_metaestimator_warnings.WeightedMetaRegressorWarn" [color="black", fontcolor="black", label=<{WeightedMetaRegressorWarn|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.gaussian_process.kernels.WhiteKernel" [color="black", fontcolor="black", label=<{WhiteKernel|hyperparameter_noise_level<br ALIGN="LEFT"/>noise_level : float<br ALIGN="LEFT"/>noise_level_bounds : tuple<br ALIGN="LEFT"/>|diag(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_pprint.test_kwargs_in_init.WithKWargs" [color="black", fontcolor="black", label=<{WithKWargs|a : str<br ALIGN="LEFT"/>b : str<br ALIGN="LEFT"/>|get_params(deep)<br ALIGN="LEFT"/>set_params()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.test_base.test_estimator_getstate_using_slots_error_message.WithSlots" [color="black", fontcolor="black", label=<{WithSlots|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_validation.WrongDummyMemory" [color="black", fontcolor="black", label=<{WrongDummyMemory|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_calibration.test_calibration_zero_probability.ZeroCalibrator" [color="black", fontcolor="black", label=<{ZeroCalibrator|<br ALIGN="LEFT"/>|predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.impute.tests.test_impute.test_iterative_imputer_dont_set_random_state.ZeroEstimator" [color="black", fontcolor="black", label=<{ZeroEstimator|random_state<br ALIGN="LEFT"/>|fit()<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._param_validation._ArrayLikes" [color="black", fontcolor="black", label=<{_ArrayLikes|hidden : bool<br ALIGN="LEFT"/>|is_satisfied_by(val)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._available_if._AvailableIfDescriptor" [color="black", fontcolor="black", label=<{_AvailableIfDescriptor|attribute_name<br ALIGN="LEFT"/>check<br ALIGN="LEFT"/>fn<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_param_validation.test_hasmethods._Bad" [color="black", fontcolor="black", label=<{_Bad|<br ALIGN="LEFT"/>|<I>a</I>()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.multioutput._BaseChain" [color="black", fontcolor="black", label=<{_BaseChain|base_estimator<br ALIGN="LEFT"/>chain_method_<br ALIGN="LEFT"/>cv : NoneType<br ALIGN="LEFT"/>estimators_<br ALIGN="LEFT"/>order : NoneType<br ALIGN="LEFT"/>order_ : NoneType, ndarray<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|<I>fit</I>(X, Y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.metaestimators._BaseComposition" [color="black", fontcolor="black", label=<{_BaseComposition|steps : List[Any]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.model_selection._plot._BaseCurveDisplay" [color="black", fontcolor="black", label=<{_BaseCurveDisplay|ax_ : NoneType<br ALIGN="LEFT"/>errorbar_ : NoneType, list<br ALIGN="LEFT"/>figure_<br ALIGN="LEFT"/>fill_between_ : NoneType, list<br ALIGN="LEFT"/>lines_ : NoneType, list<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.naive_bayes._BaseDiscreteNB" [color="black", fontcolor="black", label=<{_BaseDiscreteNB|alpha : float<br ALIGN="LEFT"/>class_count_ : ndarray<br ALIGN="LEFT"/>class_log_prior_ : ndarray<br ALIGN="LEFT"/>class_prior : NoneType<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>feature_count_ : ndarray<br ALIGN="LEFT"/>fit_prior : bool<br ALIGN="LEFT"/>force_alpha : bool<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>partial_fit(X, y, classes, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.preprocessing._encoders._BaseEncoder" [color="black", fontcolor="black", label=<{_BaseEncoder|categories_ : list<br ALIGN="LEFT"/>infrequent_categories_<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.feature_selection._univariate_selection._BaseFilter" [color="black", fontcolor="black", label=<{_BaseFilter|pvalues_ : NoneType<br ALIGN="LEFT"/>score_func<br ALIGN="LEFT"/>scores_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble._base._BaseHeterogeneousEnsemble" [color="black", fontcolor="black", label=<{_BaseHeterogeneousEnsemble|estimators<br ALIGN="LEFT"/>named_estimators<br ALIGN="LEFT"/>|get_params(deep)<br ALIGN="LEFT"/>set_params()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.impute._base._BaseImputer" [color="black", fontcolor="black", label=<{_BaseImputer|add_indicator : bool<br ALIGN="LEFT"/>indicator_ : NoneType<br ALIGN="LEFT"/>keep_empty_features : bool<br ALIGN="LEFT"/>missing_values<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.model_selection._split._BaseKFold" [color="black", fontcolor="black", label=<{_BaseKFold|n_splits : int<br ALIGN="LEFT"/>random_state<br ALIGN="LEFT"/>shuffle<br ALIGN="LEFT"/>|get_n_splits(X, y, groups)<br ALIGN="LEFT"/>split(X, y, groups)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.cluster._kmeans._BaseKMeans" [color="black", fontcolor="black", label=<{_BaseKMeans|init<br ALIGN="LEFT"/>max_iter<br ALIGN="LEFT"/>n_clusters<br ALIGN="LEFT"/>n_init<br ALIGN="LEFT"/>random_state<br ALIGN="LEFT"/>tol<br ALIGN="LEFT"/>verbose<br ALIGN="LEFT"/>|fit_predict(X, y, sample_weight)<br ALIGN="LEFT"/>fit_transform(X, y, sample_weight)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>score(X, y, sample_weight)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_estimator_checks._BaseMultiLabelClassifierMock" [color="black", fontcolor="black", label=<{_BaseMultiLabelClassifierMock|response_output<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.naive_bayes._BaseNB" [color="black", fontcolor="black", label=<{_BaseNB|<br ALIGN="LEFT"/>|predict(X)<br ALIGN="LEFT"/>predict_joint_log_proba(X)<br ALIGN="LEFT"/>predict_log_proba(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.decomposition._nmf._BaseNMF" [color="black", fontcolor="black", label=<{_BaseNMF|alpha_H : str<br ALIGN="LEFT"/>alpha_W : float<br ALIGN="LEFT"/>beta_loss : str<br ALIGN="LEFT"/>init : NoneType<br ALIGN="LEFT"/>l1_ratio : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_components : str<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.decomposition._base._BasePCA" [color="black", fontcolor="black", label=<{_BasePCA|<br ALIGN="LEFT"/>|<I>fit</I>(X, y)<br ALIGN="LEFT"/>get_covariance()<br ALIGN="LEFT"/>get_precision()<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._ridge._BaseRidge" [color="black", fontcolor="black", label=<{_BaseRidge|alpha : float<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_<br ALIGN="LEFT"/>max_iter : NoneType<br ALIGN="LEFT"/>n_iter_<br ALIGN="LEFT"/>positive : bool<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>solver : str<br ALIGN="LEFT"/>solver_<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._ridge._BaseRidgeCV" [color="black", fontcolor="black", label=<{_BaseRidgeCV|alpha_ : NoneType<br ALIGN="LEFT"/>alpha_per_target : bool<br ALIGN="LEFT"/>alphas : tuple<br ALIGN="LEFT"/>best_score_ : NoneType, tuple<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>cv : NoneType<br ALIGN="LEFT"/>cv_results_ : ndarray<br ALIGN="LEFT"/>cv_values_<br ALIGN="LEFT"/>feature_names_in_<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>gcv_mode : NoneType<br ALIGN="LEFT"/>intercept_ : float<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>scoring : NoneType<br ALIGN="LEFT"/>store_cv_results : NoneType<br ALIGN="LEFT"/>store_cv_values : str<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.metrics._scorer._BaseScorer" [color="black", fontcolor="black", label=<{_BaseScorer|<br ALIGN="LEFT"/>|set_score_request()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.decomposition._dict_learning._BaseSparseCoding" [color="black", fontcolor="black", label=<{_BaseSparseCoding|n_jobs<br ALIGN="LEFT"/>positive_code<br ALIGN="LEFT"/>split_sign<br ALIGN="LEFT"/>transform_algorithm<br ALIGN="LEFT"/>transform_alpha<br ALIGN="LEFT"/>transform_max_iter<br ALIGN="LEFT"/>transform_n_nonzero_coefs<br ALIGN="LEFT"/>|transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.decomposition._sparse_pca._BaseSparsePCA" [color="black", fontcolor="black", label=<{_BaseSparsePCA|alpha : int<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>mean_<br ALIGN="LEFT"/>method : str<br ALIGN="LEFT"/>n_components : NoneType<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>ridge_alpha : float<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble._stacking._BaseStacking" [color="black", fontcolor="black", label=<{_BaseStacking|cv : NoneType<br ALIGN="LEFT"/>estimators_ : list<br ALIGN="LEFT"/>feature_names_in_<br ALIGN="LEFT"/>final_estimator : NoneType<br ALIGN="LEFT"/>final_estimator_<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>named_estimators_<br ALIGN="LEFT"/>passthrough : bool<br ALIGN="LEFT"/>stack_method : str<br ALIGN="LEFT"/>stack_method_<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_feature_names_out(input_features)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tree._export._BaseTreeExporter" [color="black", fontcolor="black", label=<{_BaseTreeExporter|class_names : NoneType<br ALIGN="LEFT"/>feature_names : NoneType<br ALIGN="LEFT"/>filled : bool<br ALIGN="LEFT"/>fontsize : NoneType<br ALIGN="LEFT"/>impurity : bool<br ALIGN="LEFT"/>label : str<br ALIGN="LEFT"/>max_depth : NoneType<br ALIGN="LEFT"/>node_ids : bool<br ALIGN="LEFT"/>precision : int<br ALIGN="LEFT"/>proportion : bool<br ALIGN="LEFT"/>rounded : bool<br ALIGN="LEFT"/>|get_color(value)<br ALIGN="LEFT"/>get_fill_color(tree, node_id)<br ALIGN="LEFT"/>node_to_str(tree, node_id, criterion)<br ALIGN="LEFT"/>str_escape(string)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.externals._packaging.version._BaseVersion" [color="black", fontcolor="black", label=<{_BaseVersion|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.ensemble._voting._BaseVoting" [color="black", fontcolor="black", label=<{_BaseVoting|estimators_ : list<br ALIGN="LEFT"/>feature_names_in_<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>named_estimators_<br ALIGN="LEFT"/>|<I>fit</I>(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.ensemble._hist_gradient_boosting.binning._BinMapper" [color="black", fontcolor="black", label=<{_BinMapper|bin_thresholds_<br ALIGN="LEFT"/>is_categorical : NoneType<br ALIGN="LEFT"/>is_categorical_ : ndarray<br ALIGN="LEFT"/>known_categories : NoneType<br ALIGN="LEFT"/>missing_values_bin_idx_ : int<br ALIGN="LEFT"/>n_bins : int<br ALIGN="LEFT"/>n_bins_non_missing_ : ndarray<br ALIGN="LEFT"/>n_threads : NoneType<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>subsample : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>make_known_categories_bitsets()<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._plotting._BinaryClassifierCurveDisplayMixin" [color="black", fontcolor="black", label=<{_BinaryClassifierCurveDisplayMixin|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.gaussian_process._gpc._BinaryGaussianProcessClassifierLaplace" [color="black", fontcolor="black", label=<{_BinaryGaussianProcessClassifierLaplace|L_ : tuple<br ALIGN="LEFT"/>W_sr_<br ALIGN="LEFT"/>X_train_<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>copy_X_train : bool<br ALIGN="LEFT"/>f_cached : ndarray<br ALIGN="LEFT"/>kernel : NoneType<br ALIGN="LEFT"/>kernel_<br ALIGN="LEFT"/>log_marginal_likelihood_value_<br ALIGN="LEFT"/>max_iter_predict : int<br ALIGN="LEFT"/>n_restarts_optimizer : int<br ALIGN="LEFT"/>optimizer : str<br ALIGN="LEFT"/>pi_<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>rng : NoneType<br ALIGN="LEFT"/>warm_start : bool<br ALIGN="LEFT"/>y_train_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>log_marginal_likelihood(theta, eval_gradient, clone_kernel)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.cluster._bisect_k_means._BisectingTree" [color="black", fontcolor="black", label=<{_BisectingTree|center<br ALIGN="LEFT"/>indices : NoneType<br ALIGN="LEFT"/>left : NoneType<br ALIGN="LEFT"/>right : NoneType<br ALIGN="LEFT"/>score<br ALIGN="LEFT"/>|get_cluster_to_bisect()<br ALIGN="LEFT"/>iter_leaves()<br ALIGN="LEFT"/>split(labels, centers, scores)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._param_validation._Booleans" [color="black", fontcolor="black", label=<{_Booleans|hidden : bool<br ALIGN="LEFT"/>|is_satisfied_by(val)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.cluster._birch._CFNode" [color="black", fontcolor="black", label=<{_CFNode|branching_factor<br ALIGN="LEFT"/>centroids_<br ALIGN="LEFT"/>init_centroids_ : ndarray<br ALIGN="LEFT"/>init_sq_norm_ : ndarray<br ALIGN="LEFT"/>is_leaf<br ALIGN="LEFT"/>n_features<br ALIGN="LEFT"/>next_leaf_ : NoneType<br ALIGN="LEFT"/>prev_leaf_ : NoneType<br ALIGN="LEFT"/>squared_norm_ : list<br ALIGN="LEFT"/>subclusters_ : list<br ALIGN="LEFT"/>threshold<br ALIGN="LEFT"/>|append_subcluster(subcluster)<br ALIGN="LEFT"/>insert_cf_subcluster(subcluster)<br ALIGN="LEFT"/>update_split_subclusters(subcluster, new_subcluster1, new_subcluster2)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.cluster._birch._CFSubcluster" [color="black", fontcolor="black", label=<{_CFSubcluster|centroid_ : float, int<br ALIGN="LEFT"/>child_ : NoneType<br ALIGN="LEFT"/>linear_sum_ : int<br ALIGN="LEFT"/>n_samples_ : int<br ALIGN="LEFT"/>radius<br ALIGN="LEFT"/>sq_norm_ : ndarray<br ALIGN="LEFT"/>squared_sum_ : float, ndarray<br ALIGN="LEFT"/>|merge_subcluster(nominee_cluster, threshold)<br ALIGN="LEFT"/>update(subcluster)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._split._CVIterableWrapper" [color="black", fontcolor="black", label=<{_CVIterableWrapper|cv : list<br ALIGN="LEFT"/>random_state<br ALIGN="LEFT"/>|get_n_splits(X, y, groups)<br ALIGN="LEFT"/>split(X, y, groups)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._param_validation._CVObjects" [color="black", fontcolor="black", label=<{_CVObjects|hidden : bool<br ALIGN="LEFT"/>|is_satisfied_by(val)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.calibration._CalibratedClassifier" [color="black", fontcolor="black", label=<{_CalibratedClassifier|calibrators<br ALIGN="LEFT"/>classes<br ALIGN="LEFT"/>estimator<br ALIGN="LEFT"/>method : str<br ALIGN="LEFT"/>|predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._param_validation._Callables" [color="black", fontcolor="black", label=<{_Callables|hidden : bool<br ALIGN="LEFT"/>|is_satisfied_by(val)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_param_validation._Class" [color="black", fontcolor="black", label=<{_Class|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.multiclass._ConstantPredictor" [color="black", fontcolor="black", label=<{_ConstantPredictor|y_<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._param_validation._Constraint" [color="black", fontcolor="black", label=<{_Constraint|hidden : bool<br ALIGN="LEFT"/>|<I>is_satisfied_by</I>(val)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.metrics._scorer._CurveScorer" [color="black", fontcolor="black", label=<{_CurveScorer|<br ALIGN="LEFT"/>|from_scorer(scorer, response_method, thresholds)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tree._export._DOTTreeExporter" [color="black", fontcolor="black", label=<{_DOTTreeExporter|characters : list<br ALIGN="LEFT"/>colors : dict<br ALIGN="LEFT"/>fontname : str<br ALIGN="LEFT"/>leaves_parallel : bool<br ALIGN="LEFT"/>out_file<br ALIGN="LEFT"/>ranks : dict<br ALIGN="LEFT"/>rotate : bool<br ALIGN="LEFT"/>special_characters : bool<br ALIGN="LEFT"/>|export(decision_tree)<br ALIGN="LEFT"/>head()<br ALIGN="LEFT"/>recurse(tree, node_id, criterion, parent, depth)<br ALIGN="LEFT"/>str_escape(string)<br ALIGN="LEFT"/>tail()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.externals._arff._DataListMixin" [color="black", fontcolor="black", label=<{_DataListMixin|<br ALIGN="LEFT"/>|decode_rows(stream, conversors)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.datasets.tests.test_base._DummyPath" [color="black", fontcolor="black", label=<{_DummyPath|path<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_base._Empty" [color="black", fontcolor="black", label=<{_Empty|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.tests.test_param_validation._Estimator" [color="black", fontcolor="black", label=<{_Estimator|a<br ALIGN="LEFT"/>|<I>fit</I>(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._pprint._EstimatorPrettyPrinter" [color="black", fontcolor="black", label=<{_EstimatorPrettyPrinter|n_max_elements_to_show : NoneType<br ALIGN="LEFT"/>|format(object, context, maxlevels, level)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection.tests.test_search.test_scalar_fit_param_compat._FitParamClassifier" [color="black", fontcolor="black", label=<{_FitParamClassifier|<br ALIGN="LEFT"/>|fit(X, y, sample_weight, tuple_of_arrays, scalar_param, callable_param)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.parallel._FuncWrapper" [color="black", fontcolor="black", label=<{_FuncWrapper|config<br ALIGN="LEFT"/>function<br ALIGN="LEFT"/>|with_config(config)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._glm.glm._GeneralizedLinearRegressor" [color="black", fontcolor="black", label=<{_GeneralizedLinearRegressor|alpha : float<br ALIGN="LEFT"/>coef_ : ndarray<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>intercept_ : float<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>n_iter_ : int<br ALIGN="LEFT"/>solver : str<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>warm_start : bool<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>score(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.tests.test_param_validation.test_hasmethods._Good" [color="black", fontcolor="black", label=<{_Good|<br ALIGN="LEFT"/>|<I>a</I>()<br ALIGN="LEFT"/><I>b</I>()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._estimator_html_repr._HTMLDocumentationLinkMixin" [color="black", fontcolor="black", label=<{_HTMLDocumentationLinkMixin|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils._estimator_html_repr._IDCounter" [color="black", fontcolor="black", label=<{_IDCounter|count : int<br ALIGN="LEFT"/>prefix<br ALIGN="LEFT"/>|get_id()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._ridge._IdentityClassifier" [color="black", fontcolor="black", label=<{_IdentityClassifier|classes_<br ALIGN="LEFT"/>|decision_function(y_predict)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._ridge._IdentityRegressor" [color="black", fontcolor="black", label=<{_IdentityRegressor|<br ALIGN="LEFT"/>|decision_function(y_predict)<br ALIGN="LEFT"/>predict(y_predict)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._testing._IgnoreWarnings" [color="black", fontcolor="black", label=<{_IgnoreWarnings|category<br ALIGN="LEFT"/>log : list<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils._param_validation._InstancesOf" [color="black", fontcolor="black", label=<{_InstancesOf|hidden : bool<br ALIGN="LEFT"/>type<br ALIGN="LEFT"/>|is_satisfied_by(val)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._param_validation._IterablesNotString" [color="black", fontcolor="black", label=<{_IterablesNotString|<br ALIGN="LEFT"/>|is_satisfied_by(val)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.optimize._LineSearchError" [color="black", fontcolor="red", label=<{_LineSearchError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tree._export._MPLTreeExporter" [color="black", fontcolor="black", label=<{_MPLTreeExporter|arrow_args : dict<br ALIGN="LEFT"/>bbox_args : dict<br ALIGN="LEFT"/>characters : list<br ALIGN="LEFT"/>colors : dict<br ALIGN="LEFT"/>fontsize : NoneType<br ALIGN="LEFT"/>ranks : dict<br ALIGN="LEFT"/>|export(decision_tree, ax)<br ALIGN="LEFT"/>recurse(node, tree, ax, max_x, max_y, depth)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._metadata_requests._MetadataRequester" [color="black", fontcolor="black", label=<{_MetadataRequester|<br ALIGN="LEFT"/>|get_metadata_routing()<br ALIGN="LEFT"/><I>set_decision_function_request</I>()<br ALIGN="LEFT"/><I>set_fit_request</I>()<br ALIGN="LEFT"/><I>set_inverse_transform_request</I>()<br ALIGN="LEFT"/><I>set_partial_fit_request</I>()<br ALIGN="LEFT"/><I>set_predict_log_proba_request</I>()<br ALIGN="LEFT"/><I>set_predict_proba_request</I>()<br ALIGN="LEFT"/><I>set_predict_request</I>()<br ALIGN="LEFT"/><I>set_score_request</I>()<br ALIGN="LEFT"/><I>set_split_request</I>()<br ALIGN="LEFT"/><I>set_transform_request</I>()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._mocking._MockEstimatorOnOffPrediction" [color="black", fontcolor="black", label=<{_MockEstimatorOnOffPrediction|classes_ : tuple<br ALIGN="LEFT"/>response_methods : NoneType<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.datasets.tests.test_openml._MockHTTPResponse" [color="black", fontcolor="black", label=<{_MockHTTPResponse|data<br ALIGN="LEFT"/>is_gzip<br ALIGN="LEFT"/>|close()<br ALIGN="LEFT"/>info()<br ALIGN="LEFT"/>read(amt)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.multioutput._MultiOutputEstimator" [color="black", fontcolor="black", label=<{_MultiOutputEstimator|estimator<br ALIGN="LEFT"/>estimators_ : list<br ALIGN="LEFT"/>feature_names_in_<br ALIGN="LEFT"/>n_features_in_<br ALIGN="LEFT"/>n_jobs : NoneType<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>get_metadata_routing()<br ALIGN="LEFT"/>partial_fit(X, y, classes, sample_weight)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.metrics._scorer._MultimetricScorer" [color="black", fontcolor="black", label=<{_MultimetricScorer|<br ALIGN="LEFT"/>|get_metadata_routing()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._encode._NaNCounter" [color="black", fontcolor="black", label=<{_NaNCounter|nan_count : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils._param_validation._NanConstraint" [color="black", fontcolor="black", label=<{_NanConstraint|<br ALIGN="LEFT"/>|is_satisfied_by(val)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._param_validation._NoneConstraint" [color="black", fontcolor="black", label=<{_NoneConstraint|hidden : bool<br ALIGN="LEFT"/>|is_satisfied_by(val)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils.estimator_checks._NotAnArray" [color="black", fontcolor="black", label=<{_NotAnArray|data<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils._array_api._NumPyAPIWrapper" [color="black", fontcolor="black", label=<{_NumPyAPIWrapper|bool<br ALIGN="LEFT"/>|asarray(x)<br ALIGN="LEFT"/>astype(x, dtype)<br ALIGN="LEFT"/>concat(arrays)<br ALIGN="LEFT"/>isdtype(dtype, kind)<br ALIGN="LEFT"/>pow(x1, x2)<br ALIGN="LEFT"/>reshape(x, shape)<br ALIGN="LEFT"/>unique_all(x)<br ALIGN="LEFT"/>unique_counts(x)<br ALIGN="LEFT"/>unique_inverse(x)<br ALIGN="LEFT"/>unique_values(x)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.cross_decomposition._pls._PLS" [color="black", fontcolor="black", label=<{_PLS|algorithm : str<br ALIGN="LEFT"/>coef_ : ndarray<br ALIGN="LEFT"/>copy : bool<br ALIGN="LEFT"/>deflation_mode : str<br ALIGN="LEFT"/>intercept_<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>mode : str<br ALIGN="LEFT"/>n_components : int<br ALIGN="LEFT"/>n_iter_ : list<br ALIGN="LEFT"/>scale : bool<br ALIGN="LEFT"/>tol : float<br ALIGN="LEFT"/>x_loadings_ : ndarray<br ALIGN="LEFT"/>x_rotations_ : ndarray<br ALIGN="LEFT"/>x_weights_ : ndarray<br ALIGN="LEFT"/>y_loadings_ : ndarray<br ALIGN="LEFT"/>y_rotations_ : ndarray<br ALIGN="LEFT"/>y_weights_ : ndarray<br ALIGN="LEFT"/>|fit(X, y, Y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>inverse_transform(X, y, Y)<br ALIGN="LEFT"/>predict(X, copy)<br ALIGN="LEFT"/>transform(X, y, Y, copy)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._param_validation._PandasNAConstraint" [color="black", fontcolor="black", label=<{_PandasNAConstraint|<br ALIGN="LEFT"/>|is_satisfied_by(val)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.metrics._scorer._PassthroughScorer" [color="black", fontcolor="black", label=<{_PassthroughScorer|<br ALIGN="LEFT"/>|get_metadata_routing()<br ALIGN="LEFT"/>set_score_request()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._testing._Raises" [color="black", fontcolor="black", label=<{_Raises|err_msg<br ALIGN="LEFT"/>expected_exc_types : list<br ALIGN="LEFT"/>matches : list<br ALIGN="LEFT"/>may_pass<br ALIGN="LEFT"/>raised_and_matched : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils._param_validation._RandomStates" [color="black", fontcolor="black", label=<{_RandomStates|hidden : bool<br ALIGN="LEFT"/>|is_satisfied_by(val)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.tests.metadata_routing_common._Registry" [color="black", fontcolor="black", label=<{_Registry|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.compose._column_transformer._RemainderColsList" [color="black", fontcolor="black", label=<{_RemainderColsList|future_dtype : NoneType<br ALIGN="LEFT"/>warning_enabled : bool<br ALIGN="LEFT"/>warning_was_emitted : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.model_selection._split._RepeatedSplits" [color="black", fontcolor="black", label=<{_RepeatedSplits|cv<br ALIGN="LEFT"/>cvargs : dict<br ALIGN="LEFT"/>n_repeats : int<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>|get_n_splits(X, y, groups)<br ALIGN="LEFT"/>split(X, y, groups)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._ridge._RidgeClassifierMixin" [color="black", fontcolor="black", label=<{_RidgeClassifierMixin|classes_<br ALIGN="LEFT"/>|predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._ridge._RidgeGCV" [color="black", fontcolor="black", label=<{_RidgeGCV|alpha_ : NoneType, ndarray<br ALIGN="LEFT"/>alpha_per_target : bool<br ALIGN="LEFT"/>alphas : tuple<br ALIGN="LEFT"/>best_score_ : NoneType, tuple<br ALIGN="LEFT"/>coef_<br ALIGN="LEFT"/>copy_X : bool<br ALIGN="LEFT"/>cv_results_ : ndarray<br ALIGN="LEFT"/>dual_coef_ : NoneType, ndarray<br ALIGN="LEFT"/>fit_intercept : bool<br ALIGN="LEFT"/>gcv_mode : NoneType<br ALIGN="LEFT"/>is_clf : bool<br ALIGN="LEFT"/>scoring : NoneType<br ALIGN="LEFT"/>store_cv_results : bool<br ALIGN="LEFT"/>|fit(X, y, sample_weight, score_params)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._metadata_requests._RoutingNotSupportedMixin" [color="black", fontcolor="black", label=<{_RoutingNotSupportedMixin|<br ALIGN="LEFT"/>|<I>get_metadata_routing</I>()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.metrics._scorer._Scorer" [color="black", fontcolor="black", label=<{_Scorer|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils._set_output._SetOutputMixin" [color="black", fontcolor="black", label=<{_SetOutputMixin|<br ALIGN="LEFT"/>|set_output()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.calibration._SigmoidCalibration" [color="black", fontcolor="black", label=<{_SigmoidCalibration|a_<br ALIGN="LEFT"/>b_<br ALIGN="LEFT"/>|fit(X, y, sample_weight)<br ALIGN="LEFT"/>predict(T)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._param_validation._SparseMatrices" [color="black", fontcolor="black", label=<{_SparseMatrices|hidden : bool<br ALIGN="LEFT"/>|is_satisfied_by(val)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model.tests.test_sgd._SparseSGDClassifier" [color="black", fontcolor="black", label=<{_SparseSGDClassifier|<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>partial_fit(X, y)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model.tests.test_sgd._SparseSGDOneClassSVM" [color="black", fontcolor="black", label=<{_SparseSGDOneClassSVM|<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X)<br ALIGN="LEFT"/>partial_fit(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model.tests.test_sgd._SparseSGDRegressor" [color="black", fontcolor="black", label=<{_SparseSGDRegressor|<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>partial_fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.model_selection._search_successive_halving._SubsampleMetaSplitter" [color="black", fontcolor="black", label=<{_SubsampleMetaSplitter|base_cv<br ALIGN="LEFT"/>fraction<br ALIGN="LEFT"/>random_state<br ALIGN="LEFT"/>subsample_test<br ALIGN="LEFT"/>|split(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.base._UnstableArchMixin" [color="black", fontcolor="black", label=<{_UnstableArchMixin|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.model_selection._split._UnsupportedGroupCVMixin" [color="black", fontcolor="black", label=<{_UnsupportedGroupCVMixin|<br ALIGN="LEFT"/>|split(X, y, groups)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.linear_model._stochastic_gradient._ValidationScoreCallback" [color="black", fontcolor="black", label=<{_ValidationScoreCallback|X_val<br ALIGN="LEFT"/>estimator<br ALIGN="LEFT"/>sample_weight_val<br ALIGN="LEFT"/>y_val<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.feature_extraction.text._VectorizerMixin" [color="black", fontcolor="black", label=<{_VectorizerMixin|fixed_vocabulary_ : bool<br ALIGN="LEFT"/>vocabulary_ : dict<br ALIGN="LEFT"/>|build_analyzer()<br ALIGN="LEFT"/>build_preprocessor()<br ALIGN="LEFT"/>build_tokenizer()<br ALIGN="LEFT"/>decode(doc)<br ALIGN="LEFT"/>get_stop_words()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._param_validation._VerboseHelper" [color="black", fontcolor="black", label=<{_VerboseHelper|hidden : bool<br ALIGN="LEFT"/>|is_satisfied_by(val)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"sklearn.utils._estimator_html_repr._VisualBlock" [color="black", fontcolor="black", label=<{_VisualBlock|dash_wrapped : bool<br ALIGN="LEFT"/>doc_link_label : NoneType<br ALIGN="LEFT"/>estimators<br ALIGN="LEFT"/>kind<br ALIGN="LEFT"/>name_caption : NoneType<br ALIGN="LEFT"/>name_details : NoneType<br ALIGN="LEFT"/>names : NoneType<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._ridge._XT_CenterStackOp" [color="black", fontcolor="black", label=<{_XT_CenterStackOp|X<br ALIGN="LEFT"/>X_mean<br ALIGN="LEFT"/>sqrt_sw<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.linear_model._ridge._X_CenterStackOp" [color="black", fontcolor="black", label=<{_X_CenterStackOp|X<br ALIGN="LEFT"/>X_mean<br ALIGN="LEFT"/>sqrt_sw<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils._encode._nandict" [color="black", fontcolor="black", label=<{_nandict|nan_value<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.tests.test_metadata_routing.test_default_request_override.class_1" [color="black", fontcolor="black", label=<{class_1|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.deprecation.deprecated" [color="black", fontcolor="black", label=<{deprecated|extra : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.compose._column_transformer.make_column_selector" [color="black", fontcolor="black", label=<{make_column_selector|dtype_exclude : NoneType<br ALIGN="LEFT"/>dtype_include : NoneType<br ALIGN="LEFT"/>pattern : NoneType<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn.utils.parallel_backend" [color="black", fontcolor="black", label=<{parallel_backend|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"sklearn._loss.link.HalfLogitLink" -> "sklearn._loss.link.BaseLink" [arrowhead="empty", arrowtail="none"];
"sklearn._loss.link.IdentityLink" -> "sklearn._loss.link.BaseLink" [arrowhead="empty", arrowtail="none"];
"sklearn._loss.link.LogLink" -> "sklearn._loss.link.BaseLink" [arrowhead="empty", arrowtail="none"];
"sklearn._loss.link.LogitLink" -> "sklearn._loss.link.BaseLink" [arrowhead="empty", arrowtail="none"];
"sklearn._loss.link.MultinomialLogit" -> "sklearn._loss.link.BaseLink" [arrowhead="empty", arrowtail="none"];
"sklearn._loss.loss.AbsoluteError" -> "sklearn._loss.loss.BaseLoss" [arrowhead="empty", arrowtail="none"];
"sklearn._loss.loss.ExponentialLoss" -> "sklearn._loss.loss.BaseLoss" [arrowhead="empty", arrowtail="none"];
"sklearn._loss.loss.HalfBinomialLoss" -> "sklearn._loss.loss.BaseLoss" [arrowhead="empty", arrowtail="none"];
"sklearn._loss.loss.HalfGammaLoss" -> "sklearn._loss.loss.BaseLoss" [arrowhead="empty", arrowtail="none"];
"sklearn._loss.loss.HalfMultinomialLoss" -> "sklearn._loss.loss.BaseLoss" [arrowhead="empty", arrowtail="none"];
"sklearn._loss.loss.HalfPoissonLoss" -> "sklearn._loss.loss.BaseLoss" [arrowhead="empty", arrowtail="none"];
"sklearn._loss.loss.HalfSquaredError" -> "sklearn._loss.loss.BaseLoss" [arrowhead="empty", arrowtail="none"];
"sklearn._loss.loss.HalfTweedieLoss" -> "sklearn._loss.loss.BaseLoss" [arrowhead="empty", arrowtail="none"];
"sklearn._loss.loss.HalfTweedieLossIdentity" -> "sklearn._loss.loss.BaseLoss" [arrowhead="empty", arrowtail="none"];
"sklearn._loss.loss.HuberLoss" -> "sklearn._loss.loss.BaseLoss" [arrowhead="empty", arrowtail="none"];
"sklearn._loss.loss.PinballLoss" -> "sklearn._loss.loss.BaseLoss" [arrowhead="empty", arrowtail="none"];
"sklearn.base.BaseEstimator" -> "sklearn.utils._estimator_html_repr._HTMLDocumentationLinkMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.base.BaseEstimator" -> "sklearn.utils._metadata_requests._MetadataRequester" [arrowhead="empty", arrowtail="none"];
"sklearn.base.TransformerMixin" -> "sklearn.utils._set_output._SetOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.calibration.CalibratedClassifierCV" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.calibration.CalibratedClassifierCV" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.calibration.CalibratedClassifierCV" -> "sklearn.base.MetaEstimatorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.calibration.CalibrationDisplay" -> "sklearn.utils._plotting._BinaryClassifierCurveDisplayMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.calibration._SigmoidCalibration" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.calibration._SigmoidCalibration" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._affinity_propagation.AffinityPropagation" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._affinity_propagation.AffinityPropagation" -> "sklearn.base.ClusterMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._agglomerative.AgglomerativeClustering" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._agglomerative.AgglomerativeClustering" -> "sklearn.base.ClusterMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._agglomerative.FeatureAgglomeration" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._agglomerative.FeatureAgglomeration" -> "sklearn.cluster._agglomerative.AgglomerativeClustering" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._agglomerative.FeatureAgglomeration" -> "sklearn.cluster._feature_agglomeration.AgglomerationTransform" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._bicluster.BaseSpectral" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._bicluster.BaseSpectral" -> "sklearn.base.BiclusterMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._bicluster.SpectralBiclustering" -> "sklearn.cluster._bicluster.BaseSpectral" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._bicluster.SpectralCoclustering" -> "sklearn.cluster._bicluster.BaseSpectral" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._birch.Birch" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._birch.Birch" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._birch.Birch" -> "sklearn.base.ClusterMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._birch.Birch" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._bisect_k_means.BisectingKMeans" -> "sklearn.cluster._kmeans._BaseKMeans" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._dbscan.DBSCAN" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._dbscan.DBSCAN" -> "sklearn.base.ClusterMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._feature_agglomeration.AgglomerationTransform" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._hdbscan.hdbscan.HDBSCAN" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._hdbscan.hdbscan.HDBSCAN" -> "sklearn.base.ClusterMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._kmeans.KMeans" -> "sklearn.cluster._kmeans._BaseKMeans" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._kmeans.MiniBatchKMeans" -> "sklearn.cluster._kmeans._BaseKMeans" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._kmeans._BaseKMeans" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._kmeans._BaseKMeans" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._kmeans._BaseKMeans" -> "sklearn.base.ClusterMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._kmeans._BaseKMeans" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._mean_shift.MeanShift" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._mean_shift.MeanShift" -> "sklearn.base.ClusterMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._optics.OPTICS" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._optics.OPTICS" -> "sklearn.base.ClusterMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._spectral.SpectralClustering" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster._spectral.SpectralClustering" -> "sklearn.base.ClusterMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster.tests.test_bicluster.MockBiclustering" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.cluster.tests.test_bicluster.MockBiclustering" -> "sklearn.base.BiclusterMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.compose._column_transformer.ColumnTransformer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.compose._column_transformer.ColumnTransformer" -> "sklearn.utils.metaestimators._BaseComposition" [arrowhead="empty", arrowtail="none"];
"sklearn.compose._target.TransformedTargetRegressor" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.compose._target.TransformedTargetRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.compose.tests.test_column_transformer.DoubleTrans" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.compose.tests.test_column_transformer.PandasOutTransformer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.compose.tests.test_column_transformer.SparseMatrixTrans" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.compose.tests.test_column_transformer.Trans" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.compose.tests.test_column_transformer.Trans" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.compose.tests.test_column_transformer.TransNo2D" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.compose.tests.test_column_transformer.TransRaise" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.compose.tests.test_column_transformer.TransWithNames" -> "sklearn.compose.tests.test_column_transformer.Trans" [arrowhead="empty", arrowtail="none"];
"sklearn.compose.tests.test_column_transformer.test_column_transformer_dataframe.TransAssert" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.compose.tests.test_column_transformer.test_column_transformer_invalid_transformer.NoTrans" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.compose.tests.test_column_transformer.test_metadata_routing_no_fit_transform.NoFitTransform" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.compose.tests.test_target.DummyCheckerArrayTransformer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.compose.tests.test_target.DummyCheckerArrayTransformer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.compose.tests.test_target.DummyCheckerListRegressor" -> "sklearn.dummy.DummyRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.compose.tests.test_target.DummyRegressorWithExtraFitParams" -> "sklearn.dummy.DummyRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.compose.tests.test_target.DummyRegressorWithExtraPredictParams" -> "sklearn.dummy.DummyRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.compose.tests.test_target.DummyTransformer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.compose.tests.test_target.DummyTransformer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.covariance._elliptic_envelope.EllipticEnvelope" -> "sklearn.base.OutlierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.covariance._elliptic_envelope.EllipticEnvelope" -> "sklearn.covariance._robust_covariance.MinCovDet" [arrowhead="empty", arrowtail="none"];
"sklearn.covariance._empirical_covariance.EmpiricalCovariance" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.covariance._graph_lasso.BaseGraphicalLasso" -> "sklearn.covariance._empirical_covariance.EmpiricalCovariance" [arrowhead="empty", arrowtail="none"];
"sklearn.covariance._graph_lasso.GraphicalLasso" -> "sklearn.covariance._graph_lasso.BaseGraphicalLasso" [arrowhead="empty", arrowtail="none"];
"sklearn.covariance._graph_lasso.GraphicalLassoCV" -> "sklearn.covariance._graph_lasso.BaseGraphicalLasso" [arrowhead="empty", arrowtail="none"];
"sklearn.covariance._robust_covariance.MinCovDet" -> "sklearn.covariance._empirical_covariance.EmpiricalCovariance" [arrowhead="empty", arrowtail="none"];
"sklearn.covariance._shrunk_covariance.LedoitWolf" -> "sklearn.covariance._empirical_covariance.EmpiricalCovariance" [arrowhead="empty", arrowtail="none"];
"sklearn.covariance._shrunk_covariance.OAS" -> "sklearn.covariance._empirical_covariance.EmpiricalCovariance" [arrowhead="empty", arrowtail="none"];
"sklearn.covariance._shrunk_covariance.ShrunkCovariance" -> "sklearn.covariance._empirical_covariance.EmpiricalCovariance" [arrowhead="empty", arrowtail="none"];
"sklearn.cross_decomposition._pls.CCA" -> "sklearn.cross_decomposition._pls._PLS" [arrowhead="empty", arrowtail="none"];
"sklearn.cross_decomposition._pls.PLSCanonical" -> "sklearn.cross_decomposition._pls._PLS" [arrowhead="empty", arrowtail="none"];
"sklearn.cross_decomposition._pls.PLSRegression" -> "sklearn.cross_decomposition._pls._PLS" [arrowhead="empty", arrowtail="none"];
"sklearn.cross_decomposition._pls.PLSSVD" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.cross_decomposition._pls.PLSSVD" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cross_decomposition._pls.PLSSVD" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cross_decomposition._pls._PLS" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.cross_decomposition._pls._PLS" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cross_decomposition._pls._PLS" -> "sklearn.base.MultiOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cross_decomposition._pls._PLS" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.cross_decomposition._pls._PLS" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._base._BasePCA" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._base._BasePCA" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._base._BasePCA" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._dict_learning.DictionaryLearning" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._dict_learning.DictionaryLearning" -> "sklearn.decomposition._dict_learning._BaseSparseCoding" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._dict_learning.MiniBatchDictionaryLearning" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._dict_learning.MiniBatchDictionaryLearning" -> "sklearn.decomposition._dict_learning._BaseSparseCoding" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._dict_learning.SparseCoder" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._dict_learning.SparseCoder" -> "sklearn.decomposition._dict_learning._BaseSparseCoding" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._dict_learning._BaseSparseCoding" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._dict_learning._BaseSparseCoding" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._factor_analysis.FactorAnalysis" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._factor_analysis.FactorAnalysis" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._factor_analysis.FactorAnalysis" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._fastica.FastICA" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._fastica.FastICA" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._fastica.FastICA" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._incremental_pca.IncrementalPCA" -> "sklearn.decomposition._base._BasePCA" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._kernel_pca.KernelPCA" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._kernel_pca.KernelPCA" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._kernel_pca.KernelPCA" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._lda.LatentDirichletAllocation" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._lda.LatentDirichletAllocation" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._lda.LatentDirichletAllocation" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._nmf.MiniBatchNMF" -> "sklearn.decomposition._nmf._BaseNMF" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._nmf.NMF" -> "sklearn.decomposition._nmf._BaseNMF" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._nmf._BaseNMF" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._nmf._BaseNMF" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._nmf._BaseNMF" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._pca.PCA" -> "sklearn.decomposition._base._BasePCA" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._sparse_pca.MiniBatchSparsePCA" -> "sklearn.decomposition._sparse_pca._BaseSparsePCA" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._sparse_pca.SparsePCA" -> "sklearn.decomposition._sparse_pca._BaseSparsePCA" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._sparse_pca._BaseSparsePCA" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._sparse_pca._BaseSparsePCA" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._sparse_pca._BaseSparsePCA" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._truncated_svd.TruncatedSVD" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._truncated_svd.TruncatedSVD" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.decomposition._truncated_svd.TruncatedSVD" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.discriminant_analysis.LinearDiscriminantAnalysis" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.discriminant_analysis.LinearDiscriminantAnalysis" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.discriminant_analysis.LinearDiscriminantAnalysis" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.discriminant_analysis.LinearDiscriminantAnalysis" -> "sklearn.linear_model._base.LinearClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.discriminant_analysis.QuadraticDiscriminantAnalysis" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.discriminant_analysis.QuadraticDiscriminantAnalysis" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.discriminant_analysis.QuadraticDiscriminantAnalysis" -> "sklearn.discriminant_analysis.DiscriminantAnalysisPredictionMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.dummy.DummyClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.dummy.DummyClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.dummy.DummyClassifier" -> "sklearn.base.MultiOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.dummy.DummyRegressor" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.dummy.DummyRegressor" -> "sklearn.base.MultiOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.dummy.DummyRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._bagging.BaggingClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._bagging.BaggingClassifier" -> "sklearn.ensemble._bagging.BaseBagging" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._bagging.BaggingRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._bagging.BaggingRegressor" -> "sklearn.ensemble._bagging.BaseBagging" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._bagging.BaseBagging" -> "sklearn.ensemble._base.BaseEnsemble" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._base.BaseEnsemble" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._base.BaseEnsemble" -> "sklearn.base.MetaEstimatorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._base._BaseHeterogeneousEnsemble" -> "sklearn.base.MetaEstimatorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._base._BaseHeterogeneousEnsemble" -> "sklearn.utils.metaestimators._BaseComposition" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._forest.BaseForest" -> "sklearn.base.MultiOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._forest.BaseForest" -> "sklearn.ensemble._base.BaseEnsemble" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._forest.ExtraTreesClassifier" -> "sklearn.ensemble._forest.ForestClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._forest.ExtraTreesRegressor" -> "sklearn.ensemble._forest.ForestRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._forest.ForestClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._forest.ForestClassifier" -> "sklearn.ensemble._forest.BaseForest" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._forest.ForestRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._forest.ForestRegressor" -> "sklearn.ensemble._forest.BaseForest" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._forest.RandomForestClassifier" -> "sklearn.ensemble._forest.ForestClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._forest.RandomForestRegressor" -> "sklearn.ensemble._forest.ForestRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._forest.RandomTreesEmbedding" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._forest.RandomTreesEmbedding" -> "sklearn.ensemble._forest.BaseForest" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._gb.BaseGradientBoosting" -> "sklearn.ensemble._base.BaseEnsemble" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._gb.GradientBoostingClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._gb.GradientBoostingClassifier" -> "sklearn.ensemble._gb.BaseGradientBoosting" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._gb.GradientBoostingRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._gb.GradientBoostingRegressor" -> "sklearn.ensemble._gb.BaseGradientBoosting" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._hist_gradient_boosting.binning._BinMapper" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._hist_gradient_boosting.binning._BinMapper" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._hist_gradient_boosting.gradient_boosting.BaseHistGradientBoosting" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._hist_gradient_boosting.gradient_boosting.HistGradientBoostingClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._hist_gradient_boosting.gradient_boosting.HistGradientBoostingClassifier" -> "sklearn.ensemble._hist_gradient_boosting.gradient_boosting.BaseHistGradientBoosting" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._hist_gradient_boosting.gradient_boosting.HistGradientBoostingRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._hist_gradient_boosting.gradient_boosting.HistGradientBoostingRegressor" -> "sklearn.ensemble._hist_gradient_boosting.gradient_boosting.BaseHistGradientBoosting" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._hist_gradient_boosting.tests.test_gradient_boosting.test_missing_values_minmax_imputation.MinMaxImputer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._hist_gradient_boosting.tests.test_gradient_boosting.test_missing_values_minmax_imputation.MinMaxImputer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._iforest.IsolationForest" -> "sklearn.base.OutlierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._iforest.IsolationForest" -> "sklearn.ensemble._bagging.BaseBagging" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._stacking.StackingClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._stacking.StackingClassifier" -> "sklearn.ensemble._stacking._BaseStacking" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._stacking.StackingRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._stacking.StackingRegressor" -> "sklearn.ensemble._stacking._BaseStacking" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._stacking._BaseStacking" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._stacking._BaseStacking" -> "sklearn.ensemble._base._BaseHeterogeneousEnsemble" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._voting.VotingClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._voting.VotingClassifier" -> "sklearn.ensemble._voting._BaseVoting" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._voting.VotingRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._voting.VotingRegressor" -> "sklearn.ensemble._voting._BaseVoting" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._voting._BaseVoting" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._voting._BaseVoting" -> "sklearn.ensemble._base._BaseHeterogeneousEnsemble" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._weight_boosting.AdaBoostClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._weight_boosting.AdaBoostClassifier" -> "sklearn.ensemble._weight_boosting.BaseWeightBoosting" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._weight_boosting.AdaBoostClassifier" -> "sklearn.utils._metadata_requests._RoutingNotSupportedMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._weight_boosting.AdaBoostRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._weight_boosting.AdaBoostRegressor" -> "sklearn.ensemble._weight_boosting.BaseWeightBoosting" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._weight_boosting.AdaBoostRegressor" -> "sklearn.utils._metadata_requests._RoutingNotSupportedMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble._weight_boosting.BaseWeightBoosting" -> "sklearn.ensemble._base.BaseEnsemble" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble.tests.test_bagging.DummySizeEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble.tests.test_bagging.DummyZeroEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble.tests.test_bagging.test_bagging_get_estimators_indices.MyEstimator" -> "sklearn.tree._classes.DecisionTreeRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble.tests.test_bagging.test_sparse_classification.CustomSVC" -> "sklearn.svm._classes.SVC" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble.tests.test_bagging.test_sparse_regression.CustomSVR" -> "sklearn.svm._classes.SVR" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble.tests.test_base.test_set_random_states.AlphaParamPipeline" -> "sklearn.pipeline.Pipeline" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble.tests.test_base.test_set_random_states.RevParamPipeline" -> "sklearn.pipeline.Pipeline" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble.tests.test_stacking.NoWeightClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble.tests.test_stacking.NoWeightClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble.tests.test_stacking.NoWeightRegressor" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble.tests.test_stacking.NoWeightRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble.tests.test_voting.test_sample_weight.ClassifierErrorFit" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble.tests.test_voting.test_sample_weight.ClassifierErrorFit" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble.tests.test_voting.test_sample_weight_kwargs.MockClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble.tests.test_voting.test_sample_weight_kwargs.MockClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble.tests.test_weight_boosting.test_sample_weight_adaboost_regressor.DummyEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble.tests.test_weight_boosting.test_sparse_classification.CustomSVC" -> "sklearn.svm._classes.SVC" [arrowhead="empty", arrowtail="none"];
"sklearn.ensemble.tests.test_weight_boosting.test_sparse_regression.CustomSVR" -> "sklearn.svm._classes.SVR" [arrowhead="empty", arrowtail="none"];
"sklearn.externals._arff.BadAttributeFormat" -> "sklearn.externals._arff.ArffException" [arrowhead="empty", arrowtail="none"];
"sklearn.externals._arff.BadAttributeName" -> "sklearn.externals._arff.ArffException" [arrowhead="empty", arrowtail="none"];
"sklearn.externals._arff.BadAttributeType" -> "sklearn.externals._arff.ArffException" [arrowhead="empty", arrowtail="none"];
"sklearn.externals._arff.BadDataFormat" -> "sklearn.externals._arff.ArffException" [arrowhead="empty", arrowtail="none"];
"sklearn.externals._arff.BadLayout" -> "sklearn.externals._arff.ArffException" [arrowhead="empty", arrowtail="none"];
"sklearn.externals._arff.BadNominalFormatting" -> "sklearn.externals._arff.ArffException" [arrowhead="empty", arrowtail="none"];
"sklearn.externals._arff.BadNominalValue" -> "sklearn.externals._arff.ArffException" [arrowhead="empty", arrowtail="none"];
"sklearn.externals._arff.BadNumericalValue" -> "sklearn.externals._arff.ArffException" [arrowhead="empty", arrowtail="none"];
"sklearn.externals._arff.BadObject" -> "sklearn.externals._arff.ArffException" [arrowhead="empty", arrowtail="none"];
"sklearn.externals._arff.BadRelationFormat" -> "sklearn.externals._arff.ArffException" [arrowhead="empty", arrowtail="none"];
"sklearn.externals._arff.BadStringValue" -> "sklearn.externals._arff.ArffException" [arrowhead="empty", arrowtail="none"];
"sklearn.externals._arff.Data" -> "sklearn.externals._arff.DenseGeneratorData" [arrowhead="empty", arrowtail="none"];
"sklearn.externals._arff.Data" -> "sklearn.externals._arff._DataListMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.externals._arff.LODData" -> "sklearn.externals._arff.LODGeneratorData" [arrowhead="empty", arrowtail="none"];
"sklearn.externals._arff.LODData" -> "sklearn.externals._arff._DataListMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.externals._packaging.version.LegacyVersion" -> "sklearn.externals._packaging.version._BaseVersion" [arrowhead="empty", arrowtail="none"];
"sklearn.externals._packaging.version.Version" -> "sklearn.externals._packaging.version._BaseVersion" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_extraction._dict_vectorizer.DictVectorizer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_extraction._dict_vectorizer.DictVectorizer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_extraction._hash.FeatureHasher" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_extraction._hash.FeatureHasher" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_extraction.image.PatchExtractor" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_extraction.image.PatchExtractor" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_extraction.text.CountVectorizer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_extraction.text.CountVectorizer" -> "sklearn.feature_extraction.text._VectorizerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_extraction.text.HashingVectorizer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_extraction.text.HashingVectorizer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_extraction.text.HashingVectorizer" -> "sklearn.feature_extraction.text._VectorizerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_extraction.text.TfidfTransformer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_extraction.text.TfidfTransformer" -> "sklearn.base.OneToOneFeatureMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_extraction.text.TfidfTransformer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_extraction.text.TfidfVectorizer" -> "sklearn.feature_extraction.text.CountVectorizer" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection._base.SelectorMixin" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection._from_model.SelectFromModel" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection._from_model.SelectFromModel" -> "sklearn.base.MetaEstimatorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection._from_model.SelectFromModel" -> "sklearn.feature_selection._base.SelectorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection._rfe.RFE" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection._rfe.RFE" -> "sklearn.base.MetaEstimatorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection._rfe.RFE" -> "sklearn.feature_selection._base.SelectorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection._rfe.RFECV" -> "sklearn.feature_selection._rfe.RFE" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection._sequential.SequentialFeatureSelector" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection._sequential.SequentialFeatureSelector" -> "sklearn.base.MetaEstimatorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection._sequential.SequentialFeatureSelector" -> "sklearn.feature_selection._base.SelectorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection._univariate_selection.GenericUnivariateSelect" -> "sklearn.feature_selection._univariate_selection._BaseFilter" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection._univariate_selection.SelectFdr" -> "sklearn.feature_selection._univariate_selection._BaseFilter" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection._univariate_selection.SelectFpr" -> "sklearn.feature_selection._univariate_selection._BaseFilter" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection._univariate_selection.SelectFwe" -> "sklearn.feature_selection._univariate_selection._BaseFilter" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection._univariate_selection.SelectKBest" -> "sklearn.feature_selection._univariate_selection._BaseFilter" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection._univariate_selection.SelectPercentile" -> "sklearn.feature_selection._univariate_selection._BaseFilter" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection._univariate_selection._BaseFilter" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection._univariate_selection._BaseFilter" -> "sklearn.feature_selection._base.SelectorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection._variance_threshold.VarianceThreshold" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection._variance_threshold.VarianceThreshold" -> "sklearn.feature_selection._base.SelectorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection.tests.test_base.StepSelector" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection.tests.test_base.StepSelector" -> "sklearn.feature_selection._base.SelectorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection.tests.test_from_model.FixedImportanceEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection.tests.test_from_model.NaNTag" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection.tests.test_from_model.NaNTagRandomForest" -> "sklearn.ensemble._forest.RandomForestClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection.tests.test_from_model.NoNaNTag" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection.tests.test_rfe.MockClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection.tests.test_rfe.MockClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection.tests.test_rfe.test_RFE_fit_score_params.TestEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.feature_selection.tests.test_rfe.test_RFE_fit_score_params.TestEstimator" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.frozen._frozen.FrozenEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.frozen.tests.test_frozen.test_composite_fit.Estimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.frozen.tests.test_frozen.test_frozen_metadata_routing.ConsumesMetadata" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.frozen.tests.test_frozen.test_frozen_tags.Estimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process._gpc.GaussianProcessClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process._gpc.GaussianProcessClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process._gpc._BinaryGaussianProcessClassifierLaplace" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process._gpr.GaussianProcessRegressor" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process._gpr.GaussianProcessRegressor" -> "sklearn.base.MultiOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process._gpr.GaussianProcessRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.CompoundKernel" -> "sklearn.gaussian_process.kernels.Kernel" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.ConstantKernel" -> "sklearn.gaussian_process.kernels.GenericKernelMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.ConstantKernel" -> "sklearn.gaussian_process.kernels.Kernel" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.ConstantKernel" -> "sklearn.gaussian_process.kernels.StationaryKernelMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.DotProduct" -> "sklearn.gaussian_process.kernels.Kernel" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.ExpSineSquared" -> "sklearn.gaussian_process.kernels.Kernel" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.ExpSineSquared" -> "sklearn.gaussian_process.kernels.NormalizedKernelMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.ExpSineSquared" -> "sklearn.gaussian_process.kernels.StationaryKernelMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.Exponentiation" -> "sklearn.gaussian_process.kernels.Kernel" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.KernelOperator" -> "sklearn.gaussian_process.kernels.Kernel" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.Matern" -> "sklearn.gaussian_process.kernels.RBF" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.PairwiseKernel" -> "sklearn.gaussian_process.kernels.Kernel" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.Product" -> "sklearn.gaussian_process.kernels.KernelOperator" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.RBF" -> "sklearn.gaussian_process.kernels.Kernel" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.RBF" -> "sklearn.gaussian_process.kernels.NormalizedKernelMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.RBF" -> "sklearn.gaussian_process.kernels.StationaryKernelMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.RationalQuadratic" -> "sklearn.gaussian_process.kernels.Kernel" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.RationalQuadratic" -> "sklearn.gaussian_process.kernels.NormalizedKernelMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.RationalQuadratic" -> "sklearn.gaussian_process.kernels.StationaryKernelMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.Sum" -> "sklearn.gaussian_process.kernels.KernelOperator" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.WhiteKernel" -> "sklearn.gaussian_process.kernels.GenericKernelMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.WhiteKernel" -> "sklearn.gaussian_process.kernels.Kernel" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.kernels.WhiteKernel" -> "sklearn.gaussian_process.kernels.StationaryKernelMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.tests._mini_sequence_kernel.MiniSeqKernel" -> "sklearn.gaussian_process.kernels.GenericKernelMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.tests._mini_sequence_kernel.MiniSeqKernel" -> "sklearn.gaussian_process.kernels.Kernel" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.tests._mini_sequence_kernel.MiniSeqKernel" -> "sklearn.gaussian_process.kernels.StationaryKernelMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.gaussian_process.tests.test_gpr.CustomKernel" -> "sklearn.gaussian_process.kernels.ConstantKernel" [arrowhead="empty", arrowtail="none"];
"sklearn.impute._base.MissingIndicator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.impute._base.MissingIndicator" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.impute._base.SimpleImputer" -> "sklearn.impute._base._BaseImputer" [arrowhead="empty", arrowtail="none"];
"sklearn.impute._base._BaseImputer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.impute._base._BaseImputer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.impute._iterative.IterativeImputer" -> "sklearn.impute._base._BaseImputer" [arrowhead="empty", arrowtail="none"];
"sklearn.impute._knn.KNNImputer" -> "sklearn.impute._base._BaseImputer" [arrowhead="empty", arrowtail="none"];
"sklearn.impute.tests.test_base.NoFitIndicatorImputer" -> "sklearn.impute._base._BaseImputer" [arrowhead="empty", arrowtail="none"];
"sklearn.impute.tests.test_base.NoPrecomputedMaskFit" -> "sklearn.impute._base._BaseImputer" [arrowhead="empty", arrowtail="none"];
"sklearn.impute.tests.test_base.NoPrecomputedMaskTransform" -> "sklearn.impute._base._BaseImputer" [arrowhead="empty", arrowtail="none"];
"sklearn.impute.tests.test_base.NoTransformIndicatorImputer" -> "sklearn.impute._base._BaseImputer" [arrowhead="empty", arrowtail="none"];
"sklearn.inspection._plot.tests.test_boundary_decision_display.test_error_bad_response.MyClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.inspection._plot.tests.test_boundary_decision_display.test_error_bad_response.MyClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.inspection._plot.tests.test_boundary_decision_display.test_subclass_named_constructors_return_type_is_subclass.SubclassOfDisplay" -> "sklearn.inspection._plot.decision_boundary.DecisionBoundaryDisplay" [arrowhead="empty", arrowtail="none"];
"sklearn.inspection._plot.tests.test_plot_partial_dependence.test_subclass_named_constructors_return_type_is_subclass.SubclassOfDisplay" -> "sklearn.inspection._plot.partial_dependence.PartialDependenceDisplay" [arrowhead="empty", arrowtail="none"];
"sklearn.inspection.tests.test_partial_dependence.NoPredictProbaNoDecisionFunction" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.inspection.tests.test_partial_dependence.NoPredictProbaNoDecisionFunction" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.isotonic.IsotonicRegression" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.isotonic.IsotonicRegression" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.isotonic.IsotonicRegression" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.kernel_approximation.AdditiveChi2Sampler" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.kernel_approximation.AdditiveChi2Sampler" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.kernel_approximation.Nystroem" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.kernel_approximation.Nystroem" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.kernel_approximation.Nystroem" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.kernel_approximation.PolynomialCountSketch" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.kernel_approximation.PolynomialCountSketch" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.kernel_approximation.PolynomialCountSketch" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.kernel_approximation.RBFSampler" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.kernel_approximation.RBFSampler" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.kernel_approximation.RBFSampler" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.kernel_approximation.SkewedChi2Sampler" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.kernel_approximation.SkewedChi2Sampler" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.kernel_approximation.SkewedChi2Sampler" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.kernel_ridge.KernelRidge" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.kernel_ridge.KernelRidge" -> "sklearn.base.MultiOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.kernel_ridge.KernelRidge" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._base.LinearClassifierMixin" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._base.LinearModel" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._base.LinearRegression" -> "sklearn.base.MultiOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._base.LinearRegression" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._base.LinearRegression" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._bayes.ARDRegression" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._bayes.ARDRegression" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._bayes.BayesianRidge" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._bayes.BayesianRidge" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.ElasticNet" -> "sklearn.base.MultiOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.ElasticNet" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.ElasticNet" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.ElasticNetCV" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.ElasticNetCV" -> "sklearn.linear_model._coordinate_descent.LinearModelCV" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.Lasso" -> "sklearn.linear_model._coordinate_descent.ElasticNet" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.LassoCV" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.LassoCV" -> "sklearn.linear_model._coordinate_descent.LinearModelCV" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.LinearModelCV" -> "sklearn.base.MultiOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.LinearModelCV" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.MultiTaskElasticNet" -> "sklearn.linear_model._coordinate_descent.Lasso" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.MultiTaskElasticNetCV" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.MultiTaskElasticNetCV" -> "sklearn.linear_model._coordinate_descent.LinearModelCV" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.MultiTaskLasso" -> "sklearn.linear_model._coordinate_descent.MultiTaskElasticNet" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.MultiTaskLassoCV" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._coordinate_descent.MultiTaskLassoCV" -> "sklearn.linear_model._coordinate_descent.LinearModelCV" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._glm._newton_solver.NewtonCholeskySolver" -> "sklearn.linear_model._glm._newton_solver.NewtonSolver" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._glm.glm.GammaRegressor" -> "sklearn.linear_model._glm.glm._GeneralizedLinearRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._glm.glm.PoissonRegressor" -> "sklearn.linear_model._glm.glm._GeneralizedLinearRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._glm.glm.TweedieRegressor" -> "sklearn.linear_model._glm.glm._GeneralizedLinearRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._glm.glm._GeneralizedLinearRegressor" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._glm.glm._GeneralizedLinearRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._glm.tests.test_glm.BinomialRegressor" -> "sklearn.linear_model._glm.glm._GeneralizedLinearRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._huber.HuberRegressor" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._huber.HuberRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._huber.HuberRegressor" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._least_angle.Lars" -> "sklearn.base.MultiOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._least_angle.Lars" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._least_angle.Lars" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._least_angle.LarsCV" -> "sklearn.linear_model._least_angle.Lars" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._least_angle.LassoLars" -> "sklearn.linear_model._least_angle.Lars" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._least_angle.LassoLarsCV" -> "sklearn.linear_model._least_angle.LarsCV" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._least_angle.LassoLarsIC" -> "sklearn.linear_model._least_angle.LassoLars" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._logistic.LogisticRegression" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._logistic.LogisticRegression" -> "sklearn.linear_model._base.LinearClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._logistic.LogisticRegression" -> "sklearn.linear_model._base.SparseCoefMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._logistic.LogisticRegressionCV" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._logistic.LogisticRegressionCV" -> "sklearn.linear_model._base.LinearClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._logistic.LogisticRegressionCV" -> "sklearn.linear_model._logistic.LogisticRegression" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._omp.OrthogonalMatchingPursuit" -> "sklearn.base.MultiOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._omp.OrthogonalMatchingPursuit" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._omp.OrthogonalMatchingPursuit" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._omp.OrthogonalMatchingPursuitCV" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._omp.OrthogonalMatchingPursuitCV" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._passive_aggressive.PassiveAggressiveClassifier" -> "sklearn.linear_model._stochastic_gradient.BaseSGDClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._passive_aggressive.PassiveAggressiveRegressor" -> "sklearn.linear_model._stochastic_gradient.BaseSGDRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._perceptron.Perceptron" -> "sklearn.linear_model._stochastic_gradient.BaseSGDClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._quantile.QuantileRegressor" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._quantile.QuantileRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._quantile.QuantileRegressor" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ransac.RANSACRegressor" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ransac.RANSACRegressor" -> "sklearn.base.MetaEstimatorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ransac.RANSACRegressor" -> "sklearn.base.MultiOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ransac.RANSACRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge.Ridge" -> "sklearn.base.MultiOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge.Ridge" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge.Ridge" -> "sklearn.linear_model._ridge._BaseRidge" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge.RidgeCV" -> "sklearn.base.MultiOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge.RidgeCV" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge.RidgeCV" -> "sklearn.linear_model._ridge._BaseRidgeCV" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge.RidgeClassifier" -> "sklearn.linear_model._ridge._BaseRidge" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge.RidgeClassifier" -> "sklearn.linear_model._ridge._RidgeClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge.RidgeClassifierCV" -> "sklearn.linear_model._ridge._BaseRidgeCV" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge.RidgeClassifierCV" -> "sklearn.linear_model._ridge._RidgeClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge._BaseRidge" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge._BaseRidgeCV" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge._IdentityClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge._IdentityClassifier" -> "sklearn.linear_model._base.LinearClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge._IdentityRegressor" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge._IdentityRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge._RidgeClassifierMixin" -> "sklearn.linear_model._base.LinearClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._ridge._RidgeGCV" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._stochastic_gradient.BaseSGD" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._stochastic_gradient.BaseSGD" -> "sklearn.linear_model._base.SparseCoefMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._stochastic_gradient.BaseSGDClassifier" -> "sklearn.linear_model._base.LinearClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._stochastic_gradient.BaseSGDClassifier" -> "sklearn.linear_model._stochastic_gradient.BaseSGD" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._stochastic_gradient.BaseSGDRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._stochastic_gradient.BaseSGDRegressor" -> "sklearn.linear_model._stochastic_gradient.BaseSGD" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._stochastic_gradient.SGDClassifier" -> "sklearn.linear_model._stochastic_gradient.BaseSGDClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._stochastic_gradient.SGDOneClassSVM" -> "sklearn.base.OutlierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._stochastic_gradient.SGDOneClassSVM" -> "sklearn.linear_model._stochastic_gradient.BaseSGD" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._stochastic_gradient.SGDRegressor" -> "sklearn.linear_model._stochastic_gradient.BaseSGDRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._theil_sen.TheilSenRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model._theil_sen.TheilSenRegressor" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model.tests.test_coordinate_descent.test_lassoCV_does_not_set_precompute.LassoMock" -> "sklearn.linear_model._coordinate_descent.Lasso" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model.tests.test_coordinate_descent.test_multitask_cv_estimators_with_sample_weight.CVSplitter" -> "sklearn.model_selection._split.BaseCrossValidator" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model.tests.test_coordinate_descent.test_multitask_cv_estimators_with_sample_weight.CVSplitter" -> "sklearn.model_selection._split.GroupsConsumerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model.tests.test_coordinate_descent.test_multitask_cv_estimators_with_sample_weight.CVSplitterSampleWeight" -> "sklearn.linear_model.tests.test_coordinate_descent.test_multitask_cv_estimators_with_sample_weight.CVSplitter" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model.tests.test_passive_aggressive.MyPassiveAggressive" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model.tests.test_sgd._SparseSGDClassifier" -> "sklearn.linear_model._stochastic_gradient.SGDClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model.tests.test_sgd._SparseSGDOneClassSVM" -> "sklearn.linear_model._stochastic_gradient.SGDOneClassSVM" [arrowhead="empty", arrowtail="none"];
"sklearn.linear_model.tests.test_sgd._SparseSGDRegressor" -> "sklearn.linear_model._stochastic_gradient.SGDRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.manifold._isomap.Isomap" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.manifold._isomap.Isomap" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.manifold._isomap.Isomap" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.manifold._locally_linear.LocallyLinearEmbedding" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.manifold._locally_linear.LocallyLinearEmbedding" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.manifold._locally_linear.LocallyLinearEmbedding" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.manifold._locally_linear.LocallyLinearEmbedding" -> "sklearn.base._UnstableArchMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.manifold._mds.MDS" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.manifold._spectral_embedding.SpectralEmbedding" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.manifold._t_sne.TSNE" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.manifold._t_sne.TSNE" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.manifold._t_sne.TSNE" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.metrics._pairwise_distances_reduction._dispatcher.ArgKmin" -> "sklearn.metrics._pairwise_distances_reduction._dispatcher.BaseDistancesReductionDispatcher" [arrowhead="empty", arrowtail="none"];
"sklearn.metrics._pairwise_distances_reduction._dispatcher.ArgKminClassMode" -> "sklearn.metrics._pairwise_distances_reduction._dispatcher.BaseDistancesReductionDispatcher" [arrowhead="empty", arrowtail="none"];
"sklearn.metrics._pairwise_distances_reduction._dispatcher.RadiusNeighbors" -> "sklearn.metrics._pairwise_distances_reduction._dispatcher.BaseDistancesReductionDispatcher" [arrowhead="empty", arrowtail="none"];
"sklearn.metrics._pairwise_distances_reduction._dispatcher.RadiusNeighborsClassMode" -> "sklearn.metrics._pairwise_distances_reduction._dispatcher.BaseDistancesReductionDispatcher" [arrowhead="empty", arrowtail="none"];
"sklearn.metrics._plot.det_curve.DetCurveDisplay" -> "sklearn.utils._plotting._BinaryClassifierCurveDisplayMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.metrics._plot.precision_recall_curve.PrecisionRecallDisplay" -> "sklearn.utils._plotting._BinaryClassifierCurveDisplayMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.metrics._plot.roc_curve.RocCurveDisplay" -> "sklearn.utils._plotting._BinaryClassifierCurveDisplayMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.metrics._plot.tests.test_common_curve_display.test_display_curve_error_no_response.MyClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.metrics._plot.tests.test_common_curve_display.test_display_curve_error_no_response.MyClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.metrics._scorer._BaseScorer" -> "sklearn.utils._metadata_requests._MetadataRequester" [arrowhead="empty", arrowtail="none"];
"sklearn.metrics._scorer._CurveScorer" -> "sklearn.metrics._scorer._BaseScorer" [arrowhead="empty", arrowtail="none"];
"sklearn.metrics._scorer._PassthroughScorer" -> "sklearn.utils._metadata_requests._MetadataRequester" [arrowhead="empty", arrowtail="none"];
"sklearn.metrics._scorer._Scorer" -> "sklearn.metrics._scorer._BaseScorer" [arrowhead="empty", arrowtail="none"];
"sklearn.metrics.tests.test_score_objects.EstimatorWithFit" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.metrics.tests.test_score_objects.EstimatorWithFitAndPredict" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.metrics.tests.test_score_objects.EstimatorWithFitAndScore" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.metrics.tests.test_score_objects.test_multimetric_scorer_calls_method_once.MyClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.metrics.tests.test_score_objects.test_multimetric_scorer_calls_method_once.MyClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.metrics.tests.test_score_objects.test_multimetric_scorer_calls_method_once_classifier_no_decision.MockKNeighborsClassifier" -> "sklearn.neighbors._classification.KNeighborsClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.metrics.tests.test_score_objects.test_multimetric_scorer_calls_method_once_regressor_threshold.MockDecisionTreeRegressor" -> "sklearn.tree._classes.DecisionTreeRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.mixture._base.BaseMixture" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.mixture._base.BaseMixture" -> "sklearn.base.DensityMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.mixture._bayesian_mixture.BayesianGaussianMixture" -> "sklearn.mixture._base.BaseMixture" [arrowhead="empty", arrowtail="none"];
"sklearn.mixture._gaussian_mixture.GaussianMixture" -> "sklearn.mixture._base.BaseMixture" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._classification_threshold.BaseThresholdClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._classification_threshold.BaseThresholdClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._classification_threshold.BaseThresholdClassifier" -> "sklearn.base.MetaEstimatorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._classification_threshold.FixedThresholdClassifier" -> "sklearn.model_selection._classification_threshold.BaseThresholdClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._classification_threshold.TunedThresholdClassifierCV" -> "sklearn.model_selection._classification_threshold.BaseThresholdClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._plot.LearningCurveDisplay" -> "sklearn.model_selection._plot._BaseCurveDisplay" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._plot.ValidationCurveDisplay" -> "sklearn.model_selection._plot._BaseCurveDisplay" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._search.BaseSearchCV" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._search.BaseSearchCV" -> "sklearn.base.MetaEstimatorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._search.GridSearchCV" -> "sklearn.model_selection._search.BaseSearchCV" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._search.RandomizedSearchCV" -> "sklearn.model_selection._search.BaseSearchCV" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._search_successive_halving.BaseSuccessiveHalving" -> "sklearn.model_selection._search.BaseSearchCV" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._search_successive_halving.HalvingGridSearchCV" -> "sklearn.model_selection._search_successive_halving.BaseSuccessiveHalving" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._search_successive_halving.HalvingRandomSearchCV" -> "sklearn.model_selection._search_successive_halving.BaseSuccessiveHalving" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.BaseCrossValidator" -> "sklearn.utils._metadata_requests._MetadataRequester" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.BaseShuffleSplit" -> "sklearn.utils._metadata_requests._MetadataRequester" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.GroupKFold" -> "sklearn.model_selection._split.GroupsConsumerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.GroupKFold" -> "sklearn.model_selection._split._BaseKFold" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.GroupShuffleSplit" -> "sklearn.model_selection._split.BaseShuffleSplit" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.GroupShuffleSplit" -> "sklearn.model_selection._split.GroupsConsumerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.GroupsConsumerMixin" -> "sklearn.utils._metadata_requests._MetadataRequester" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.KFold" -> "sklearn.model_selection._split._BaseKFold" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.KFold" -> "sklearn.model_selection._split._UnsupportedGroupCVMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.LeaveOneGroupOut" -> "sklearn.model_selection._split.BaseCrossValidator" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.LeaveOneGroupOut" -> "sklearn.model_selection._split.GroupsConsumerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.LeaveOneOut" -> "sklearn.model_selection._split.BaseCrossValidator" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.LeaveOneOut" -> "sklearn.model_selection._split._UnsupportedGroupCVMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.LeavePGroupsOut" -> "sklearn.model_selection._split.BaseCrossValidator" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.LeavePGroupsOut" -> "sklearn.model_selection._split.GroupsConsumerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.LeavePOut" -> "sklearn.model_selection._split.BaseCrossValidator" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.LeavePOut" -> "sklearn.model_selection._split._UnsupportedGroupCVMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.PredefinedSplit" -> "sklearn.model_selection._split.BaseCrossValidator" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.RepeatedKFold" -> "sklearn.model_selection._split._RepeatedSplits" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.RepeatedKFold" -> "sklearn.model_selection._split._UnsupportedGroupCVMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.RepeatedStratifiedKFold" -> "sklearn.model_selection._split._RepeatedSplits" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.RepeatedStratifiedKFold" -> "sklearn.model_selection._split._UnsupportedGroupCVMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.ShuffleSplit" -> "sklearn.model_selection._split.BaseShuffleSplit" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.ShuffleSplit" -> "sklearn.model_selection._split._UnsupportedGroupCVMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.StratifiedGroupKFold" -> "sklearn.model_selection._split.GroupsConsumerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.StratifiedGroupKFold" -> "sklearn.model_selection._split._BaseKFold" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.StratifiedKFold" -> "sklearn.model_selection._split._BaseKFold" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.StratifiedShuffleSplit" -> "sklearn.model_selection._split.BaseShuffleSplit" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split.TimeSeriesSplit" -> "sklearn.model_selection._split._BaseKFold" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split._BaseKFold" -> "sklearn.model_selection._split.BaseCrossValidator" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split._CVIterableWrapper" -> "sklearn.model_selection._split.BaseCrossValidator" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection._split._RepeatedSplits" -> "sklearn.utils._metadata_requests._MetadataRequester" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_search.BrokenClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_search.FailingClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_search.LinearSVCNoScore" -> "sklearn.svm._classes.LinearSVC" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_search.MockClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_search.MockClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_search.test__custom_fit_no_run_search.BadSearchCV" -> "sklearn.model_selection._search.BaseSearchCV" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_search.test__custom_fit_no_run_search.NoRunSearchSearchCV" -> "sklearn.model_selection._search.BaseSearchCV" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_search.test_custom_run_search.CustomSearchCV" -> "sklearn.model_selection._search.BaseSearchCV" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_search.test_cv_results_dtype_issue_29074.MetaEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_search.test_cv_results_dtype_issue_29074.MetaEstimator" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_search.test_random_search_bad_cv.BrokenKFold" -> "sklearn.model_selection._split.KFold" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_search.test_scalar_fit_param.TestEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_search.test_scalar_fit_param.TestEstimator" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_search.test_scalar_fit_param_compat._FitParamClassifier" -> "sklearn.linear_model._stochastic_gradient.SGDClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_search.test_search_cv__pairwise_property_delegated_to_base_estimator.EstimatorPairwise" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_search.test_search_cv_pairwise_property_delegated_to_base_estimator.TestEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_successive_halving.FastClassifier" -> "sklearn.dummy.DummyClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_successive_halving.SometimesFailClassifier" -> "sklearn.dummy.DummyClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_successive_halving.test_base_estimator_inputs.FastClassifierBookKeeping" -> "sklearn.model_selection.tests.test_successive_halving.FastClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_validation.DataDependentFailingClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_validation.MockClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_validation.MockClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_validation.MockEstimatorWithParameter" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_validation.MockEstimatorWithSingleFitCallAllowed" -> "sklearn.model_selection.tests.test_validation.MockEstimatorWithParameter" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_validation.MockImprovingEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_validation.MockIncrementalImprovingEstimator" -> "sklearn.model_selection.tests.test_validation.MockImprovingEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.model_selection.tests.test_validation.RFWithDecisionFunction" -> "sklearn.ensemble._forest.RandomForestClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.multiclass.OneVsOneClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.multiclass.OneVsOneClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.multiclass.OneVsOneClassifier" -> "sklearn.base.MetaEstimatorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.multiclass.OneVsRestClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.multiclass.OneVsRestClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.multiclass.OneVsRestClassifier" -> "sklearn.base.MetaEstimatorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.multiclass.OneVsRestClassifier" -> "sklearn.base.MultiOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.multiclass.OutputCodeClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.multiclass.OutputCodeClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.multiclass.OutputCodeClassifier" -> "sklearn.base.MetaEstimatorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.multiclass._ConstantPredictor" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.multioutput.ClassifierChain" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.multioutput.ClassifierChain" -> "sklearn.base.MetaEstimatorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.multioutput.ClassifierChain" -> "sklearn.multioutput._BaseChain" [arrowhead="empty", arrowtail="none"];
"sklearn.multioutput.MultiOutputClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.multioutput.MultiOutputClassifier" -> "sklearn.multioutput._MultiOutputEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.multioutput.MultiOutputRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.multioutput.MultiOutputRegressor" -> "sklearn.multioutput._MultiOutputEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.multioutput.RegressorChain" -> "sklearn.base.MetaEstimatorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.multioutput.RegressorChain" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.multioutput.RegressorChain" -> "sklearn.multioutput._BaseChain" [arrowhead="empty", arrowtail="none"];
"sklearn.multioutput._BaseChain" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.multioutput._MultiOutputEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.multioutput._MultiOutputEstimator" -> "sklearn.base.MetaEstimatorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.naive_bayes.BernoulliNB" -> "sklearn.naive_bayes._BaseDiscreteNB" [arrowhead="empty", arrowtail="none"];
"sklearn.naive_bayes.CategoricalNB" -> "sklearn.naive_bayes._BaseDiscreteNB" [arrowhead="empty", arrowtail="none"];
"sklearn.naive_bayes.ComplementNB" -> "sklearn.naive_bayes._BaseDiscreteNB" [arrowhead="empty", arrowtail="none"];
"sklearn.naive_bayes.GaussianNB" -> "sklearn.naive_bayes._BaseNB" [arrowhead="empty", arrowtail="none"];
"sklearn.naive_bayes.MultinomialNB" -> "sklearn.naive_bayes._BaseDiscreteNB" [arrowhead="empty", arrowtail="none"];
"sklearn.naive_bayes._BaseDiscreteNB" -> "sklearn.naive_bayes._BaseNB" [arrowhead="empty", arrowtail="none"];
"sklearn.naive_bayes._BaseNB" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.naive_bayes._BaseNB" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._base.NeighborsBase" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._base.NeighborsBase" -> "sklearn.base.MultiOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._classification.KNeighborsClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._classification.KNeighborsClassifier" -> "sklearn.neighbors._base.KNeighborsMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._classification.KNeighborsClassifier" -> "sklearn.neighbors._base.NeighborsBase" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._classification.RadiusNeighborsClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._classification.RadiusNeighborsClassifier" -> "sklearn.neighbors._base.NeighborsBase" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._classification.RadiusNeighborsClassifier" -> "sklearn.neighbors._base.RadiusNeighborsMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._graph.KNeighborsTransformer" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._graph.KNeighborsTransformer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._graph.KNeighborsTransformer" -> "sklearn.neighbors._base.KNeighborsMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._graph.KNeighborsTransformer" -> "sklearn.neighbors._base.NeighborsBase" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._graph.RadiusNeighborsTransformer" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._graph.RadiusNeighborsTransformer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._graph.RadiusNeighborsTransformer" -> "sklearn.neighbors._base.NeighborsBase" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._graph.RadiusNeighborsTransformer" -> "sklearn.neighbors._base.RadiusNeighborsMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._kde.KernelDensity" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._lof.LocalOutlierFactor" -> "sklearn.base.OutlierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._lof.LocalOutlierFactor" -> "sklearn.neighbors._base.KNeighborsMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._lof.LocalOutlierFactor" -> "sklearn.neighbors._base.NeighborsBase" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._nca.NeighborhoodComponentsAnalysis" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._nca.NeighborhoodComponentsAnalysis" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._nca.NeighborhoodComponentsAnalysis" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._nearest_centroid.NearestCentroid" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._nearest_centroid.NearestCentroid" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._nearest_centroid.NearestCentroid" -> "sklearn.discriminant_analysis.DiscriminantAnalysisPredictionMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._regression.KNeighborsRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._regression.KNeighborsRegressor" -> "sklearn.neighbors._base.KNeighborsMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._regression.KNeighborsRegressor" -> "sklearn.neighbors._base.NeighborsBase" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._regression.RadiusNeighborsRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._regression.RadiusNeighborsRegressor" -> "sklearn.neighbors._base.NeighborsBase" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._regression.RadiusNeighborsRegressor" -> "sklearn.neighbors._base.RadiusNeighborsMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._unsupervised.NearestNeighbors" -> "sklearn.neighbors._base.KNeighborsMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._unsupervised.NearestNeighbors" -> "sklearn.neighbors._base.NeighborsBase" [arrowhead="empty", arrowtail="none"];
"sklearn.neighbors._unsupervised.NearestNeighbors" -> "sklearn.neighbors._base.RadiusNeighborsMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neural_network._multilayer_perceptron.BaseMultilayerPerceptron" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.neural_network._multilayer_perceptron.MLPClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neural_network._multilayer_perceptron.MLPClassifier" -> "sklearn.neural_network._multilayer_perceptron.BaseMultilayerPerceptron" [arrowhead="empty", arrowtail="none"];
"sklearn.neural_network._multilayer_perceptron.MLPRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neural_network._multilayer_perceptron.MLPRegressor" -> "sklearn.neural_network._multilayer_perceptron.BaseMultilayerPerceptron" [arrowhead="empty", arrowtail="none"];
"sklearn.neural_network._rbm.BernoulliRBM" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.neural_network._rbm.BernoulliRBM" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neural_network._rbm.BernoulliRBM" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.neural_network._stochastic_optimizers.AdamOptimizer" -> "sklearn.neural_network._stochastic_optimizers.BaseOptimizer" [arrowhead="empty", arrowtail="none"];
"sklearn.neural_network._stochastic_optimizers.SGDOptimizer" -> "sklearn.neural_network._stochastic_optimizers.BaseOptimizer" [arrowhead="empty", arrowtail="none"];
"sklearn.pipeline.FeatureUnion" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.pipeline.FeatureUnion" -> "sklearn.utils.metaestimators._BaseComposition" [arrowhead="empty", arrowtail="none"];
"sklearn.pipeline.Pipeline" -> "sklearn.utils.metaestimators._BaseComposition" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.Binarizer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.Binarizer" -> "sklearn.base.OneToOneFeatureMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.Binarizer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.KernelCenterer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.KernelCenterer" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.KernelCenterer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.MaxAbsScaler" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.MaxAbsScaler" -> "sklearn.base.OneToOneFeatureMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.MaxAbsScaler" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.MinMaxScaler" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.MinMaxScaler" -> "sklearn.base.OneToOneFeatureMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.MinMaxScaler" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.Normalizer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.Normalizer" -> "sklearn.base.OneToOneFeatureMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.Normalizer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.PowerTransformer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.PowerTransformer" -> "sklearn.base.OneToOneFeatureMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.PowerTransformer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.QuantileTransformer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.QuantileTransformer" -> "sklearn.base.OneToOneFeatureMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.QuantileTransformer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.RobustScaler" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.RobustScaler" -> "sklearn.base.OneToOneFeatureMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.RobustScaler" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.StandardScaler" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.StandardScaler" -> "sklearn.base.OneToOneFeatureMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._data.StandardScaler" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._discretization.KBinsDiscretizer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._discretization.KBinsDiscretizer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._encoders.OneHotEncoder" -> "sklearn.preprocessing._encoders._BaseEncoder" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._encoders.OrdinalEncoder" -> "sklearn.base.OneToOneFeatureMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._encoders.OrdinalEncoder" -> "sklearn.preprocessing._encoders._BaseEncoder" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._encoders._BaseEncoder" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._encoders._BaseEncoder" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._function_transformer.FunctionTransformer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._function_transformer.FunctionTransformer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._label.LabelBinarizer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._label.LabelBinarizer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._label.LabelEncoder" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._label.LabelEncoder" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._label.MultiLabelBinarizer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._label.MultiLabelBinarizer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._polynomial.PolynomialFeatures" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._polynomial.PolynomialFeatures" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._polynomial.SplineTransformer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._polynomial.SplineTransformer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._target_encoder.TargetEncoder" -> "sklearn.base.OneToOneFeatureMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.preprocessing._target_encoder.TargetEncoder" -> "sklearn.preprocessing._encoders._BaseEncoder" [arrowhead="empty", arrowtail="none"];
"sklearn.random_projection.BaseRandomProjection" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.random_projection.BaseRandomProjection" -> "sklearn.base.ClassNamePrefixFeaturesOutMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.random_projection.BaseRandomProjection" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.random_projection.GaussianRandomProjection" -> "sklearn.random_projection.BaseRandomProjection" [arrowhead="empty", arrowtail="none"];
"sklearn.random_projection.SparseRandomProjection" -> "sklearn.random_projection.BaseRandomProjection" [arrowhead="empty", arrowtail="none"];
"sklearn.semi_supervised._label_propagation.BaseLabelPropagation" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.semi_supervised._label_propagation.BaseLabelPropagation" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.semi_supervised._label_propagation.LabelPropagation" -> "sklearn.semi_supervised._label_propagation.BaseLabelPropagation" [arrowhead="empty", arrowtail="none"];
"sklearn.semi_supervised._label_propagation.LabelSpreading" -> "sklearn.semi_supervised._label_propagation.BaseLabelPropagation" [arrowhead="empty", arrowtail="none"];
"sklearn.semi_supervised._self_training.SelfTrainingClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.semi_supervised._self_training.SelfTrainingClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.semi_supervised._self_training.SelfTrainingClassifier" -> "sklearn.base.MetaEstimatorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.svm._base.BaseLibSVM" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.svm._base.BaseSVC" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.svm._base.BaseSVC" -> "sklearn.svm._base.BaseLibSVM" [arrowhead="empty", arrowtail="none"];
"sklearn.svm._classes.LinearSVC" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.svm._classes.LinearSVC" -> "sklearn.linear_model._base.LinearClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.svm._classes.LinearSVC" -> "sklearn.linear_model._base.SparseCoefMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.svm._classes.LinearSVR" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.svm._classes.LinearSVR" -> "sklearn.linear_model._base.LinearModel" [arrowhead="empty", arrowtail="none"];
"sklearn.svm._classes.NuSVC" -> "sklearn.svm._base.BaseSVC" [arrowhead="empty", arrowtail="none"];
"sklearn.svm._classes.NuSVR" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.svm._classes.NuSVR" -> "sklearn.svm._base.BaseLibSVM" [arrowhead="empty", arrowtail="none"];
"sklearn.svm._classes.OneClassSVM" -> "sklearn.base.OutlierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.svm._classes.OneClassSVM" -> "sklearn.svm._base.BaseLibSVM" [arrowhead="empty", arrowtail="none"];
"sklearn.svm._classes.SVC" -> "sklearn.svm._base.BaseSVC" [arrowhead="empty", arrowtail="none"];
"sklearn.svm._classes.SVR" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.svm._classes.SVR" -> "sklearn.svm._base.BaseLibSVM" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.ConsumingClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.ConsumingClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.ConsumingNoFitTransformTransformer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.ConsumingRegressor" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.ConsumingRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.ConsumingScorer" -> "sklearn.metrics._scorer._Scorer" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.ConsumingSplitter" -> "sklearn.model_selection._split.BaseCrossValidator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.ConsumingSplitter" -> "sklearn.model_selection._split.GroupsConsumerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.ConsumingTransformer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.ConsumingTransformer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.MetaRegressor" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.MetaRegressor" -> "sklearn.base.MetaEstimatorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.MetaRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.MetaTransformer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.MetaTransformer" -> "sklearn.base.MetaEstimatorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.MetaTransformer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.NonConsumingClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.NonConsumingClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.NonConsumingRegressor" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.NonConsumingRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.WeightedMetaClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.WeightedMetaClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.WeightedMetaClassifier" -> "sklearn.base.MetaEstimatorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.WeightedMetaRegressor" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.WeightedMetaRegressor" -> "sklearn.base.MetaEstimatorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.metadata_routing_common.WeightedMetaRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.Buggy" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.DiamondOverwriteTag" -> "sklearn.tests.test_base.NaNTag" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.DiamondOverwriteTag" -> "sklearn.tests.test_base.NoNaNTag" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.EmptyEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.EmptyEstimator" -> "sklearn.tests.test_base._Empty" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.InheritDiamondOverwriteTag" -> "sklearn.tests.test_base.DiamondOverwriteTag" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.K" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.ModifyInitParams" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.MultiInheritanceEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.MultiInheritanceEstimator" -> "sklearn.tests.test_base.DontPickleAttributeMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.MyEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.NaNTag" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.NoNaNTag" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.OverrideTag" -> "sklearn.tests.test_base.NaNTag" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.SingleInheritanceEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.T" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.TreeBadVersion" -> "sklearn.tree._classes.DecisionTreeClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.TreeNoVersion" -> "sklearn.tree._classes.DecisionTreeClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.VargEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.test_clone_pandas_dataframe.DummyEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.test_clone_pandas_dataframe.DummyEstimator" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.test_clone_protocol.FrozenEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.test_dataframe_protocol.NoOpTransformer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.test_dataframe_protocol.NoOpTransformer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.test_estimator_getstate_using_slots_error_message.Estimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.test_estimator_getstate_using_slots_error_message.Estimator" -> "sklearn.tests.test_base.test_estimator_getstate_using_slots_error_message.WithSlots" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.test_feature_names_in.NoOpTransformer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.test_feature_names_in.NoOpTransformer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.test_outlier_mixin_fit_predict_with_metadata_in_predict.CustomOutlierDetector" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.test_outlier_mixin_fit_predict_with_metadata_in_predict.CustomOutlierDetector" -> "sklearn.base.OutlierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.test_raises_on_get_params_non_attribute.MyEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.test_set_params_passes_all_parameters.TestDecisionTree" -> "sklearn.tree._classes.DecisionTreeClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.test_transformer_fit_transform_with_metadata_in_transform.CustomTransformer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.test_transformer_fit_transform_with_metadata_in_transform.CustomTransformer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.test_validate_data_skip_check_array.NoOpTransformer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_base.test_validate_data_skip_check_array.NoOpTransformer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_calibration.test_calibration_accepts_ndarray.MockTensorClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_calibration.test_calibration_accepts_ndarray.MockTensorClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_calibration.test_calibration_with_non_sample_aligned_fit_param.TestClassifier" -> "sklearn.linear_model._logistic.LogisticRegression" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_calibration.test_calibration_without_sample_weight_estimator.ClfWithoutSampleWeight" -> "sklearn.utils._mocking.CheckingClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_calibration.test_float32_predict_proba.DummyClassifer32" -> "sklearn.dummy.DummyClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_common.CallableEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_common.test_transition_public_api_deprecations.OldEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_metadata_routing.SimplePipeline" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_metadata_routing.test_composite_methods.SimpleEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_metadata_routing.test_default_request_override.Base" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_metadata_routing.test_default_request_override.Class_1" -> "sklearn.tests.test_metadata_routing.test_default_request_override.Base" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_metadata_routing.test_default_request_override.class_1" -> "sklearn.tests.test_metadata_routing.test_default_request_override.Base" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_metadata_routing.test_default_requests.OddEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_metadata_routing.test_estimator_warnings.ConsumingRegressorWarn" -> "sklearn.tests.metadata_routing_common.ConsumingRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_metadata_routing.test_get_metadata_routing.TestDefaults" -> "sklearn.utils._metadata_requests._MetadataRequester" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_metadata_routing.test_get_metadata_routing.TestDefaultsBadMethodName" -> "sklearn.utils._metadata_requests._MetadataRequester" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_metadata_routing.test_get_routing_for_object.Consumer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_metadata_routing.test_metaestimator_warnings.WeightedMetaRegressorWarn" -> "sklearn.tests.metadata_routing_common.WeightedMetaRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_metadata_routing.test_method_generation.SimpleEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_metadata_routing.test_no_metadata_always_works.Estimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_metadata_routing.test_no_metadata_always_works.Estimator" -> "sklearn.utils._metadata_requests._RoutingNotSupportedMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_metadata_routing.test_removing_non_existing_param_raises.InvalidRequestRemoval" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_metadata_routing.test_setting_default_requests.ExplicitRequest" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_metadata_routing.test_setting_default_requests.ExplicitRequestOverwrite" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_metadata_routing.test_setting_default_requests.ImplicitRequest" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_metadata_routing.test_setting_default_requests.ImplicitRequestRemoval" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_metadata_routing.test_unbound_set_methods_work.A" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_metaestimators.test_metaestimator_delegation.SubEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_multioutput.DummyClassifierWithFitParams" -> "sklearn.dummy.DummyClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_multioutput.DummyRegressorWithFitParams" -> "sklearn.dummy.DummyRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_multioutput.test_regressor_chain_w_fit_params.MySGD" -> "sklearn.linear_model._stochastic_gradient.SGDRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.DummyEstimatorParams" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.DummyTransf" -> "sklearn.tests.test_pipeline.Transf" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.FeatureNameSaver" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.FitParamT" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.Mult" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.Mult" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.NoFit" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.NoInvTransf" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.NoInvTransf" -> "sklearn.tests.test_pipeline.NoTrans" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.NoTrans" -> "sklearn.tests.test_pipeline.NoFit" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.SimpleEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.Transf" -> "sklearn.tests.test_pipeline.NoInvTransf" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.TransfFitParams" -> "sklearn.tests.test_pipeline.Transf" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.test_feature_union_fit_params.DummyTransformer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.test_feature_union_fit_params.DummyTransformer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.test_feature_union_fit_params_without_fit_transform.DummyTransformer" -> "sklearn.tests.metadata_routing_common.ConsumingNoFitTransformTransformer" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.test_pipeline_check_if_fitted.Estimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.test_pipeline_get_feature_names_out_passes_names_through.AddPrefixStandardScalar" -> "sklearn.preprocessing._data.StandardScaler" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.test_pipeline_warns_not_fitted.StatelessEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.test_transform_input_explicit_value_check.Estimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.test_transform_input_explicit_value_check.Estimator" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.test_transform_input_explicit_value_check.Transformer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.test_transform_input_explicit_value_check.Transformer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.test_transform_tuple_input.Estimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.test_transform_tuple_input.Estimator" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.test_transform_tuple_input.Transformer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tests.test_pipeline.test_transform_tuple_input.Transformer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tree._classes.BaseDecisionTree" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.tree._classes.BaseDecisionTree" -> "sklearn.base.MultiOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tree._classes.DecisionTreeClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tree._classes.DecisionTreeClassifier" -> "sklearn.tree._classes.BaseDecisionTree" [arrowhead="empty", arrowtail="none"];
"sklearn.tree._classes.DecisionTreeRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.tree._classes.DecisionTreeRegressor" -> "sklearn.tree._classes.BaseDecisionTree" [arrowhead="empty", arrowtail="none"];
"sklearn.tree._classes.ExtraTreeClassifier" -> "sklearn.tree._classes.DecisionTreeClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.tree._classes.ExtraTreeRegressor" -> "sklearn.tree._classes.DecisionTreeRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.tree._export._DOTTreeExporter" -> "sklearn.tree._export._BaseTreeExporter" [arrowhead="empty", arrowtail="none"];
"sklearn.tree._export._MPLTreeExporter" -> "sklearn.tree._export._BaseTreeExporter" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._mocking.CheckingClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._mocking.CheckingClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._mocking.NoSampleWeightWrapper" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._mocking._MockEstimatorOnOffPrediction" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._param_validation.HasMethods" -> "sklearn.utils._param_validation._Constraint" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._param_validation.Interval" -> "sklearn.utils._param_validation._Constraint" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._param_validation.MissingValues" -> "sklearn.utils._param_validation._Constraint" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._param_validation.Options" -> "sklearn.utils._param_validation._Constraint" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._param_validation.StrOptions" -> "sklearn.utils._param_validation.Options" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._param_validation._ArrayLikes" -> "sklearn.utils._param_validation._Constraint" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._param_validation._Booleans" -> "sklearn.utils._param_validation._Constraint" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._param_validation._CVObjects" -> "sklearn.utils._param_validation._Constraint" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._param_validation._Callables" -> "sklearn.utils._param_validation._Constraint" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._param_validation._InstancesOf" -> "sklearn.utils._param_validation._Constraint" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._param_validation._IterablesNotString" -> "sklearn.utils._param_validation._Constraint" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._param_validation._NanConstraint" -> "sklearn.utils._param_validation._Constraint" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._param_validation._NoneConstraint" -> "sklearn.utils._param_validation._Constraint" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._param_validation._PandasNAConstraint" -> "sklearn.utils._param_validation._Constraint" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._param_validation._RandomStates" -> "sklearn.utils._param_validation._Constraint" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._param_validation._SparseMatrices" -> "sklearn.utils._param_validation._Constraint" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._param_validation._VerboseHelper" -> "sklearn.utils._param_validation._Constraint" [arrowhead="empty", arrowtail="none"];
"sklearn.utils._pprint.KeyValTupleParam" -> "sklearn.utils._pprint.KeyValTuple" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.metaestimators._BaseComposition" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_array_api.SimpleEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_deprecation.MockClass5" -> "sklearn.utils.tests.test_deprecation.MockClass1" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.BadBalancedWeightsClassifier" -> "sklearn.utils.tests.test_estimator_checks.BaseBadClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.BadTransformerWithoutMixin" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.BaseBadClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.BaseBadClassifier" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.BrokenArrayAPI" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.ChangesDict" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.ChangesUnderscoreAttribute" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.ChangesWrongAttribute" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.CorrectNotFittedErrorClassifier" -> "sklearn.utils.tests.test_estimator_checks.BaseBadClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.EstimatorInconsistentForPandas" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.HasImmutableParameters" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.HasMutableParameters" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.LargeSparseNotSupportedClassifier" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.ModifiesAnotherValue" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.ModifiesValueInsteadOfRaisingError" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.NoCheckinPredict" -> "sklearn.utils.tests.test_estimator_checks.BaseBadClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.NoSampleWeightPandasSeriesType" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.NoSparseClassifier" -> "sklearn.utils.tests.test_estimator_checks.BaseBadClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.NotInvariantPredict" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.NotInvariantSampleOrder" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.OneClassSampleErrorClassifier" -> "sklearn.utils.tests.test_estimator_checks.BaseBadClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.PartialFitChecksName" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.PoorScoreLogisticRegression" -> "sklearn.linear_model._logistic.LogisticRegression" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.RaisesErrorInSetParams" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.RequiresPositiveXRegressor" -> "sklearn.linear_model._base.LinearRegression" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.RequiresPositiveYRegressor" -> "sklearn.linear_model._base.LinearRegression" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.SetsWrongAttribute" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.SparseTransformer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.SparseTransformer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.TaggedBinaryClassifier" -> "sklearn.utils.tests.test_estimator_checks.UntaggedBinaryClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.UntaggedBinaryClassifier" -> "sklearn.linear_model._stochastic_gradient.SGDClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks._BaseMultiLabelClassifierMock" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks._BaseMultiLabelClassifierMock" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_check_classifier_not_supporting_multiclass.BadEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_check_classifiers_multilabel_output_format_decision_function.MultiLabelClassifierDecisionFunction" -> "sklearn.utils.tests.test_estimator_checks._BaseMultiLabelClassifierMock" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_check_classifiers_multilabel_output_format_predict.MultiLabelClassifierPredict" -> "sklearn.utils.tests.test_estimator_checks._BaseMultiLabelClassifierMock" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_check_classifiers_multilabel_output_format_predict_proba.MultiLabelClassifierPredictProba" -> "sklearn.utils.tests.test_estimator_checks._BaseMultiLabelClassifierMock" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_check_estimator_cloneable_error.NotCloneable" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_check_estimator_sparse_tag.EstimatorWithSparseConfig" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_check_fit_check_is_fitted.Estimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_check_fit_score_takes_y_works_on_deprecated_fit.TestEstimatorWithDeprecatedFitMethod" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_check_mixin_order.BadEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_check_mixin_order.BadEstimator" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_check_no_attributes_set_in_init.ConformantEstimatorClassAttribute" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_check_no_attributes_set_in_init.NonConformantEstimatorNoParamSet" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_check_no_attributes_set_in_init.NonConformantEstimatorPrivateSet" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_check_outlier_contamination.OutlierDetectorWithConstraint" -> "sklearn.utils.tests.test_estimator_checks.test_check_outlier_contamination.OutlierDetectorWithoutConstraint" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_check_outlier_contamination.OutlierDetectorWithoutConstraint" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_check_outlier_contamination.OutlierDetectorWithoutConstraint" -> "sklearn.base.OutlierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_check_positive_only_tag_during_fit.RequiresPositiveXBadTag" -> "sklearn.utils.tests.test_estimator_checks.RequiresPositiveXRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_check_requires_y_none.Estimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_estimator_repr_error.NotRepr" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_non_deterministic_estimator_skip_tests.MyEstimator" -> "sklearn.utils._testing.MinimalClassifier" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_non_deterministic_estimator_skip_tests.MyEstimator" -> "sklearn.utils._testing.MinimalRegressor" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_checks.test_non_deterministic_estimator_skip_tests.MyEstimator" -> "sklearn.utils._testing.MinimalTransformer" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_html_repr.test_estimator_html_repr_unfitted_vs_fitted.MyEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_html_repr.test_html_documentation_link_mixin_doc_link_url_param_generator_class.FooBar" -> "sklearn.utils._estimator_html_repr._HTMLDocumentationLinkMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_html_repr.test_html_documentation_link_mixin_get_doc_link_class.FooBar" -> "sklearn.utils._estimator_html_repr._HTMLDocumentationLinkMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_estimator_html_repr.test_html_documentation_link_mixin_get_doc_link_instance.FooBar" -> "sklearn.utils._estimator_html_repr._HTMLDocumentationLinkMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_parallel.test_dispatch_config_parallel.TransformerRequiredDataFrame" -> "sklearn.preprocessing._data.StandardScaler" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_param_validation._Estimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_param_validation.test_third_party_estimator.ThirdPartyEstimator" -> "sklearn.utils.tests.test_param_validation._Estimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_pprint.CountVectorizer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_pprint.GridSearchCV" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_pprint.LogisticRegression" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_pprint.NMF" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_pprint.PCA" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_pprint.Pipeline" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_pprint.RFE" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_pprint.SVC" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_pprint.SimpleImputer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_pprint.StandardScaler" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_pprint.StandardScaler" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_pprint.test_complexity_print_changed_only.DummyEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_pprint.test_complexity_print_changed_only.DummyEstimator" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_pprint.test_kwargs_in_init.WithKWargs" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_set_output.EstimatorNoSetOutputWithTransformNoFeatureNamesOut" -> "sklearn.utils._set_output._SetOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_set_output.EstimatorReturnTuple" -> "sklearn.utils._set_output._SetOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_set_output.EstimatorWithListInput" -> "sklearn.utils._set_output._SetOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_set_output.EstimatorWithSetOutput" -> "sklearn.utils._set_output._SetOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_set_output.EstimatorWithSetOutputIndex" -> "sklearn.utils._set_output._SetOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_set_output.EstimatorWithSetOutputNoAutoWrap" -> "sklearn.utils._set_output._SetOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_set_output.test_auto_wrap_output_keys_errors_with_incorrect_input.BadEstimator" -> "sklearn.utils._set_output._SetOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_set_output.test_set_output_mixin_custom_mixin.BothMixinEstimator" -> "sklearn.utils._set_output._SetOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_set_output.test_set_output_mixin_custom_mixin.BothMixinEstimator" -> "sklearn.utils.tests.test_set_output.AnotherMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_set_output.test_set_output_mro.A" -> "sklearn.utils.tests.test_set_output.test_set_output_mro.Base" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_set_output.test_set_output_mro.B" -> "sklearn.utils.tests.test_set_output.test_set_output_mro.Base" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_set_output.test_set_output_mro.Base" -> "sklearn.utils._set_output._SetOutputMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_set_output.test_set_output_mro.C" -> "sklearn.utils.tests.test_set_output.test_set_output_mro.A" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_set_output.test_set_output_mro.C" -> "sklearn.utils.tests.test_set_output.test_set_output_mro.B" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.EmptyRegressor" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.EmptyRegressor" -> "sklearn.base.RegressorMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.EmptyTransformer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.EmptyTransformer" -> "sklearn.base.TransformerMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.PredictorNewTags" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.PredictorOldNewTags" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.PredictorOldTags" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test__get_tags_backward_compatibility.ChildClass" -> "sklearn.utils.tests.test_tags.MixinAllowNanNewTags" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test__get_tags_backward_compatibility.ChildClass" -> "sklearn.utils.tests.test_tags.MixinAllowNanOldNewTags" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test__get_tags_backward_compatibility.ChildClass" -> "sklearn.utils.tests.test_tags.MixinAllowNanOldTags" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test__get_tags_backward_compatibility.ChildClass" -> "sklearn.utils.tests.test_tags.PredictorNewTags" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test__get_tags_backward_compatibility.ChildClass" -> "sklearn.utils.tests.test_tags.PredictorOldNewTags" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test__get_tags_backward_compatibility.ChildClass" -> "sklearn.utils.tests.test_tags.PredictorOldTags" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test_get_tags_backward_compatibility.ChildClass" -> "sklearn.utils.tests.test_tags.MixinAllowNanNewTags" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test_get_tags_backward_compatibility.ChildClass" -> "sklearn.utils.tests.test_tags.MixinAllowNanOldNewTags" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test_get_tags_backward_compatibility.ChildClass" -> "sklearn.utils.tests.test_tags.MixinAllowNanOldTags" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test_get_tags_backward_compatibility.ChildClass" -> "sklearn.utils.tests.test_tags.PredictorNewTags" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test_get_tags_backward_compatibility.ChildClass" -> "sklearn.utils.tests.test_tags.PredictorOldNewTags" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test_get_tags_backward_compatibility.ChildClass" -> "sklearn.utils.tests.test_tags.PredictorOldTags" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test_no___sklearn_tags__with_more_tags.MoreTagsEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test_safe_tags_backward_compatibility.ChildClass" -> "sklearn.utils.tests.test_tags.MixinAllowNanNewTags" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test_safe_tags_backward_compatibility.ChildClass" -> "sklearn.utils.tests.test_tags.MixinAllowNanOldNewTags" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test_safe_tags_backward_compatibility.ChildClass" -> "sklearn.utils.tests.test_tags.MixinAllowNanOldTags" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test_safe_tags_backward_compatibility.ChildClass" -> "sklearn.utils.tests.test_tags.PredictorNewTags" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test_safe_tags_backward_compatibility.ChildClass" -> "sklearn.utils.tests.test_tags.PredictorOldNewTags" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test_safe_tags_backward_compatibility.ChildClass" -> "sklearn.utils.tests.test_tags.PredictorOldTags" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test_tag_test_passes_with_inheritance.MyEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test_tag_test_passes_with_inheritance.MyTags" -> "sklearn.utils._tags.Tags" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test_tags_no_sklearn_tags_concrete_implementation.MyEstimator" -> "sklearn.base.ClassifierMixin" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test_tags_no_sklearn_tags_concrete_implementation.MyEstimator2" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_tags.test_tags_no_sklearn_tags_concrete_implementation.MyEstimator2" -> "sklearn.utils.tests.test_tags.test_tags_no_sklearn_tags_concrete_implementation.MyEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_validation.PassthroughTransformer" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_validation.test_check_is_fitted_attributes.MyEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_validation.test_check_is_fitted_stateless.StatelessEstimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn.utils.tests.test_validation.test_check_is_fitted_with_is_fitted.Estimator" -> "sklearn.base.BaseEstimator" [arrowhead="empty", arrowtail="none"];
"sklearn._loss.link.Interval" -> "sklearn._loss.link.BaseLink" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interval_y_pred", style="solid"];
"sklearn._loss.link.Interval" -> "sklearn._loss.link.HalfLogitLink" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interval_y_pred", style="solid"];
"sklearn._loss.link.Interval" -> "sklearn._loss.link.LogLink" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interval_y_pred", style="solid"];
"sklearn._loss.link.Interval" -> "sklearn._loss.link.LogitLink" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interval_y_pred", style="solid"];
"sklearn._loss.link.Interval" -> "sklearn._loss.link.MultinomialLogit" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interval_y_pred", style="solid"];
"sklearn._loss.link.Interval" -> "sklearn._loss.loss.BaseLoss" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interval_y_true", style="solid"];
"sklearn._loss.link.Interval" -> "sklearn._loss.loss.ExponentialLoss" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interval_y_true", style="solid"];
"sklearn._loss.link.Interval" -> "sklearn._loss.loss.HalfBinomialLoss" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interval_y_true", style="solid"];
"sklearn._loss.link.Interval" -> "sklearn._loss.loss.HalfGammaLoss" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interval_y_true", style="solid"];
"sklearn._loss.link.Interval" -> "sklearn._loss.loss.HalfMultinomialLoss" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interval_y_true", style="solid"];
"sklearn._loss.link.Interval" -> "sklearn._loss.loss.HalfMultinomialLoss" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interval_y_pred", style="solid"];
"sklearn._loss.link.Interval" -> "sklearn._loss.loss.HalfPoissonLoss" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interval_y_true", style="solid"];
"sklearn._loss.link.Interval" -> "sklearn._loss.loss.HalfTweedieLoss" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interval_y_true", style="solid"];
"sklearn._loss.link.Interval" -> "sklearn._loss.loss.HalfTweedieLoss" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interval_y_true", style="solid"];
"sklearn._loss.link.Interval" -> "sklearn._loss.loss.HalfTweedieLoss" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interval_y_true", style="solid"];
"sklearn._loss.link.Interval" -> "sklearn._loss.loss.HalfTweedieLossIdentity" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interval_y_true", style="solid"];
"sklearn._loss.link.Interval" -> "sklearn._loss.loss.HalfTweedieLossIdentity" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interval_y_true", style="solid"];
"sklearn._loss.link.Interval" -> "sklearn._loss.loss.HalfTweedieLossIdentity" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interval_y_true", style="solid"];
"sklearn._loss.link.Interval" -> "sklearn._loss.loss.HalfTweedieLossIdentity" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interval_y_pred", style="solid"];
"sklearn._loss.link.Interval" -> "sklearn._loss.loss.HalfTweedieLossIdentity" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interval_y_pred", style="solid"];
"sklearn._loss.loss.HalfSquaredError" -> "sklearn.linear_model._glm.glm._GeneralizedLinearRegressor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_base_loss", style="solid"];
"sklearn.cluster._birch._CFNode" -> "sklearn.cluster._birch.Birch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="root_", style="solid"];
"sklearn.cluster._birch._CFNode" -> "sklearn.cluster._birch.Birch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="root_", style="solid"];
"sklearn.cluster._birch._CFNode" -> "sklearn.cluster._birch.Birch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dummy_leaf_", style="solid"];
"sklearn.cluster._birch._CFNode" -> "sklearn.cluster._birch._CFNode" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="prev_leaf_", style="solid"];
"sklearn.cluster._birch._CFNode" -> "sklearn.cluster._birch._CFNode" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="next_leaf_", style="solid"];
"sklearn.cluster._bisect_k_means._BisectingTree" -> "sklearn.cluster._bisect_k_means.BisectingKMeans" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_bisecting_tree", style="solid"];
"sklearn.cluster._bisect_k_means._BisectingTree" -> "sklearn.cluster._bisect_k_means._BisectingTree" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="left", style="solid"];
"sklearn.cluster._bisect_k_means._BisectingTree" -> "sklearn.cluster._bisect_k_means._BisectingTree" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="right", style="solid"];
"sklearn.compose._column_transformer.ColumnTransformer" -> "sklearn.ensemble._hist_gradient_boosting.gradient_boosting.BaseHistGradientBoosting" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_preprocessor", style="solid"];
"sklearn.decomposition._kernel_pca.KernelPCA" -> "sklearn.manifold._isomap.Isomap" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="kernel_pca_", style="solid"];
"sklearn.dummy.DummyClassifier" -> "sklearn.ensemble._gb.BaseGradientBoosting" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="init_", style="solid"];
"sklearn.dummy.DummyClassifier" -> "sklearn.ensemble.tests.test_stacking.NoWeightClassifier" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="clf", style="solid"];
"sklearn.dummy.DummyRegressor" -> "sklearn.ensemble._gb.BaseGradientBoosting" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="init_", style="solid"];
"sklearn.dummy.DummyRegressor" -> "sklearn.ensemble._gb.BaseGradientBoosting" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="init_", style="solid"];
"sklearn.dummy.DummyRegressor" -> "sklearn.ensemble._gb.BaseGradientBoosting" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="init_", style="solid"];
"sklearn.dummy.DummyRegressor" -> "sklearn.ensemble.tests.test_stacking.NoWeightRegressor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="reg", style="solid"];
"sklearn.ensemble._hist_gradient_boosting.binning._BinMapper" -> "sklearn.ensemble._hist_gradient_boosting.gradient_boosting.BaseHistGradientBoosting" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_bin_mapper", style="solid"];
"sklearn.ensemble._hist_gradient_boosting.grower.TreeNode" -> "sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="root", style="solid"];
"sklearn.feature_extraction.text.TfidfTransformer" -> "sklearn.feature_extraction.text.TfidfVectorizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_tfidf", style="solid"];
"sklearn.feature_extraction.text.TfidfTransformer" -> "sklearn.feature_extraction.text.TfidfVectorizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_tfidf", style="solid"];
"sklearn.feature_extraction.text.TfidfTransformer" -> "sklearn.feature_extraction.text.TfidfVectorizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_tfidf", style="solid"];
"sklearn.gaussian_process._gpc._BinaryGaussianProcessClassifierLaplace" -> "sklearn.gaussian_process._gpc.GaussianProcessClassifier" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="base_estimator_", style="solid"];
"sklearn.gaussian_process.kernels.Product" -> "sklearn.gaussian_process._gpc._BinaryGaussianProcessClassifierLaplace" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="kernel_", style="solid"];
"sklearn.gaussian_process.kernels.Product" -> "sklearn.gaussian_process._gpr.GaussianProcessRegressor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="kernel_", style="solid"];
"sklearn.impute._base.MissingIndicator" -> "sklearn.impute._base._BaseImputer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="indicator_", style="solid"];
"sklearn.impute._base.SimpleImputer" -> "sklearn.impute._iterative.IterativeImputer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="initial_imputer_", style="solid"];
"sklearn.linear_model._base.LinearRegression" -> "sklearn.compose._target.TransformedTargetRegressor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="regressor_", style="solid"];
"sklearn.linear_model._bayes.BayesianRidge" -> "sklearn.impute._iterative.IterativeImputer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_estimator", style="solid"];
"sklearn.metrics._scorer._CurveScorer" -> "sklearn.model_selection._classification_threshold.TunedThresholdClassifierCV" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_curve_scorer", style="solid"];
"sklearn.metrics._scorer._Scorer" -> "sklearn.ensemble._hist_gradient_boosting.gradient_boosting.BaseHistGradientBoosting" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_scorer", style="solid"];
"sklearn.model_selection._split.KFold" -> "sklearn.model_selection._search_successive_halving.BaseSuccessiveHalving" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_checked_cv_orig", style="solid"];
"sklearn.model_selection._split.StratifiedKFold" -> "sklearn.model_selection._search_successive_halving.BaseSuccessiveHalving" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_checked_cv_orig", style="solid"];
"sklearn.model_selection._split._CVIterableWrapper" -> "sklearn.model_selection._search_successive_halving.BaseSuccessiveHalving" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_checked_cv_orig", style="solid"];
"sklearn.multiclass.OneVsOneClassifier" -> "sklearn.gaussian_process._gpc.GaussianProcessClassifier" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="base_estimator_", style="solid"];
"sklearn.multiclass.OneVsRestClassifier" -> "sklearn.gaussian_process._gpc.GaussianProcessClassifier" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="base_estimator_", style="solid"];
"sklearn.neighbors._nca.NeighborhoodComponentsAnalysis" -> "sklearn.neighbors.tests.test_nca.test_expected_transformation_shape.TransformationStorer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fake_nca", style="solid"];
"sklearn.neighbors._nca.NeighborhoodComponentsAnalysis" -> "sklearn.neighbors.tests.test_nca.test_toy_example_collapse_points.LossStorer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fake_nca", style="solid"];
"sklearn.neighbors._unsupervised.NearestNeighbors" -> "sklearn.manifold._isomap.Isomap" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="nbrs_", style="solid"];
"sklearn.neighbors._unsupervised.NearestNeighbors" -> "sklearn.manifold._locally_linear.LocallyLinearEmbedding" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="nbrs_", style="solid"];
"sklearn.neighbors._unsupervised.NearestNeighbors" -> "sklearn.semi_supervised._label_propagation.BaseLabelPropagation" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="nn_fit", style="solid"];
"sklearn.neural_network._stochastic_optimizers.AdamOptimizer" -> "sklearn.neural_network._multilayer_perceptron.BaseMultilayerPerceptron" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_optimizer", style="solid"];
"sklearn.neural_network._stochastic_optimizers.SGDOptimizer" -> "sklearn.neural_network._multilayer_perceptron.BaseMultilayerPerceptron" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_optimizer", style="solid"];
"sklearn.preprocessing._data.KernelCenterer" -> "sklearn.decomposition._kernel_pca.KernelPCA" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_centerer", style="solid"];
"sklearn.preprocessing._data.StandardScaler" -> "sklearn.preprocessing._data.PowerTransformer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_scaler", style="solid"];
"sklearn.preprocessing._encoders.OneHotEncoder" -> "sklearn.ensemble._forest.RandomTreesEmbedding" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="one_hot_encoder_", style="solid"];
"sklearn.preprocessing._encoders.OneHotEncoder" -> "sklearn.preprocessing._discretization.KBinsDiscretizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_encoder", style="solid"];
"sklearn.preprocessing._function_transformer.FunctionTransformer" -> "sklearn.compose._target.TransformedTargetRegressor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="transformer_", style="solid"];
"sklearn.preprocessing._label.LabelBinarizer" -> "sklearn.linear_model._ridge._RidgeClassifierMixin" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_label_binarizer", style="solid"];
"sklearn.preprocessing._label.LabelBinarizer" -> "sklearn.multiclass.OneVsRestClassifier" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="label_binarizer_", style="solid"];
"sklearn.preprocessing._label.LabelBinarizer" -> "sklearn.multiclass.OneVsRestClassifier" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="label_binarizer_", style="solid"];
"sklearn.preprocessing._label.LabelBinarizer" -> "sklearn.neural_network._multilayer_perceptron.MLPClassifier" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_label_binarizer", style="solid"];
"sklearn.preprocessing._label.LabelBinarizer" -> "sklearn.neural_network._multilayer_perceptron.MLPClassifier" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_label_binarizer", style="solid"];
"sklearn.preprocessing._label.LabelEncoder" -> "sklearn.ensemble._stacking.StackingClassifier" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_label_encoder", style="solid"];
"sklearn.preprocessing._label.LabelEncoder" -> "sklearn.ensemble._voting.VotingClassifier" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="le_", style="solid"];
"sklearn.svm._classes.SVC" -> "sklearn.feature_selection.tests.test_rfe.test_RFE_fit_score_params.TestEstimator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="svc_", style="solid"];
"sklearn.utils._available_if._AvailableIfDescriptor" -> "sklearn.neighbors._nearest_centroid.NearestCentroid" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="decision_function", style="solid"];
"sklearn.utils._available_if._AvailableIfDescriptor" -> "sklearn.neighbors._nearest_centroid.NearestCentroid" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="predict_proba", style="solid"];
"sklearn.utils._available_if._AvailableIfDescriptor" -> "sklearn.neighbors._nearest_centroid.NearestCentroid" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="predict_log_proba", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.ensemble._stacking._BaseStacking" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="named_estimators_", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.ensemble._voting._BaseVoting" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="named_estimators_", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="splitter", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="splitter", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="splitter", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="splitter", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="splitter", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="splitter", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="splitter", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="splitter", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="splitter", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="estimator", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="estimator", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="estimator", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="estimator", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="estimator", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="estimator", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="estimator", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="estimator", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="final_estimator_", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="final_estimator_", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scorer", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scorer", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scorer", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scorer", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scorer", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scorer", style="solid"];
"sklearn.utils._bunch.Bunch" -> "sklearn.utils._bunch.Bunch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scorer", style="solid"];
"sklearn.utils._metadata_requests.MetadataRequest" -> "sklearn.metrics._scorer._BaseScorer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_metadata_request", style="solid"];
"sklearn.utils._mocking.ArraySlicingWrapper" -> "sklearn.utils._mocking.MockDataFrame" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="iloc", style="solid"];
"sklearn.utils._tags.InputTags" -> "sklearn.utils._tags.Tags" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="input_tags", style="solid"];
"sklearn.utils._tags.TargetTags" -> "sklearn.utils._tags.Tags" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="target_tags", style="solid"];
"sklearn.utils.tests.test_array_api.test_device_inspection.Device" -> "sklearn.utils.tests.test_array_api.test_device_inspection.Array" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="device", style="solid"];
"sklearn.cluster._birch._CFNode" -> "sklearn.cluster._birch._CFSubcluster" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="child_", style="solid"];
"sklearn.cluster._birch._CFNode" -> "sklearn.cluster._birch._CFSubcluster" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="child_", style="solid"];
"sklearn.linear_model._linear_loss.LinearModelLoss" -> "sklearn.linear_model._glm._newton_solver.NewtonSolver" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="linear_loss", style="solid"];
"sklearn.metrics._scorer._Scorer" -> "sklearn.model_selection._search.BaseSearchCV" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="scorer_", style="solid"];
"sklearn.tree._export.Sentinel" -> "sklearn.tree._export._DOTTreeExporter" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="out_file", style="solid"];
"sklearn.tree._reingold_tilford.DrawTree" -> "sklearn.tree._reingold_tilford.DrawTree" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="ancestor", style="solid"];
"sklearn.utils._metadata_requests.MetadataRequest" -> "sklearn.metrics._scorer._PassthroughScorer" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_metadata_request", style="solid"];
}
